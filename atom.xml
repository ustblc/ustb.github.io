<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>lemon</title>
  
  <subtitle>一直在路上</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cblog.club/"/>
  <updated>2019-12-23T14:08:53.414Z</updated>
  <id>https://cblog.club/</id>
  
  <author>
    <name>lemon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>让同一个git管理gitee和github</title>
    <link href="https://cblog.club/ck4iio1v5007db8g4gkzcg2rm.html"/>
    <id>https://cblog.club/ck4iio1v5007db8g4gkzcg2rm.html</id>
    <published>2019-12-23T14:04:30.000Z</published>
    <updated>2019-12-23T14:08:53.414Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景:"></a>使用场景:</h3><p> 同一个git需要管理gitee和给github,但是gitee和github需要不同的公钥进行连接</p><h3 id="生成SSH-Key"><a href="#生成SSH-Key" class="headerlink" title="生成SSH Key"></a>生成SSH Key</h3><p>首先生成gitee的SSH Key</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"你的邮箱"</span></span><br></pre></td></tr></table></figure><p>接下来一直回车,大概按三次就会成功生成了.然后打开 <code>C:/Users/user(个人用户目录下)找到</code>~/.ssh/id_rsa.pub<code>用任何可疑打开的编辑器打开</code>id_rsa.pub`复制里面的内容,到gitee里面的SSH Key粘贴就行了.</p><p>测试成功与否</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@gitee.com</span><br><span class="line">//出现这段话就说明连接成功</span><br><span class="line">Hi xxx! You<span class="string">'ve successfully authenticated, but GITEE.COM does not provide shell access.</span></span><br></pre></td></tr></table></figure><p>生成github的SH Key,<code>注意!</code>这个时候,要进入到.ssh文件夹中打开<code>Git Bash Here</code>,然后按照默认方式生成SH Key</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"xxx@qq.com"</span>//填写你的邮箱</span><br><span class="line">//当出现这段话的时候,要在后面改一下文件名</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/c/Users/Administrator/.ssh/id_rsa):</span><br><span class="line">//改成这样</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/c/Users/Administrator/.ssh/id_rsa):id_rsa_github</span><br></pre></td></tr></table></figure><p>接下来还是和上一次一样一直回车,这个时候在<code>ssh</code>这个目录已经有四个文件了,分别是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id_rsa</span><br><span class="line">id_rsa.pub          //这两个文件是gitee的</span><br><span class="line">id_rsa_github</span><br><span class="line">id_rsa_github.pub   //这两个是github的</span><br></pre></td></tr></table></figure><p>​    接下来和gitee粘贴SH Key一样,打开id_rsa_github.pub,把里面的内容,粘贴到github中的SSH Key管理中</p><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>​    <code>重要的一步来了</code>在<code>.ssh</code>文件夹中新建一个<code>config</code>的文件,注意这个文件<code>没有后缀</code>文件名就是config,然后粘贴下面的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gitee</span></span><br><span class="line">Host gitee.com</span><br><span class="line">HostName gitee.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line"></span><br><span class="line"><span class="comment"># github</span></span><br><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_github</span><br></pre></td></tr></table></figure><p>​    测试成功与否</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//测试gitee</span><br><span class="line">ssh -T git@gitee.com</span><br><span class="line">//出现这段话就说明连接成功</span><br><span class="line">Hi xxx! You<span class="string">'ve successfully authenticated, but GITEE.COM does not provide shell access.</span></span><br><span class="line"><span class="string">//测试 github</span></span><br><span class="line"><span class="string">ssh -T git@github.com</span></span><br><span class="line"><span class="string">//出现这段话就说明连接成功</span></span><br><span class="line"><span class="string">Hi xxx! You'</span>ve successfully authenticated, but GitHub does not provide shell access.</span><br><span class="line"></span><br><span class="line">//出现这段话说明连接失败</span><br><span class="line">Permission denied (publickey).</span><br><span class="line">// 连接失败解决办法</span><br><span class="line">1.检查config里面的文件名是否正确</span><br><span class="line"> 2.有时候是因为网络原因,重新测试即可</span><br></pre></td></tr></table></figure><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>​    没啥原理,就是通过配置config文件,让不同的连接代理到不同的公钥上</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景:&quot;&gt;&lt;/a&gt;使用场景:&lt;/h3&gt;&lt;p&gt; 同一个git需要管理gitee和给github,但是gitee和github需要不同的公钥进行连接&lt;/p&gt;
&lt;h3 i
      
    
    </summary>
    
    
      <category term="Git" scheme="https://cblog.club/categories/Git/"/>
    
    
      <category term="Git" scheme="https://cblog.club/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>329矩阵中的最长递增路径</title>
    <link href="https://cblog.club/ck4iio1rm0021b8g4e0n2bi5t.html"/>
    <id>https://cblog.club/ck4iio1rm0021b8g4e0n2bi5t.html</id>
    <published>2019-12-08T05:19:15.000Z</published>
    <updated>2019-12-08T05:24:02.281Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定一个整数矩阵，找出最长递增路径的长度。</p><p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。</p><a id="more"></a><blockquote><p>示例 1:</p><p>输入: nums =<br>[<br>  [9,9,4],<br>  [6,6,8],<br>  [2,1,1]<br>]<br>输出: 4<br>解释: 最长递增路径为 [1, 2, 6, 9]。<br>示例 2:</p><p>输入: nums =<br>[<br>  [3,4,5],<br>  [3,2,6],<br>  [2,2,1]<br>]<br>输出: 4<br>解释: 最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。</p></blockquote><h6 id="解题思路：本题刚开始想的就是DP，想两次DP，因为之前做过一道两次DP的题目，但是此题不对的，找了很久BUG，你用DP的前提就是，后算的必须是以前算的为依赖的，如果之前算的，后来还可能更新，那就不能使用DP的，得需要处理，所以耽搁了很长时间-！然后看官方题解，发现使用DFS-记忆化即可，记忆化的思想就很像cache，保存已有的值，那么下次需要取，就不用再DFS了，就会节省很长的时间。（这一题还是需要再看，感觉很好的题目）"><a href="#解题思路：本题刚开始想的就是DP，想两次DP，因为之前做过一道两次DP的题目，但是此题不对的，找了很久BUG，你用DP的前提就是，后算的必须是以前算的为依赖的，如果之前算的，后来还可能更新，那就不能使用DP的，得需要处理，所以耽搁了很长时间-！然后看官方题解，发现使用DFS-记忆化即可，记忆化的思想就很像cache，保存已有的值，那么下次需要取，就不用再DFS了，就会节省很长的时间。（这一题还是需要再看，感觉很好的题目）" class="headerlink" title="解题思路：本题刚开始想的就是DP，想两次DP，因为之前做过一道两次DP的题目，但是此题不对的，找了很久BUG，你用DP的前提就是，后算的必须是以前算的为依赖的，如果之前算的，后来还可能更新，那就不能使用DP的，得需要处理，所以耽搁了很长时间= =！然后看官方题解，发现使用DFS+记忆化即可，记忆化的思想就很像cache，保存已有的值，那么下次需要取，就不用再DFS了，就会节省很长的时间。（这一题还是需要再看，感觉很好的题目）"></a>解题思路：本题刚开始想的就是DP，想两次DP，因为之前做过一道两次DP的题目，但是此题不对的，找了很久BUG，你用DP的前提就是，后算的必须是以前算的为依赖的，如果之前算的，后来还可能更新，那就不能使用DP的，得需要处理，所以耽搁了很长时间= =！然后看官方题解，发现使用DFS+记忆化即可，记忆化的思想就很像cache，保存已有的值，那么下次需要取，就不用再DFS了，就会节省很长的时间。（这一题还是需要再看，感觉很好的题目）</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> cur_max=INT_MIN;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> row=matrix.size();</span><br><span class="line">        <span class="keyword">if</span>(row==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col=matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;visited(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line">                result=max(result,DFS(matrix,i,j,visited));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp;visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[i][j]!=<span class="number">0</span>)<span class="keyword">return</span> visited[i][j];</span><br><span class="line">        <span class="keyword">int</span> row=matrix.size();</span><br><span class="line">        <span class="keyword">int</span> col=matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="comment">//定义四个方向</span></span><br><span class="line">        <span class="keyword">int</span> direct[<span class="number">2</span>][<span class="number">4</span>]=&#123;&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> nexti,nextj;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)&#123;</span><br><span class="line">            nexti=i+direct[<span class="number">0</span>][k];</span><br><span class="line">            nextj=j+direct[<span class="number">1</span>][k];</span><br><span class="line">            <span class="keyword">int</span> cur_val=matrix[i][j];</span><br><span class="line">            <span class="keyword">if</span>(nexti&gt;=<span class="number">0</span>&amp;&amp;nexti&lt;row&amp;&amp;nextj&gt;=<span class="number">0</span>&amp;&amp;nextj&lt;col&amp;&amp;matrix[nexti][nextj]&gt;cur_val)&#123;</span><br><span class="line">                visited[i][j]=max(visited[i][j],DFS(matrix,nexti,nextj,visited));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ++visited[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;给定一个整数矩阵，找出最长递增路径的长度。&lt;/p&gt;
&lt;p&gt;对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="DFS" scheme="https://cblog.club/categories/leetcode/DFS/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="DFS" scheme="https://cblog.club/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>230二叉搜索树中第K小的元素</title>
    <link href="https://cblog.club/ck4iio1ra001lb8g4hx1s5hp5.html"/>
    <id>https://cblog.club/ck4iio1ra001lb8g4hx1s5hp5.html</id>
    <published>2019-12-08T05:08:16.000Z</published>
    <updated>2019-12-08T05:18:38.454Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定一个二叉搜索树，编写一个函数 <code>kthSmallest</code> 来查找其中第 <strong>k</strong> 个最小的元素。</p><p><strong>说明：</strong><br>你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。</p><a id="more"></a><blockquote><p>示例 1:</p><p>输入: root = [3,1,4,null,2], k = 1<br>   3<br>  / <br> 1   4<br>  <br>   2<br>输出: 1<br>示例 2:</p><p>输入: root = [5,3,6,2,4,null,null,1], k = 3<br>       5<br>      / <br>     3   6<br>    / <br>   2   4<br>  /<br> 1<br>输出: 3<br>进阶：<br>如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 kthSmallest 函数？</p></blockquote><h6 id="解题思路：本题刚开始竟然没有想到中序遍历-，真的有点蠢了，我用的是一个优先队列，长度为k，队头始终就是第k小的结点，始终保持队列大小为k，升序。但是后来发现，中序遍历不就行了-！因为二叉搜索树的中序遍历就是递增的序列，那样找第K个即可。"><a href="#解题思路：本题刚开始竟然没有想到中序遍历-，真的有点蠢了，我用的是一个优先队列，长度为k，队头始终就是第k小的结点，始终保持队列大小为k，升序。但是后来发现，中序遍历不就行了-！因为二叉搜索树的中序遍历就是递增的序列，那样找第K个即可。" class="headerlink" title="解题思路：本题刚开始竟然没有想到中序遍历= =，真的有点蠢了，我用的是一个优先队列，长度为k，队头始终就是第k小的结点，始终保持队列大小为k，升序。但是后来发现，中序遍历不就行了= =！因为二叉搜索树的中序遍历就是递增的序列，那样找第K个即可。"></a>解题思路：本题刚开始竟然没有想到中序遍历= =，真的有点蠢了，我用的是一个优先队列，长度为k，队头始终就是第k小的结点，始终保持队列大小为k，升序。但是后来发现，中序遍历不就行了= =！因为二叉搜索树的中序遍历就是递增的序列，那样找第K个即可。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//法一：优先队列，不如中序方便，但是也好理解。</span></span><br><span class="line"><span class="comment">//定义自定义比较函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(TreeNode* a, TreeNode* b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a-&gt;val&lt;b-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个优先队列，降序</span></span><br><span class="line">        priority_queue&lt;TreeNode*,<span class="built_in">vector</span>&lt;TreeNode*&gt;,cmp&gt;pq;</span><br><span class="line">        <span class="comment">//定义一个队列，用于层次遍历</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt;q;</span><br><span class="line">        TreeNode* cur;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            cur=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            pq.push(cur);</span><br><span class="line">            <span class="keyword">if</span>(pq.size()&gt;k)pq.pop();</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left)q.push(cur-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right)q.push(cur-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result=pq.top()-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//法二，中序非递归：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个队列，用于层次遍历</span></span><br><span class="line">        <span class="keyword">int</span> count,result;</span><br><span class="line">        count=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt;node;</span><br><span class="line">        TreeNode*p=root;</span><br><span class="line">        <span class="keyword">while</span>(!node.empty()||p)&#123;</span><br><span class="line">            <span class="keyword">while</span>(p)&#123;</span><br><span class="line">                node.push(p);</span><br><span class="line">                p=p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            p=node.top();</span><br><span class="line">            node.pop();</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(count==k)result=p-&gt;val;</span><br><span class="line">            p=p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;给定一个二叉搜索树，编写一个函数 &lt;code&gt;kthSmallest&lt;/code&gt; 来查找其中第 &lt;strong&gt;k&lt;/strong&gt; 个最小的元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;br&gt;你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="二叉树" scheme="https://cblog.club/categories/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="二叉树" scheme="https://cblog.club/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>297二叉树的序列化和反序列化</title>
    <link href="https://cblog.club/ck4iio1rh001tb8g49s0e6pkv.html"/>
    <id>https://cblog.club/ck4iio1rh001tb8g49s0e6pkv.html</id>
    <published>2019-12-08T04:57:40.000Z</published>
    <updated>2019-12-08T05:06:37.352Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p><p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><a id="more"></a><blockquote><p>示例: </p><p>你可以将以下二叉树：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">4</span>   <span class="number">5</span></span><br></pre></td></tr></table></figure><p>序列化为 “[1,2,3,null,null,4,5]”<br>提示: 这与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p><p>说明: 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。</p></blockquote><h6 id="解题思路：本题还是花费了不少的时间，刚开始想的使用每个字符的判断吗，还要分数字是否为负数，包括几位，太麻烦了。借鉴了别人的做法之后，觉得还真的是挺好的，处理起来也不麻烦。主要思想就是：将二叉树编码成字符串时，每个节点之间用空格隔断，空结点用n代替，返回这样要个字符串，等到将字符串转换成二叉树的时候，采用stringstreamline，他的一大特点就是自动隔断字符串中的空格，那这样就好办了，每次都用一个字符串接收即可，判断他是空结点还是正常节点，遍历顺序均采用的是层次遍历，这样在转换的时候，个人感觉更简单一点，其实每一种遍历都可以，他是双向的过程。"><a href="#解题思路：本题还是花费了不少的时间，刚开始想的使用每个字符的判断吗，还要分数字是否为负数，包括几位，太麻烦了。借鉴了别人的做法之后，觉得还真的是挺好的，处理起来也不麻烦。主要思想就是：将二叉树编码成字符串时，每个节点之间用空格隔断，空结点用n代替，返回这样要个字符串，等到将字符串转换成二叉树的时候，采用stringstreamline，他的一大特点就是自动隔断字符串中的空格，那这样就好办了，每次都用一个字符串接收即可，判断他是空结点还是正常节点，遍历顺序均采用的是层次遍历，这样在转换的时候，个人感觉更简单一点，其实每一种遍历都可以，他是双向的过程。" class="headerlink" title="解题思路：本题还是花费了不少的时间，刚开始想的使用每个字符的判断吗，还要分数字是否为负数，包括几位，太麻烦了。借鉴了别人的做法之后，觉得还真的是挺好的，处理起来也不麻烦。主要思想就是：将二叉树编码成字符串时，每个节点之间用空格隔断，空结点用n代替，返回这样要个字符串，等到将字符串转换成二叉树的时候，采用stringstreamline，他的一大特点就是自动隔断字符串中的空格，那这样就好办了，每次都用一个字符串接收即可，判断他是空结点还是正常节点，遍历顺序均采用的是层次遍历，这样在转换的时候，个人感觉更简单一点，其实每一种遍历都可以，他是双向的过程。"></a>解题思路：本题还是花费了不少的时间，刚开始想的使用每个字符的判断吗，还要分数字是否为负数，包括几位，太麻烦了。借鉴了别人的做法之后，觉得还真的是挺好的，处理起来也不麻烦。主要思想就是：将二叉树编码成字符串时，每个节点之间用空格隔断，空结点用n代替，返回这样要个字符串，等到将字符串转换成二叉树的时候，采用stringstreamline，他的一大特点就是自动隔断字符串中的空格，那这样就好办了，每次都用一个字符串接收即可，判断他是空结点还是正常节点，遍历顺序均采用的是层次遍历，这样在转换的时候，个人感觉更简单一点，其实每一种遍历都可以，他是双向的过程。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> str;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt;node;</span><br><span class="line">        node.push(root);</span><br><span class="line">        TreeNode*p;</span><br><span class="line">        <span class="keyword">while</span>(!node.empty())&#123;</span><br><span class="line">            p=node.front();</span><br><span class="line">            node.pop();</span><br><span class="line">            <span class="keyword">if</span>(p)&#123;</span><br><span class="line">                str+=to_string(p-&gt;val);</span><br><span class="line">                node.push(p-&gt;left);</span><br><span class="line">                node.push(p-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> str+=<span class="string">"n"</span>;</span><br><span class="line">            str+=<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data==<span class="string">""</span>)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt;node;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(data)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        ss &gt;&gt; str;</span><br><span class="line">        TreeNode*head=<span class="keyword">new</span> TreeNode(stoi(str));</span><br><span class="line">        node.push(head);</span><br><span class="line">        <span class="keyword">while</span>(!node.empty())&#123;</span><br><span class="line">            TreeNode*cur=node.front();</span><br><span class="line">            node.pop();</span><br><span class="line">            ss &gt;&gt; str;</span><br><span class="line">            <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">'n'</span>)cur-&gt;left=<span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;left=<span class="keyword">new</span> TreeNode(stoi(str));</span><br><span class="line">                node.push(cur-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            ss &gt;&gt; str;</span><br><span class="line">            <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">'n'</span>)cur-&gt;right=<span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;right=<span class="keyword">new</span> TreeNode(stoi(str));</span><br><span class="line">                node.push(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。&lt;/p&gt;
&lt;p&gt;请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="二叉树" scheme="https://cblog.club/categories/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="二叉树" scheme="https://cblog.club/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>59螺旋矩阵II</title>
    <link href="https://cblog.club/ck4iio1tg004nb8g473grgc74.html"/>
    <id>https://cblog.club/ck4iio1tg004nb8g473grgc74.html</id>
    <published>2019-12-05T14:46:19.000Z</published>
    <updated>2019-12-05T14:49:54.840Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定一个正整数 <em>n</em>，生成一个包含 1 到 <em>n</em>2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p><a id="more"></a><blockquote><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">3</span></span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line"> [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ],</span><br><span class="line"> [ <span class="number">8</span>, <span class="number">9</span>, <span class="number">4</span> ],</span><br><span class="line"> [ <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span> ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：之前做过螺旋矩阵的话，这一题就比较简单了，主要还是在于模拟整个过程，以及相应的边界判断以及走过的位置。（方向上的模拟数组，已经用过很多次了，这种形式感觉还是不错的）。"><a href="#解题思路：之前做过螺旋矩阵的话，这一题就比较简单了，主要还是在于模拟整个过程，以及相应的边界判断以及走过的位置。（方向上的模拟数组，已经用过很多次了，这种形式感觉还是不错的）。" class="headerlink" title="解题思路：之前做过螺旋矩阵的话，这一题就比较简单了，主要还是在于模拟整个过程，以及相应的边界判断以及走过的位置。（方向上的模拟数组，已经用过很多次了，这种形式感觉还是不错的）。"></a>解题思路：之前做过螺旋矩阵的话，这一题就比较简单了，主要还是在于模拟整个过程，以及相应的边界判断以及走过的位置。（方向上的模拟数组，已经用过很多次了，这种形式感觉还是不错的）。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;result(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">int</span> cur_x,cur_y,next_x,next_y,count,dir;</span><br><span class="line">        cur_x=cur_y=dir=<span class="number">0</span>;</span><br><span class="line">        count=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//定义四个方向</span></span><br><span class="line">        <span class="keyword">int</span> direct[<span class="number">2</span>][<span class="number">4</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span>(count&lt;n*n)&#123;</span><br><span class="line">            result[cur_x][cur_y]=count;</span><br><span class="line">            <span class="comment">//取下一个元素</span></span><br><span class="line">            next_x=cur_x+direct[<span class="number">0</span>][dir];</span><br><span class="line">            next_y=cur_y+direct[<span class="number">1</span>][dir];</span><br><span class="line">            <span class="comment">//判断此位置是否合适</span></span><br><span class="line">            <span class="keyword">if</span>(next_x&gt;=<span class="number">0</span>&amp;&amp;next_x&lt;n&amp;&amp;next_y&gt;=<span class="number">0</span>&amp;&amp;next_y&lt;n&amp;&amp;result[next_x][next_y]==<span class="number">0</span>)&#123;</span><br><span class="line">                cur_x=next_x;</span><br><span class="line">                cur_y=next_y;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//转向</span></span><br><span class="line">            <span class="keyword">else</span> dir=(dir+<span class="number">1</span>)%<span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result[cur_x][cur_y]=count;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;给定一个正整数 &lt;em&gt;n&lt;/em&gt;，生成一个包含 1 到 &lt;em&gt;n&lt;/em&gt;2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>394字符串解码</title>
    <link href="https://cblog.club/ck4iio1s8002lb8g4h71s3vx8.html"/>
    <id>https://cblog.club/ck4iio1s8002lb8g4h71s3vx8.html</id>
    <published>2019-12-05T14:36:18.000Z</published>
    <updated>2019-12-05T14:45:47.608Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <em>encoded_string</em> 正好重复 <em>k</em> 次。注意 <em>k</em> 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <em>k</em> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p><a id="more"></a><blockquote><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"3[a]2[bc]"</span>, 返回 <span class="string">"aaabcbc"</span>.</span><br><span class="line">s = <span class="string">"3[a2[c]]"</span>, 返回 <span class="string">"accaccacc"</span>.</span><br><span class="line">s = <span class="string">"2[abc]3[cd]ef"</span>, 返回 <span class="string">"abcabccdcdcdef"</span>.</span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：本题主要在于模拟整个过程，数据结构的话很容易就会想到栈，这一题主要采用双栈（一个数字栈，一个当字符串栈），自己在做的时候，感觉思路比较乱，难以统一，从而导致做题就会磕磕巴巴，还是在于没有模拟出整个规律，对于当前字符，一共有四种可能性，首先要注意的是，数字有可能不是一位的，而是多位的，那这就要求我们在对数字转换成十进制的时候要注意-！个人感觉这个比较好的栈相关的题目，要留意一下。"><a href="#解题思路：本题主要在于模拟整个过程，数据结构的话很容易就会想到栈，这一题主要采用双栈（一个数字栈，一个当字符串栈），自己在做的时候，感觉思路比较乱，难以统一，从而导致做题就会磕磕巴巴，还是在于没有模拟出整个规律，对于当前字符，一共有四种可能性，首先要注意的是，数字有可能不是一位的，而是多位的，那这就要求我们在对数字转换成十进制的时候要注意-！个人感觉这个比较好的栈相关的题目，要留意一下。" class="headerlink" title="解题思路：本题主要在于模拟整个过程，数据结构的话很容易就会想到栈，这一题主要采用双栈（一个数字栈，一个当字符串栈），自己在做的时候，感觉思路比较乱，难以统一，从而导致做题就会磕磕巴巴，还是在于没有模拟出整个规律，对于当前字符，一共有四种可能性，首先要注意的是，数字有可能不是一位的，而是多位的，那这就要求我们在对数字转换成十进制的时候要注意= =！个人感觉这个比较好的栈相关的题目，要留意一下。"></a>解题思路：本题主要在于模拟整个过程，数据结构的话很容易就会想到栈，这一题主要采用双栈（一个数字栈，一个当字符串栈），自己在做的时候，感觉思路比较乱，难以统一，从而导致做题就会磕磕巴巴，还是在于没有模拟出整个规律，对于当前字符，一共有四种可能性，首先要注意的是，数字有可能不是一位的，而是多位的，那这就要求我们在对数字转换成十进制的时候要注意= =！个人感觉这个比较好的栈相关的题目，要留意一下。</h6><ul><li>当前字符是数字，继续计算</li><li>当前字符是字母，当前字符串+</li><li>当前是左括号，将当前字符串和当前的数字入栈，并且将当前数字和字符串清0</li><li>如果是右括号，将数字出栈，当前这个数字就是字符串栈+当前字符串的次数，最后赋值给结果字符串</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decodeString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;times;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt;str;</span><br><span class="line">        <span class="built_in">string</span> result=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> cur_num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="comment">//如果当前字符是数字，继续计算</span></span><br><span class="line">            <span class="keyword">if</span>(s[i]&gt;=<span class="string">'0'</span>&amp;&amp;s[i]&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">                cur_num=cur_num*<span class="number">10</span>+(s[i]-<span class="string">'0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果是左括号，数字和当前字符串进栈</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">'['</span>)&#123;</span><br><span class="line">                str.push(result);</span><br><span class="line">                times.push(cur_num);</span><br><span class="line">                cur_num=<span class="number">0</span>;</span><br><span class="line">                result=<span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果是右括号，就该出栈</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">']'</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> time=times.top();</span><br><span class="line">                times.pop();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;time;j++)&#123;</span><br><span class="line">                    str.top()+=result;</span><br><span class="line">                &#125;</span><br><span class="line">                result=str.top();</span><br><span class="line">                str.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//正常字母</span></span><br><span class="line">            <span class="keyword">else</span> result+=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;给定一个经过编码的字符串，返回它解码后的字符串。&lt;/p&gt;
&lt;p&gt;编码规则为: &lt;code&gt;k[encoded_string]&lt;/code&gt;，表示其中方括号内部的 &lt;em&gt;encoded_string&lt;/em&gt; 正好重复 &lt;em&gt;k&lt;/em&gt; 次。注意 &lt;em&gt;k&lt;/em&gt; 保证为正整数。&lt;/p&gt;
&lt;p&gt;你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。&lt;/p&gt;
&lt;p&gt;此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 &lt;em&gt;k&lt;/em&gt; ，例如不会出现像 &lt;code&gt;3a&lt;/code&gt; 或 &lt;code&gt;2[4]&lt;/code&gt; 的输入。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="栈" scheme="https://cblog.club/categories/leetcode/%E6%A0%88/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="栈" scheme="https://cblog.club/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>733图像渲染</title>
    <link href="https://cblog.club/ck4iio1ta004cb8g4bce7fa9h.html"/>
    <id>https://cblog.club/ck4iio1ta004cb8g4bce7fa9h.html</id>
    <published>2019-12-05T14:30:43.000Z</published>
    <updated>2019-12-05T14:57:57.874Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。</p><p>给你一个坐标 <code>(sr, sc)</code> 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 <code>newColor</code>，让你重新上色这幅图像。</p><p>为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。</p><p>最后返回经过上色渲染后的图像。</p><a id="more"></a><blockquote><p><strong>示例 1:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">image = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">sr = <span class="number">1</span>, sc = <span class="number">1</span>, newColor = <span class="number">2</span></span><br><span class="line">输出: [[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">解析: </span><br><span class="line">在图像的正中间，(坐标(sr,sc)=(<span class="number">1</span>,<span class="number">1</span>)),</span><br><span class="line">在路径上所有符合条件的像素点的颜色都被更改成<span class="number">2</span>。</span><br><span class="line">注意，右下角的像素没有更改为<span class="number">2</span>，</span><br><span class="line">因为它不是在上下左右四个方向上与初始点相连的像素点。</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><code>image</code> 和 <code>image[0]</code> 的长度在范围 <code>[1, 50]</code> 内。</li><li>给出的初始点将满足 <code>0 &lt;= sr &lt; image.length</code> 和 <code>0 &lt;= sc &lt; image[0].length</code>。</li><li><code>image[i][j]</code> 和 <code>newColor</code> 表示的颜色值在范围 <code>[0, 65535]</code>内。</li></ul></blockquote><h6 id="解题思路：本题就是最典型的DFS和BFS搜索，如果是DFS，那就是每走一步，就改成新的颜色数字。如果是BFS，那就是每次都将上下左右四个点中符合要求的入队列，然后出队渲染即可。"><a href="#解题思路：本题就是最典型的DFS和BFS搜索，如果是DFS，那就是每走一步，就改成新的颜色数字。如果是BFS，那就是每次都将上下左右四个点中符合要求的入队列，然后出队渲染即可。" class="headerlink" title="解题思路：本题就是最典型的DFS和BFS搜索，如果是DFS，那就是每走一步，就改成新的颜色数字。如果是BFS，那就是每次都将上下左右四个点中符合要求的入队列，然后出队渲染即可。"></a>解题思路：本题就是最典型的DFS和BFS搜索，如果是DFS，那就是每走一步，就改成新的颜色数字。如果是BFS，那就是每次都将上下左右四个点中符合要求的入队列，然后出队渲染即可。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    vector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int newColor) &#123;</span></span><br><span class="line"><span class="comment">        queue&lt;pair&lt;int,int&gt;&gt;q;</span></span><br><span class="line"><span class="comment">        q.push(&#123;sr,sc&#125;);</span></span><br><span class="line"><span class="comment">        int row=image.size();</span></span><br><span class="line"><span class="comment">        int col=image[0].size();</span></span><br><span class="line"><span class="comment">        //定义上下左右四个方向</span></span><br><span class="line"><span class="comment">        int direct[2][4]=&#123;&#123;-1,0,1,0&#125;,&#123;0,1,0,-1&#125;&#125;;</span></span><br><span class="line"><span class="comment">        int original_color=image[sr][sc];</span></span><br><span class="line"><span class="comment">        while(!q.empty())&#123;</span></span><br><span class="line"><span class="comment">            pair&lt;int,int&gt;cur=q.front();</span></span><br><span class="line"><span class="comment">            q.pop();</span></span><br><span class="line"><span class="comment">            int cur_r,cur_c,next_r,next_c;</span></span><br><span class="line"><span class="comment">            cur_r=cur.first;</span></span><br><span class="line"><span class="comment">            cur_c=cur.second;</span></span><br><span class="line"><span class="comment">            image[cur_r][cur_c]=newColor;</span></span><br><span class="line"><span class="comment">            for(int i=0;i&lt;4;i++)&#123;</span></span><br><span class="line"><span class="comment">                next_r=cur_r+direct[0][i];</span></span><br><span class="line"><span class="comment">                next_c=cur_c+direct[1][i];</span></span><br><span class="line"><span class="comment">                //判断是否越界和是否和初始值元素相同</span></span><br><span class="line"><span class="comment">                if(next_r&gt;=0&amp;&amp;next_r&lt;row&amp;&amp;next_c&gt;=0&amp;&amp;next_c&lt;col&amp;&amp;image[next_r][next_c]==original_color&amp;&amp;image[next_r][next_c]!=newColor)q.push(&#123;next_r,next_c&#125;);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return image;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; floodFill(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line">        <span class="keyword">int</span> original_color=image[sr][sc];</span><br><span class="line">        DFS(image,sr,sc,newColor,original_color);</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; image,<span class="keyword">int</span> sr, <span class="keyword">int</span> sc,<span class="keyword">int</span> newColor,<span class="keyword">int</span> original_color)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row=image.size();</span><br><span class="line">        <span class="keyword">int</span> col=image[<span class="number">0</span>].size();</span><br><span class="line">        <span class="comment">//越界要先判断，不然数组会越界</span></span><br><span class="line">        <span class="keyword">if</span>(sr&lt;<span class="number">0</span>||sr&gt;=row||sc&lt;<span class="number">0</span>||sc&gt;=col)<span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//修改过了、不需要修改、和初始元素值不一样</span></span><br><span class="line">        <span class="keyword">if</span>(image[sr][sc]==newColor||image[sr][sc]!=original_color)<span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//定义上下左右四个方向</span></span><br><span class="line">        <span class="keyword">int</span> direct[<span class="number">2</span>][<span class="number">4</span>]=&#123;&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> next_r,next_c;</span><br><span class="line">        image[sr][sc]=newColor;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            next_r=sr+direct[<span class="number">0</span>][i];</span><br><span class="line">            next_c=sc+direct[<span class="number">1</span>][i];</span><br><span class="line">            DFS(image,next_r,next_c,newColor,original_color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。&lt;/p&gt;
&lt;p&gt;给你一个坐标 &lt;code&gt;(sr, sc)&lt;/code&gt; 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 &lt;code&gt;newColor&lt;/code&gt;，让你重新上色这幅图像。&lt;/p&gt;
&lt;p&gt;为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。&lt;/p&gt;
&lt;p&gt;最后返回经过上色渲染后的图像。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="BFS" scheme="https://cblog.club/categories/leetcode/BFS/"/>
    
      <category term="DFS" scheme="https://cblog.club/categories/leetcode/BFS/DFS/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="DFS" scheme="https://cblog.club/tags/DFS/"/>
    
      <category term="BFS" scheme="https://cblog.club/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>124二叉树中的最大路径和</title>
    <link href="https://cblog.club/ck4iio1qe000db8g4bay166h4.html"/>
    <id>https://cblog.club/ck4iio1qe000db8g4bay166h4.html</id>
    <published>2019-12-04T13:51:42.000Z</published>
    <updated>2019-12-04T13:59:43.935Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定一个<strong>非空</strong>二叉树，返回其最大路径和。</p><p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径<strong>至少包含一个</strong>节点，且不一定经过根节点。</p><a id="more"></a><blockquote><p>示例 1:</p><p>输入: [1,2,3]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">3</span></span><br></pre></td></tr></table></figure><p>输出: 6<br>示例 2:</p><p>输入: [-10,9,20,null,null,15,7]</p><p>   -10<br>   / <br>  9  20<br>    /  <br>   15   7</p><p>输出: 42</p></blockquote><h6 id="解题思路：本题呢，个人感觉难度并不是很大，Hard的话，不太够格-，比较明显的就是树形DP的感觉，主要分为四种情况，代码中有体现，但是呢，做的时候还是BUG很多，只是考虑情况并不是很全面-！后序递归比较简单，个人又换了一种后序迭代，但是时间上并没有提升多少-！"><a href="#解题思路：本题呢，个人感觉难度并不是很大，Hard的话，不太够格-，比较明显的就是树形DP的感觉，主要分为四种情况，代码中有体现，但是呢，做的时候还是BUG很多，只是考虑情况并不是很全面-！后序递归比较简单，个人又换了一种后序迭代，但是时间上并没有提升多少-！" class="headerlink" title="解题思路：本题呢，个人感觉难度并不是很大，Hard的话，不太够格- -，比较明显的就是树形DP的感觉，主要分为四种情况，代码中有体现，但是呢，做的时候还是BUG很多，只是考虑情况并不是很全面= =！后序递归比较简单，个人又换了一种后序迭代，但是时间上并没有提升多少= =！"></a>解题思路：本题呢，个人感觉难度并不是很大，Hard的话，不太够格- -，比较明显的就是树形DP的感觉，主要分为四种情况，代码中有体现，但是呢，做的时候还是BUG很多，只是考虑情况并不是很全面= =！后序递归比较简单，个人又换了一种后序迭代，但是时间上并没有提升多少= =！</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int result=-INT_MAX;</span></span><br><span class="line"><span class="comment">    int maxPathSum(TreeNode* root) &#123;</span></span><br><span class="line"><span class="comment">        postorder(root);</span></span><br><span class="line"><span class="comment">        return result;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    void postorder(TreeNode* root)&#123;</span></span><br><span class="line"><span class="comment">        if(root)&#123;</span></span><br><span class="line"><span class="comment">            //后序的遍历方式</span></span><br><span class="line"><span class="comment">            postorder(root-&gt;left);</span></span><br><span class="line"><span class="comment">            postorder(root-&gt;right);</span></span><br><span class="line"><span class="comment">            //如果有左右孩子</span></span><br><span class="line"><span class="comment">            if(root-&gt;left&amp;&amp;root-&gt;right)&#123;</span></span><br><span class="line"><span class="comment">                int cur_val=root-&gt;val+max(root-&gt;left-&gt;val,root-&gt;right-&gt;val);</span></span><br><span class="line"><span class="comment">                if(cur_val&gt;root-&gt;val)root-&gt;val=cur_val;</span></span><br><span class="line"><span class="comment">                //以当前结点为根时，该节点所在路径的最大值还有可能包括左节点</span></span><br><span class="line"><span class="comment">                int cur_min=root-&gt;val+min(root-&gt;left-&gt;val,root-&gt;right-&gt;val);</span></span><br><span class="line"><span class="comment">                if(cur_min&gt;root-&gt;val&amp;&amp;cur_min&gt;result)result=cur_min;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            //只有左孩子</span></span><br><span class="line"><span class="comment">            else if(root-&gt;left) root-&gt;val=max(root-&gt;val+root-&gt;left-&gt;val,root-&gt;val);</span></span><br><span class="line"><span class="comment">            //只有右孩子</span></span><br><span class="line"><span class="comment">            else if(root-&gt;right) root-&gt;val=max(root-&gt;val+root-&gt;right-&gt;val,root-&gt;val);</span></span><br><span class="line"><span class="comment">            //没有孩子</span></span><br><span class="line"><span class="comment">            else root-&gt;val=root-&gt;val;</span></span><br><span class="line"><span class="comment">            if(root-&gt;val&gt;result)result=root-&gt;val;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="comment">//迭代版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=-INT_MAX;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode *&gt;S;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode *&gt;vt;</span><br><span class="line">        S.push(root);</span><br><span class="line">        TreeNode*cur;</span><br><span class="line">        <span class="keyword">while</span>(!S.empty())&#123;</span><br><span class="line">            cur=S.top();</span><br><span class="line">            S.pop();</span><br><span class="line">            vt.push_back(cur);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left)S.push(cur-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right)S.push(cur-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(vt.begin(),vt.end());</span><br><span class="line">        <span class="keyword">int</span> cur_min,cur_val;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vt.size();i++)&#123;</span><br><span class="line">            cur=vt[i];</span><br><span class="line">            <span class="comment">//如果有左右孩子</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left&amp;&amp;cur-&gt;right)&#123;</span><br><span class="line">                cur_val=cur-&gt;val+max(cur-&gt;left-&gt;val,cur-&gt;right-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(cur_val&gt;cur-&gt;val)cur-&gt;val=cur_val;</span><br><span class="line">                <span class="comment">//以当前结点为根时，该节点所在路径的最大值还有可能包括左节点</span></span><br><span class="line">                cur_min=cur-&gt;val+min(cur-&gt;left-&gt;val,cur-&gt;right-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(cur_min&gt;cur-&gt;val&amp;&amp;cur_min&gt;result)result=cur_min;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//只有左孩子</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;left) cur-&gt;val=max(cur-&gt;val+cur-&gt;left-&gt;val,cur-&gt;val);</span><br><span class="line">            <span class="comment">//只有右孩子</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;right) cur-&gt;val=max(cur-&gt;val+cur-&gt;right-&gt;val,cur-&gt;val);</span><br><span class="line">            <span class="comment">//没有孩子</span></span><br><span class="line">            <span class="keyword">else</span> cur-&gt;val=cur-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val&gt;result)result=cur-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;给定一个&lt;strong&gt;非空&lt;/strong&gt;二叉树，返回其最大路径和。&lt;/p&gt;
&lt;p&gt;本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径&lt;strong&gt;至少包含一个&lt;/strong&gt;节点，且不一定经过根节点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/categories/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>89格雷编码</title>
    <link href="https://cblog.club/ck4iio1tn004xb8g4a9yafnvl.html"/>
    <id>https://cblog.club/ck4iio1tn004xb8g4a9yafnvl.html</id>
    <published>2019-12-04T13:39:34.000Z</published>
    <updated>2019-12-04T13:50:59.932Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。</p><p>给定一个代表编码总位数的非负整数 <em>n</em>，打印其格雷编码序列。格雷编码序列必须以 0 开头。</p><a id="more"></a><blockquote><p><strong>示例 1:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">2</span></span><br><span class="line">输出: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">解释:</span><br><span class="line"><span class="number">00</span> - <span class="number">0</span></span><br><span class="line"><span class="number">01</span> - <span class="number">1</span></span><br><span class="line"><span class="number">11</span> - <span class="number">3</span></span><br><span class="line"><span class="number">10</span> - <span class="number">2</span></span><br><span class="line"></span><br><span class="line">对于给定的 n，其格雷编码序列并不唯一。</span><br><span class="line">例如，[<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>] 也是一个有效的格雷编码序列。</span><br><span class="line"></span><br><span class="line"><span class="number">00</span> - <span class="number">0</span></span><br><span class="line"><span class="number">10</span> - <span class="number">2</span></span><br><span class="line"><span class="number">11</span> - <span class="number">3</span></span><br><span class="line"><span class="number">01</span> - <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">0</span></span><br><span class="line">输出: [<span class="number">0</span>]</span><br><span class="line">解释: 我们定义格雷编码序列必须以 <span class="number">0</span> 开头。</span><br><span class="line">     给定编码总位数为 n 的格雷编码序列，其长度为 <span class="number">2</span>n。当 n = <span class="number">0</span> 时，长度为 <span class="number">20</span> = <span class="number">1</span>。</span><br><span class="line">     因此，当 n = <span class="number">0</span> 时，其格雷编码序列为 [<span class="number">0</span>]。</span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：做本题时，就想到做过的开锁哪一题，这两题差不多，格雷编码要注意他的一个条件就是每次只能改变一个数字，那这样，我就先生成一个n的全0字符串，然后递归从最后一位开始变，将遍历过的字符串添加到hash-set中，以备去重，然后当前元素改完之后，在hash-set中找到该字符串，就代表不能再修改这一位了，所以将其回溯到之前状态，并修改为不同的值，然后递归之后，觉得还能不能修改，利用BFS思想呢？然后又想到了一种方法，就是每次将字符串入队列，然后出队计算成十进制插入到结果数组，出对之后，再每次只改变他的其中一位，再次入队（必须是没访问过的），以此类推，直到队列结束，一定会全部走完（手动模拟一下）。"><a href="#解题思路：做本题时，就想到做过的开锁哪一题，这两题差不多，格雷编码要注意他的一个条件就是每次只能改变一个数字，那这样，我就先生成一个n的全0字符串，然后递归从最后一位开始变，将遍历过的字符串添加到hash-set中，以备去重，然后当前元素改完之后，在hash-set中找到该字符串，就代表不能再修改这一位了，所以将其回溯到之前状态，并修改为不同的值，然后递归之后，觉得还能不能修改，利用BFS思想呢？然后又想到了一种方法，就是每次将字符串入队列，然后出队计算成十进制插入到结果数组，出对之后，再每次只改变他的其中一位，再次入队（必须是没访问过的），以此类推，直到队列结束，一定会全部走完（手动模拟一下）。" class="headerlink" title="解题思路：做本题时，就想到做过的开锁哪一题，这两题差不多，格雷编码要注意他的一个条件就是每次只能改变一个数字，那这样，我就先生成一个n的全0字符串，然后递归从最后一位开始变，将遍历过的字符串添加到hash set中，以备去重，然后当前元素改完之后，在hash set中找到该字符串，就代表不能再修改这一位了，所以将其回溯到之前状态，并修改为不同的值，然后递归之后，觉得还能不能修改，利用BFS思想呢？然后又想到了一种方法，就是每次将字符串入队列，然后出队计算成十进制插入到结果数组，出对之后，再每次只改变他的其中一位，再次入队（必须是没访问过的），以此类推，直到队列结束，一定会全部走完（手动模拟一下）。"></a>解题思路：做本题时，就想到做过的开锁哪一题，这两题差不多，格雷编码要注意他的一个条件就是每次只能改变一个数字，那这样，我就先生成一个n的全0字符串，然后递归从最后一位开始变，将遍历过的字符串添加到hash set中，以备去重，然后当前元素改完之后，在hash set中找到该字符串，就代表不能再修改这一位了，所以将其回溯到之前状态，并修改为不同的值，然后递归之后，觉得还能不能修改，利用BFS思想呢？然后又想到了一种方法，就是每次将字符串入队列，然后出队计算成十进制插入到结果数组，出对之后，再<strong>每次只改变他的其中一位</strong>，再次入队（必须是没访问过的），以此类推，直到队列结束，一定会全部走完（手动模拟一下）。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    vector&lt;int&gt; grayCode(int n) &#123;</span></span><br><span class="line"><span class="comment">        string str=string(n,'0');</span></span><br><span class="line"><span class="comment">        vector&lt;int&gt;result;</span></span><br><span class="line"><span class="comment">        unordered_set&lt;string&gt;visited;</span></span><br><span class="line"><span class="comment">        getGray(n,str,result,visited);</span></span><br><span class="line"><span class="comment">        return result;</span></span><br><span class="line"><span class="comment">    &#125; </span></span><br><span class="line"><span class="comment">    void getGray(int n,string &amp;str,vector&lt;int&gt;&amp;result,unordered_set&lt;string&gt;&amp;visited)&#123;</span></span><br><span class="line"><span class="comment">        //当前字符串出现过了</span></span><br><span class="line"><span class="comment">        if(visited.find(str)!=visited.end())return;</span></span><br><span class="line"><span class="comment">        //将当前字符串转换成十进制数字</span></span><br><span class="line"><span class="comment">        int sum=0;</span></span><br><span class="line"><span class="comment">        for(int i=n-1;i&gt;=0;i--)&#123;</span></span><br><span class="line"><span class="comment">            sum+=(str[i]-'0')*pow(2,n-1-i);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        result.push_back(sum);</span></span><br><span class="line"><span class="comment">        visited.insert(str);</span></span><br><span class="line"><span class="comment">        for(int i=n-1;i&gt;=0;i--)&#123;</span></span><br><span class="line"><span class="comment">            str[i]=str[i]+1;</span></span><br><span class="line"><span class="comment">            if(str[i]&gt;'1')str[i]='0';</span></span><br><span class="line"><span class="comment">            getGray(n,str,result,visited);</span></span><br><span class="line"><span class="comment">            str[i]=(str[i]=='0')?'1':'0';</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; grayCode(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">string</span> str=<span class="built_in">string</span>(n,<span class="string">'0'</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;visited;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt;q;</span><br><span class="line">        q.push(str);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="built_in">string</span> cur_str=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">int</span> cur_ten=returnTen(cur_str);</span><br><span class="line">            result.push_back(cur_ten);</span><br><span class="line">            visited.insert(cur_str);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=cur_str.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                <span class="built_in">string</span> temp=cur_str;</span><br><span class="line">                temp[i]+=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(temp[i]&gt;<span class="string">'1'</span>)temp[i]=<span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">if</span>(visited.find(temp)==visited.end())&#123;</span><br><span class="line">                    q.push(temp);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">returnTen</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> size=str.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=size<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            sum+=(str[i]-<span class="string">'0'</span>)*<span class="built_in">pow</span>(<span class="number">2</span>,size<span class="number">-1</span>-i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。&lt;/p&gt;
&lt;p&gt;给定一个代表编码总位数的非负整数 &lt;em&gt;n&lt;/em&gt;，打印其格雷编码序列。格雷编码序列必须以 0 开头。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="回溯" scheme="https://cblog.club/categories/leetcode/%E5%9B%9E%E6%BA%AF/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="回溯" scheme="https://cblog.club/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>210课程表II</title>
    <link href="https://cblog.club/ck4iio1r00015b8g46qjg38gb.html"/>
    <id>https://cblog.club/ck4iio1r00015b8g46qjg38gb.html</id>
    <published>2019-12-03T14:34:16.000Z</published>
    <updated>2019-12-03T14:37:21.991Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>现在你总共有 <em>n</em> 门课需要选，记为 <code>0</code> 到 <code>n-1</code>。</p><p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: <code>[0,1]</code></p><p>给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。</p><p>可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。</p><a id="more"></a><blockquote><p><strong>示例 1:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">2</span>, [[<span class="number">1</span>,<span class="number">0</span>]] </span><br><span class="line">输出: [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">解释: 总共有 <span class="number">2</span> 门课程。要学习课程 <span class="number">1</span>，你需要先完成课程 <span class="number">0</span>。因此，正确的课程顺序为 [<span class="number">0</span>,<span class="number">1</span>] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">4</span>, [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">2</span>]]</span><br><span class="line">输出: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="keyword">or</span> [<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">解释: 总共有 <span class="number">4</span> 门课程。要学习课程 <span class="number">3</span>，你应该先完成课程 <span class="number">1</span> 和课程 <span class="number">2</span>。并且课程 <span class="number">1</span> 和课程 <span class="number">2</span> 都应该排在课程 <span class="number">0</span> 之后。</span><br><span class="line">     因此，一个正确的课程顺序是 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] 。另一个正确的排序是 [<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>] 。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ol><li>输入的先决条件是由<strong>边缘列表</strong>表示的图形，而不是邻接矩阵。详情请参见 <a href="http://blog.csdn.net/woaidapaopao/article/details/51732947" target="_blank" rel="noopener">图的表示法</a>。</li><li>你可以假定输入的先决条件中没有重复的边。</li></ol><p><strong>提示:</strong></p><ol><li>这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。</li><li><a href="https://www.coursera.org/specializations/algorithms" target="_blank" rel="noopener"> 通过 DFS 进行拓扑排序</a>  - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。</li><li>拓扑排序也可以通过  <a href="https://baike.baidu.com/item/宽度优先搜索/5224802?fr=aladdin&fromid=2148012&fromtitle=广度优先搜索" target="_blank" rel="noopener">BFS</a>  完成。</li></ol></blockquote><h6 id="解题思路：本题和207课程表的思路是一模一样，只不过返回的形式不一样，这一题返回的是具体的结果数组，只需要在最后比较一下和课程数目的长度即可。"><a href="#解题思路：本题和207课程表的思路是一模一样，只不过返回的形式不一样，这一题返回的是具体的结果数组，只需要在最后比较一下和课程数目的长度即可。" class="headerlink" title="解题思路：本题和207课程表的思路是一模一样，只不过返回的形式不一样，这一题返回的是具体的结果数组，只需要在最后比较一下和课程数目的长度即可。"></a>解题思路：本题和207课程表的思路是一模一样，只不过返回的形式不一样，这一题返回的是具体的结果数组，只需要在最后比较一下和课程数目的长度即可。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findOrder(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;indegree(numCourses);</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;outdegree;</span><br><span class="line">        <span class="comment">//计算所有结点的入度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prerequisites.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> firstvalue=prerequisites[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> secondvalue=prerequisites[i][<span class="number">1</span>];</span><br><span class="line">            indegree[firstvalue]++;</span><br><span class="line">            outdegree[secondvalue].push_back(firstvalue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">        <span class="comment">//将入度为0的点入队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree[i]==<span class="number">0</span>)q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> cur=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            result.push_back(cur);</span><br><span class="line">            <span class="keyword">auto</span> it=outdegree.find(cur);</span><br><span class="line">            <span class="keyword">if</span>(it!=outdegree.end())&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;it-&gt;second.size();i++)&#123;</span><br><span class="line">                    indegree[it-&gt;second[i]]--;</span><br><span class="line">                    <span class="keyword">if</span>(indegree[it-&gt;second[i]]==<span class="number">0</span>)q.push(it-&gt;second[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(result.size()==numCourses)<span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;res;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;现在你总共有 &lt;em&gt;n&lt;/em&gt; 门课需要选，记为 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;n-1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: &lt;code&gt;[0,1]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。&lt;/p&gt;
&lt;p&gt;可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="拓扑排序" scheme="https://cblog.club/categories/leetcode/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="拓扑排序" scheme="https://cblog.club/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>207课程表</title>
    <link href="https://cblog.club/ck4iio1qy0012b8g4g71jc4it.html"/>
    <id>https://cblog.club/ck4iio1qy0012b8g4g71jc4it.html</id>
    <published>2019-12-03T14:27:50.000Z</published>
    <updated>2019-12-03T14:33:48.116Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>现在你总共有 <em>n</em> 门课需要选，记为 <code>0</code> 到 <code>n-1</code>。</p><p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: <code>[0,1]</code></p><p>给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？</p><a id="more"></a><blockquote><p><strong>示例 1:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">2</span>, [[<span class="number">1</span>,<span class="number">0</span>]] </span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 总共有 <span class="number">2</span> 门课程。学习课程 <span class="number">1</span> 之前，你需要完成课程 <span class="number">0</span>。所以这是可能的。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">2</span>, [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">解释: 总共有 <span class="number">2</span> 门课程。学习课程 <span class="number">1</span> 之前，你需要先完成课程 <span class="number">0</span>；并且学习课程 <span class="number">0</span> 之前，你还应先完成课程 <span class="number">1</span>。这是不可能的。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ol><li>输入的先决条件是由<strong>边缘列表</strong>表示的图形，而不是邻接矩阵。详情请参见 <a href="http://blog.csdn.net/woaidapaopao/article/details/51732947" target="_blank" rel="noopener">图的表示法</a>。</li><li>你可以假定输入的先决条件中没有重复的边。</li></ol><p><strong>提示:</strong></p><ol><li>这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。</li><li><a href="https://www.coursera.org/specializations/algorithms" target="_blank" rel="noopener">通过 DFS 进行拓扑排序</a>  - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。</li><li>拓扑排序也可以通过  <a href="https://baike.baidu.com/item/宽度优先搜索/5224802?fr=aladdin&fromid=2148012&fromtitle=广度优先搜索" target="_blank" rel="noopener">BFS</a>  完成。</li></ol></blockquote><h6 id="解题思路：本题是标准的拓扑排序，可以使用BFS和DFS，本题采用BFS来解题，拓扑排序大体的思路就是："><a href="#解题思路：本题是标准的拓扑排序，可以使用BFS和DFS，本题采用BFS来解题，拓扑排序大体的思路就是：" class="headerlink" title="解题思路：本题是标准的拓扑排序，可以使用BFS和DFS，本题采用BFS来解题，拓扑排序大体的思路就是："></a>解题思路：本题是标准的拓扑排序，可以使用BFS和DFS，本题采用BFS来解题，拓扑排序大体的思路就是：</h6><ul><li>首先计算所有结点的入度，以及相应结点的出度结点（用unordered_map存比较好）</li><li>将所有入度为0的结点入队列</li><li>出队，然后将当前结点插入到一个新的数组中，接着将当前节点的所有出度结点的入度-1，并且如果此节点入度减完-后为0，那么就应该让其队列</li><li>最后当队列为空为止，如果新数组的长度和所有结点个数和一样，那么就代表当前图没有环（这也是拓扑排序的一个用处）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prerequisites.size()==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;indegree(numCourses);</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;outd;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prerequisites.size();i++)&#123;</span><br><span class="line">            <span class="comment">//计算所有结点的入度,后一个结点指向第一个结点，所以第一个结点的入度+1</span></span><br><span class="line">            <span class="keyword">int</span> firstvalue=prerequisites[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> secondvalue=prerequisites[i][<span class="number">1</span>];</span><br><span class="line">            indegree[firstvalue]++;</span><br><span class="line">            <span class="comment">//将后一个结点的出度结点插入其出度数组中</span></span><br><span class="line">            outd[secondvalue].push_back(firstvalue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">        <span class="comment">//所有入度为0的结点入队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree[i]==<span class="number">0</span>)q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//所有入度为0的结点出队列</span></span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> cur=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            result.push_back(cur);</span><br><span class="line">            <span class="comment">//将指向其的所有结点入度-1</span></span><br><span class="line">            <span class="keyword">auto</span> it=outd.find(cur);</span><br><span class="line">            <span class="keyword">if</span>(it!=outd.end())&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;it-&gt;second.size();i++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> out=it-&gt;second[i];</span><br><span class="line">                    indegree[out]--;</span><br><span class="line">                    <span class="comment">//如果他的出度结点的入度为0，也将其入队列</span></span><br><span class="line">                    <span class="keyword">if</span>(indegree[out]==<span class="number">0</span>)q.push(out);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.size()==numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;现在你总共有 &lt;em&gt;n&lt;/em&gt; 门课需要选，记为 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;n-1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: &lt;code&gt;[0,1]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="拓扑排序" scheme="https://cblog.club/categories/leetcode/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="拓扑排序" scheme="https://cblog.club/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>54螺旋矩阵</title>
    <link href="https://cblog.club/ck4iio1sy003rb8g4bp56dp2y.html"/>
    <id>https://cblog.club/ck4iio1sy003rb8g4bp56dp2y.html</id>
    <published>2019-12-02T15:11:45.000Z</published>
    <updated>2019-12-02T15:13:21.946Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定一个包含 <em>m</em> x <em>n</em> 个元素的矩阵（<em>m</em> 行, <em>n</em> 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。</p><a id="more"></a><blockquote><p><strong>示例 1:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line"> [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ],</span><br><span class="line"> [ <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ],</span><br><span class="line"> [ <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> ]</span><br><span class="line">]</span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">  [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]</span><br><span class="line">]</span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：本题算是面试中经常遇到的题目，所以再来做一遍，但是还是找BUG找了半天，所以说代码能力还是不过关，得加强。"><a href="#解题思路：本题算是面试中经常遇到的题目，所以再来做一遍，但是还是找BUG找了半天，所以说代码能力还是不过关，得加强。" class="headerlink" title="解题思路：本题算是面试中经常遇到的题目，所以再来做一遍，但是还是找BUG找了半天，所以说代码能力还是不过关，得加强。"></a>解题思路：本题算是面试中经常遇到的题目，所以再来做一遍，但是还是找BUG找了半天，所以说代码能力还是不过关，得加强。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; spiralOrder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line">        <span class="keyword">int</span> row=matrix.size();</span><br><span class="line">        <span class="comment">//矩阵为空</span></span><br><span class="line">        <span class="keyword">if</span>(row==<span class="number">0</span>)<span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">int</span> col=matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="comment">//获取最终数组要填充的个数</span></span><br><span class="line">        <span class="keyword">int</span> size=row*col;</span><br><span class="line">        <span class="comment">//定义四个方向</span></span><br><span class="line">        <span class="keyword">int</span> direct[<span class="number">2</span>][<span class="number">4</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> nextx,nexty,der,curx,cury;</span><br><span class="line">        <span class="comment">//定义当前位置和方向</span></span><br><span class="line">        curx=cury=der=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//直到填充完数组结束</span></span><br><span class="line">        <span class="keyword">while</span>(result.size()&lt;size)&#123;</span><br><span class="line">            <span class="comment">//如果当前元素没有访问过</span></span><br><span class="line">            <span class="keyword">if</span>(matrix[curx][cury]!=INT_MAX)&#123;</span><br><span class="line">                result.push_back(matrix[curx][cury]);</span><br><span class="line">                <span class="comment">//设置当前元素访问过</span></span><br><span class="line">                matrix[curx][cury]=INT_MAX;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取下一个元素</span></span><br><span class="line">            nextx=curx+direct[<span class="number">0</span>][der];</span><br><span class="line">            nexty=cury+direct[<span class="number">1</span>][der];</span><br><span class="line">            <span class="comment">//判断下一个元素是否符合要求（不越界，也没访问过）</span></span><br><span class="line">            <span class="keyword">if</span>(nextx&gt;=<span class="number">0</span>&amp;&amp;nextx&lt;row&amp;&amp;nexty&gt;=<span class="number">0</span>&amp;&amp;nexty&lt;col&amp;&amp;matrix[nextx][nexty]!=INT_MAX)&#123;</span><br><span class="line">                curx=nextx;</span><br><span class="line">                cury=nexty;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不符合要求，转向</span></span><br><span class="line">            <span class="keyword">else</span> der=(der+<span class="number">1</span>)%<span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;给定一个包含 &lt;em&gt;m&lt;/em&gt; x &lt;em&gt;n&lt;/em&gt; 个元素的矩阵（&lt;em&gt;m&lt;/em&gt; 行, &lt;em&gt;n&lt;/em&gt; 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>127单词接龙</title>
    <link href="https://cblog.club/ck4iio1q9000ab8g45kow34vz.html"/>
    <id>https://cblog.club/ck4iio1q9000ab8g45kow34vz.html</id>
    <published>2019-12-02T15:08:31.000Z</published>
    <updated>2019-12-02T15:10:58.383Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定两个单词（<em>beginWord</em> 和 <em>endWord*）和一个字典，找到从 *beginWord</em> 到 <em>endWord</em> 的最短转换序列的长度。转换需遵循如下规则：</p><ol><li>每次转换只能改变一个字母。</li><li>转换过程中的中间单词必须是字典中的单词。</li></ol><a id="more"></a><blockquote><p><strong>说明:</strong></p><ul><li>如果不存在这样的转换序列，返回 0。</li><li>所有单词具有相同的长度。</li><li>所有单词只由小写字母组成。</li><li>字典中不存在重复的单词。</li><li>你可以假设 <em>beginWord</em> 和 <em>endWord</em> 是非空的，且二者不相同。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord = <span class="string">"hit"</span>,</span><br><span class="line">endWord = <span class="string">"cog"</span>,</span><br><span class="line">wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>,<span class="string">"cog"</span>]</span><br><span class="line"></span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line"></span><br><span class="line">解释: 一个最短转换序列是 <span class="string">"hit"</span> -&gt; <span class="string">"hot"</span> -&gt; <span class="string">"dot"</span> -&gt; <span class="string">"dog"</span> -&gt; <span class="string">"cog"</span>,</span><br><span class="line">     返回它的长度 <span class="number">5</span>。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord = <span class="string">"hit"</span></span><br><span class="line">endWord = <span class="string">"cog"</span></span><br><span class="line">wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>]</span><br><span class="line"></span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">解释: endWord <span class="string">"cog"</span> 不在字典中，所以无法进行转换。</span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：本题和打开转盘锁一个套路，都是用BFS，但是本题花费了很长时间才做对，哎-，一言难尽"><a href="#解题思路：本题和打开转盘锁一个套路，都是用BFS，但是本题花费了很长时间才做对，哎-，一言难尽" class="headerlink" title="解题思路：本题和打开转盘锁一个套路，都是用BFS，但是本题花费了很长时间才做对，哎= =，一言难尽"></a>解题思路：本题和打开转盘锁一个套路，都是用BFS，但是本题花费了很长时间才做对，哎= =，一言难尽</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;wl;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;visited;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;wordList.size();i++)&#123;</span><br><span class="line">            wl.insert(wordList[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt;q;</span><br><span class="line">        q.push(beginWord);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size=q.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;size;k++)&#123;</span><br><span class="line">                <span class="built_in">string</span> cur=q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                visited.insert(cur);</span><br><span class="line">                <span class="keyword">if</span>(cur==endWord)<span class="keyword">return</span> result+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//每个字母有26个选择</span></span><br><span class="line">                <span class="built_in">string</span> alphbet=<span class="string">"abcdefghijklmnopqrstuvwxyz"</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;beginWord.size();i++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">char</span> c:alphbet)&#123;</span><br><span class="line">                        <span class="built_in">string</span> str=cur;</span><br><span class="line">                        str[i]=c;</span><br><span class="line">                        <span class="comment">//在字典中，并且还没有被访问过</span></span><br><span class="line">                        <span class="keyword">if</span>(wl.find(str)!=wl.end()&amp;&amp;visited.find(str)==visited.end())&#123;</span><br><span class="line">                            q.push(str);</span><br><span class="line">                            visited.insert(str);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;给定两个单词（&lt;em&gt;beginWord&lt;/em&gt; 和 &lt;em&gt;endWord*）和一个字典，找到从 *beginWord&lt;/em&gt; 到 &lt;em&gt;endWord&lt;/em&gt; 的最短转换序列的长度。转换需遵循如下规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每次转换只能改变一个字母。&lt;/li&gt;
&lt;li&gt;转换过程中的中间单词必须是字典中的单词。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="广度搜索" scheme="https://cblog.club/categories/leetcode/%E5%B9%BF%E5%BA%A6%E6%90%9C%E7%B4%A2/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="广度搜索" scheme="https://cblog.club/tags/%E5%B9%BF%E5%BA%A6%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>120三角形最小路径和</title>
    <link href="https://cblog.club/ck4iio1pp0001b8g418xnaude.html"/>
    <id>https://cblog.club/ck4iio1pp0001b8g418xnaude.html</id>
    <published>2019-12-01T14:25:48.000Z</published>
    <updated>2019-12-01T14:29:43.802Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p><a id="more"></a><blockquote><p>例如，给定三角形：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [<span class="number">2</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">   [<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>自顶向下的最小路径和为 <code>11</code>（即，<strong>2</strong> + <strong>3</strong> + <strong>5</strong> + <strong>1</strong> = 11）。</p><p><strong>说明：</strong></p><p>如果你可以只使用 <em>O</em>(<em>n</em>) 的额外空间（<em>n</em> 为三角形的总行数）来解决这个问题，那么你的算法会很加分</p></blockquote><h6 id="解题思路：本题一开始觉得很是简单，直接DP就行了，当前值由上一层的两个待选元素确定，但是访问越界问题，我找BUG找了好久-，所以在确定上一层的元素的时候，边界情况一定要搞清楚-（这一题O1的额外空间就可以了），还有就是像这种越界之后所用的值的方式，还是挺好的，值得借鉴。"><a href="#解题思路：本题一开始觉得很是简单，直接DP就行了，当前值由上一层的两个待选元素确定，但是访问越界问题，我找BUG找了好久-，所以在确定上一层的元素的时候，边界情况一定要搞清楚-（这一题O1的额外空间就可以了），还有就是像这种越界之后所用的值的方式，还是挺好的，值得借鉴。" class="headerlink" title="解题思路：本题一开始觉得很是简单，直接DP就行了，当前值由上一层的两个待选元素确定，但是访问越界问题，我找BUG找了好久= =，所以在确定上一层的元素的时候，边界情况一定要搞清楚= =（这一题O1的额外空间就可以了），还有就是像这种越界之后所用的值的方式，还是挺好的，值得借鉴。"></a>解题思路：本题一开始觉得很是简单，直接DP就行了，当前值由上一层的两个待选元素确定，但是访问越界问题，我找BUG找了好久= =，所以在确定上一层的元素的时候，边界情况一定要搞清楚= =（这一题O1的额外空间就可以了），还有就是像这种越界之后所用的值的方式，还是挺好的，值得借鉴。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row=triangle.size();</span><br><span class="line">        <span class="keyword">if</span>(row==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(row==<span class="number">1</span>)<span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> min_path=INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                <span class="comment">//上层相邻的，有两个待选</span></span><br><span class="line">                <span class="keyword">int</span> left,right;</span><br><span class="line">                left=(j&gt;<span class="number">0</span>)?triangle[i<span class="number">-1</span>][j<span class="number">-1</span>]:INT_MAX;</span><br><span class="line">                right=(i&gt;j)?triangle[i<span class="number">-1</span>][j]:INT_MAX;</span><br><span class="line">                triangle[i][j]+=min(left,right);</span><br><span class="line">                <span class="keyword">if</span>(i==row<span class="number">-1</span>&amp;&amp;min_path&gt;triangle[i][j])min_path=triangle[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min_path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/categories/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>221最大正方形</title>
    <link href="https://cblog.club/ck4iio1r8001ib8g421ti01m9.html"/>
    <id>https://cblog.club/ck4iio1r8001ib8g421ti01m9.html</id>
    <published>2019-12-01T14:19:38.000Z</published>
    <updated>2019-12-01T14:25:01.584Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p><a id="more"></a><blockquote><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：本题因为是求最优值问题，所以一般还是往动态规划上想，这一题dp-i-j-代表以-i-j-这个点为正方形的右下角坐标的正方形最大边长，这就要考虑三个位置，上方，左方，左上方，当前位置的dp值等于这三个中的最小值-1（其实这个原理，画图的话还是很牵强，并没有真正理解-），最后返回这些位置中最大的一个，注意只有一个元素的情况。"><a href="#解题思路：本题因为是求最优值问题，所以一般还是往动态规划上想，这一题dp-i-j-代表以-i-j-这个点为正方形的右下角坐标的正方形最大边长，这就要考虑三个位置，上方，左方，左上方，当前位置的dp值等于这三个中的最小值-1（其实这个原理，画图的话还是很牵强，并没有真正理解-），最后返回这些位置中最大的一个，注意只有一个元素的情况。" class="headerlink" title="解题思路：本题因为是求最优值问题，所以一般还是往动态规划上想，这一题dp[i] [j]代表以(i,j)这个点为正方形的右下角坐标的正方形最大边长，这就要考虑三个位置，上方，左方，左上方，当前位置的dp值等于这三个中的最小值+1（其实这个原理，画图的话还是很牵强，并没有真正理解= =），最后返回这些位置中最大的一个，注意只有一个元素的情况。"></a>解题思路：本题因为是求最优值问题，所以一般还是往动态规划上想，这一题dp[i] [j]代表以(i,j)这个点为正方形的右下角坐标的正方形最大边长，这就要考虑三个位置，上方，左方，左上方，当前位置的dp值等于这三个中的最小值+1（其实这个原理，画图的话还是很牵强，并没有真正理解= =），最后返回这些位置中最大的一个，注意只有一个元素的情况。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row=matrix.size();</span><br><span class="line">        <span class="keyword">if</span>(row==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col=matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;dp(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">if</span>(matrix[<span class="number">0</span>][<span class="number">0</span>]==<span class="string">'1'</span>)dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_res=dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                    <span class="comment">//三个位置 上  左  左上</span></span><br><span class="line">                    <span class="keyword">int</span> up,left,left_up;</span><br><span class="line">                    up=(i&gt;<span class="number">0</span>)?dp[i<span class="number">-1</span>][j]:<span class="number">0</span>;</span><br><span class="line">                    left=(j&gt;<span class="number">0</span>)?dp[i][j<span class="number">-1</span>]:<span class="number">0</span>;</span><br><span class="line">                    left_up=(i&gt;<span class="number">0</span>&amp;&amp;j&gt;<span class="number">0</span>)?dp[i<span class="number">-1</span>][j<span class="number">-1</span>]:<span class="number">0</span>;</span><br><span class="line">                    dp[i][j]=min(min(up,left),left_up)+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(max_res&lt;dp[i][j])max_res=dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_res*max_res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/categories/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>752打开转盘锁</title>
    <link href="https://cblog.club/ck4iio1tc004fb8g4g3lp1dnh.html"/>
    <id>https://cblog.club/ck4iio1tc004fb8g4g3lp1dnh.html</id>
    <published>2019-11-30T09:38:47.000Z</published>
    <updated>2019-11-30T09:45:19.642Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： <code>&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;</code> 。每个拨轮可以自由旋转：例如把 <code>&#39;9&#39;</code> 变为 <code>&#39;0&#39;</code>，<code>&#39;0&#39;</code> 变为 <code>&#39;9&#39;</code> 。每次旋转都只能旋转一个拨轮的一位数字。</p><p>锁的初始数字为 <code>&#39;0000&#39;</code> ，一个代表四个拨轮的数字的字符串。</p><p>列表 <code>deadends</code> 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p><p>字符串 <code>target</code> 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。</p><a id="more"></a><blockquote><p><strong>示例 1:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：deadends = [<span class="string">"0201"</span>,<span class="string">"0101"</span>,<span class="string">"0102"</span>,<span class="string">"1212"</span>,<span class="string">"2002"</span>], target = <span class="string">"0202"</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：</span><br><span class="line">可能的移动序列为 <span class="string">"0000"</span> -&gt; <span class="string">"1000"</span> -&gt; <span class="string">"1100"</span> -&gt; <span class="string">"1200"</span> -&gt; <span class="string">"1201"</span> -&gt; <span class="string">"1202"</span> -&gt; <span class="string">"0202"</span>。</span><br><span class="line">注意 <span class="string">"0000"</span> -&gt; <span class="string">"0001"</span> -&gt; <span class="string">"0002"</span> -&gt; <span class="string">"0102"</span> -&gt; <span class="string">"0202"</span> 这样的序列是不能解锁的，</span><br><span class="line">因为当拨动到 <span class="string">"0102"</span> 时这个锁就会被锁定。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: deadends = [<span class="string">"8888"</span>], target = <span class="string">"0009"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：</span><br><span class="line">把最后一位反向旋转一次即可 <span class="string">"0000"</span> -&gt; <span class="string">"0009"</span>。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: deadends = [<span class="string">"8887"</span>,<span class="string">"8889"</span>,<span class="string">"8878"</span>,<span class="string">"8898"</span>,<span class="string">"8788"</span>,<span class="string">"8988"</span>,<span class="string">"7888"</span>,<span class="string">"9888"</span>], target = <span class="string">"8888"</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：</span><br><span class="line">无法旋转到目标数字且不被锁定。</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: deadends = [<span class="string">"0000"</span>], target = <span class="string">"8888"</span></span><br><span class="line">输出：<span class="number">-1</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>死亡列表 <code>deadends</code> 的长度范围为 <code>[1, 500]</code>。</li><li>目标数字 <code>target</code> 不会在 <code>deadends</code> 之中。</li><li>每个 <code>deadends</code> 和 <code>target</code> 中的字符串的数字会在 10,000 个可能的情况 <code>&#39;0000&#39;</code> 到 <code>&#39;9999&#39;</code> 中产生。</li></ol></blockquote><h6 id="解题思路：这一题采用广度搜索（BFS），每一次的选择有八个，四个位置可以-1，也可以-1，但是要注意0和9之间的转换（这一点由于是借鉴别人的思路，所以没有被坑到，自己写的话极有可能会掉坑），然后每走完一层（这个走完一层，遍历的范围是0-当前队列的长度（不得不说巧妙，之前层次遍历就领略过，十分巧妙）），就要判断一下当前的值中有没有和target相等的（并且还不能在锁里边（锁在之前，先插入到unordered-set里，因为它实现使用的哈希表，所以时间很快（O1））），如果有，直接返回即可，没有的话，再次往下一层走，类似于层次遍历，每一层都是每一步的八个选择（当然，我们还需要使用一个unordered-set来去掉访问过的，这样剪枝，可以省掉一些时间）。"><a href="#解题思路：这一题采用广度搜索（BFS），每一次的选择有八个，四个位置可以-1，也可以-1，但是要注意0和9之间的转换（这一点由于是借鉴别人的思路，所以没有被坑到，自己写的话极有可能会掉坑），然后每走完一层（这个走完一层，遍历的范围是0-当前队列的长度（不得不说巧妙，之前层次遍历就领略过，十分巧妙）），就要判断一下当前的值中有没有和target相等的（并且还不能在锁里边（锁在之前，先插入到unordered-set里，因为它实现使用的哈希表，所以时间很快（O1））），如果有，直接返回即可，没有的话，再次往下一层走，类似于层次遍历，每一层都是每一步的八个选择（当然，我们还需要使用一个unordered-set来去掉访问过的，这样剪枝，可以省掉一些时间）。" class="headerlink" title="解题思路：这一题采用广度搜索（BFS），每一次的选择有八个，四个位置可以+1，也可以-1，但是要注意0和9之间的转换（这一点由于是借鉴别人的思路，所以没有被坑到，自己写的话极有可能会掉坑），然后每走完一层（这个走完一层，遍历的范围是0-当前队列的长度（不得不说巧妙，之前层次遍历就领略过，十分巧妙）），就要判断一下当前的值中有没有和target相等的（并且还不能在锁里边（锁在之前，先插入到unordered_set里，因为它实现使用的哈希表，所以时间很快（O1））），如果有，直接返回即可，没有的话，再次往下一层走，类似于层次遍历，每一层都是每一步的八个选择（当然，我们还需要使用一个unordered_set来去掉访问过的，这样剪枝，可以省掉一些时间）。"></a>解题思路：这一题采用广度搜索（BFS），每一次的选择有八个，四个位置可以+1，也可以-1，但是要注意0和9之间的转换（这一点由于是借鉴别人的思路，所以没有被坑到，自己写的话极有可能会掉坑），然后每走完一层（这个走完一层，遍历的范围是0-当前队列的长度（不得不说巧妙，之前层次遍历就领略过，十分巧妙）），就要判断一下当前的值中有没有和target相等的（并且还不能在锁里边（锁在之前，先插入到unordered_set里，因为它实现使用的哈希表，所以时间很快（O1））），如果有，直接返回即可，没有的话，再次往下一层走，类似于层次遍历，每一层都是每一步的八个选择（当然，我们还需要使用一个unordered_set来去掉访问过的，这样剪枝，可以省掉一些时间）。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">openLock</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; deadends, <span class="built_in">string</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;dead;</span><br><span class="line">        <span class="comment">//将锁的字符串插入到无序集合中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> d:deadends)&#123;</span><br><span class="line">            dead.insert(d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//"0000"是锁，目标值是锁，都不能解锁</span></span><br><span class="line">        <span class="keyword">if</span>(dead.find(target)!=dead.end()||dead.find(<span class="string">"0000"</span>)!=dead.end())<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;visited;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt;q;</span><br><span class="line">        <span class="keyword">int</span> layer=<span class="number">0</span>;</span><br><span class="line">        q.push(<span class="string">"0000"</span>);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size=q.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                <span class="built_in">string</span> cur_string=q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span>(cur_string==target)<span class="keyword">return</span> layer;</span><br><span class="line">                <span class="comment">//定义他的八个相邻的值(分别是四个位置+1和-1)</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)&#123;</span><br><span class="line">                    <span class="built_in">string</span> s1,s2;</span><br><span class="line">                    s1=s2=cur_string;</span><br><span class="line">                    s1[k]=(s1[k]==<span class="string">'9'</span>)?<span class="string">'0'</span>:s1[k]+<span class="number">1</span>;</span><br><span class="line">                    s2[k]=(s2[k]==<span class="string">'0'</span>)?<span class="string">'9'</span>:s2[k]<span class="number">-1</span>;</span><br><span class="line">                    <span class="comment">//接下来就是检查这两个字符串是否是目标字符串</span></span><br><span class="line">                    <span class="keyword">if</span>(dead.find(s1)==dead.end()&amp;&amp;visited.find(s1)==visited.end())&#123;</span><br><span class="line">                        q.push(s1);</span><br><span class="line">                        visited.insert(s1);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(dead.find(s2)==dead.end()&amp;&amp;visited.find(s2)==visited.end())&#123;</span><br><span class="line">                        q.push(s2);</span><br><span class="line">                        visited.insert(s2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            layer++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： &lt;code&gt;&amp;#39;0&amp;#39;, &amp;#39;1&amp;#39;, &amp;#39;2&amp;#39;, &amp;#39;3&amp;#39;, &amp;#39;4&amp;#39;, &amp;#39;5&amp;#39;, &amp;#39;6&amp;#39;, &amp;#39;7&amp;#39;, &amp;#39;8&amp;#39;, &amp;#39;9&amp;#39;&lt;/code&gt; 。每个拨轮可以自由旋转：例如把 &lt;code&gt;&amp;#39;9&amp;#39;&lt;/code&gt; 变为 &lt;code&gt;&amp;#39;0&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;0&amp;#39;&lt;/code&gt; 变为 &lt;code&gt;&amp;#39;9&amp;#39;&lt;/code&gt; 。每次旋转都只能旋转一个拨轮的一位数字。&lt;/p&gt;
&lt;p&gt;锁的初始数字为 &lt;code&gt;&amp;#39;0000&amp;#39;&lt;/code&gt; ，一个代表四个拨轮的数字的字符串。&lt;/p&gt;
&lt;p&gt;列表 &lt;code&gt;deadends&lt;/code&gt; 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。&lt;/p&gt;
&lt;p&gt;字符串 &lt;code&gt;target&lt;/code&gt; 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="广度搜索" scheme="https://cblog.club/categories/leetcode/%E5%B9%BF%E5%BA%A6%E6%90%9C%E7%B4%A2/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="广度搜索" scheme="https://cblog.club/tags/%E5%B9%BF%E5%BA%A6%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>133克隆图</title>
    <link href="https://cblog.club/ck4iio1q60009b8g46ue4an86.html"/>
    <id>https://cblog.club/ck4iio1q60009b8g46ue4an86.html</id>
    <published>2019-11-30T09:31:47.000Z</published>
    <updated>2019-11-30T09:38:26.855Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定无向<a href="https://baike.baidu.com/item/连通图/6460995?fr=aladdin" target="_blank" rel="noopener"><strong>连通</strong></a>图中一个节点的引用，返回该图的<a href="https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin" target="_blank" rel="noopener"><strong>深拷贝</strong></a>（克隆）。图中的每个节点都包含它的值 <code>val</code>（<code>Int</code>） 和其邻居的列表（<code>list[Node]</code>）。</p><a id="more"></a><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">&#123;<span class="string">"$id"</span>:<span class="string">"1"</span>,<span class="string">"neighbors"</span>:[&#123;<span class="string">"$id"</span>:<span class="string">"2"</span>,<span class="string">"neighbors"</span>:[&#123;<span class="string">"$ref"</span>:<span class="string">"1"</span>&#125;,&#123;<span class="string">"$id"</span>:<span class="string">"3"</span>,<span class="string">"neighbors"</span>:[&#123;<span class="string">"$ref"</span>:<span class="string">"2"</span>&#125;,&#123;<span class="string">"$id"</span>:<span class="string">"4"</span>,<span class="string">"neighbors"</span>:[&#123;<span class="string">"$ref"</span>:<span class="string">"3"</span>&#125;,&#123;<span class="string">"$ref"</span>:<span class="string">"1"</span>&#125;],<span class="string">"val"</span>:<span class="number">4</span>&#125;],<span class="string">"val"</span>:<span class="number">3</span>&#125;],<span class="string">"val"</span>:<span class="number">2</span>&#125;,&#123;<span class="string">"$ref"</span>:<span class="string">"4"</span>&#125;],<span class="string">"val"</span>:<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">节点 <span class="number">1</span> 的值是 <span class="number">1</span>，它有两个邻居：节点 <span class="number">2</span> 和 <span class="number">4</span> 。</span><br><span class="line">节点 <span class="number">2</span> 的值是 <span class="number">2</span>，它有两个邻居：节点 <span class="number">1</span> 和 <span class="number">3</span> 。</span><br><span class="line">节点 <span class="number">3</span> 的值是 <span class="number">3</span>，它有两个邻居：节点 <span class="number">2</span> 和 <span class="number">4</span> 。</span><br><span class="line">节点 <span class="number">4</span> 的值是 <span class="number">4</span>，它有两个邻居：节点 <span class="number">1</span> 和 <span class="number">3</span> 。</span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">节点数介于 <span class="number">1</span> 到 <span class="number">100</span> 之间。</span><br><span class="line">无向图是一个简单图，这意味着图中没有重复的边，也没有自环。</span><br><span class="line">由于图是无向的，如果节点 p 是节点 q 的邻居，那么节点 q 也必须是节点 p 的邻居。</span><br><span class="line">必须将给定节点的拷贝作为对克隆图的引用返回。</span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：本题一开始就想用BFS，但是不行，因为我们返回的是一个深拷贝，也就是说，改变这个拷贝的元素，原来的图是不会改变的！那这样，我使用普通的BFS，就会导致，我能把第一个结点搞定，但是他的邻居结点怎么搞定呢（没有存啊，可能这里描述的不清楚，还是亲身做一下才会有体会），所以为了解决这个问题，我们还要再使用hash-map来解决，主要思想就是，生成一个原来结点和新生成的节点的映射关系，那这样我在遍历的时候，就能将深拷贝的结点之间也建立相邻关系，这题的思路还是比较好的，借鉴别人的思想，所以自己一定要多体会，不然还是不会成为自己的东西。"><a href="#解题思路：本题一开始就想用BFS，但是不行，因为我们返回的是一个深拷贝，也就是说，改变这个拷贝的元素，原来的图是不会改变的！那这样，我使用普通的BFS，就会导致，我能把第一个结点搞定，但是他的邻居结点怎么搞定呢（没有存啊，可能这里描述的不清楚，还是亲身做一下才会有体会），所以为了解决这个问题，我们还要再使用hash-map来解决，主要思想就是，生成一个原来结点和新生成的节点的映射关系，那这样我在遍历的时候，就能将深拷贝的结点之间也建立相邻关系，这题的思路还是比较好的，借鉴别人的思想，所以自己一定要多体会，不然还是不会成为自己的东西。" class="headerlink" title="解题思路：本题一开始就想用BFS，但是不行，因为我们返回的是一个深拷贝，也就是说，改变这个拷贝的元素，原来的图是不会改变的！那这样，我使用普通的BFS，就会导致，我能把第一个结点搞定，但是他的邻居结点怎么搞定呢（没有存啊，可能这里描述的不清楚，还是亲身做一下才会有体会），所以为了解决这个问题，我们还要再使用hash map来解决，主要思想就是，生成一个原来结点和新生成的节点的映射关系，那这样我在遍历的时候，就能将深拷贝的结点之间也建立相邻关系，这题的思路还是比较好的，借鉴别人的思想，所以自己一定要多体会，不然还是不会成为自己的东西。"></a>解题思路：本题一开始就想用BFS，但是不行，因为我们返回的是一个深拷贝，也就是说，改变这个拷贝的元素，原来的图是不会改变的！那这样，我使用普通的BFS，就会导致，我能把第一个结点搞定，但是他的邻居结点怎么搞定呢（没有存啊，可能这里描述的不清楚，还是亲身做一下才会有体会），所以为了解决这个问题，我们还要再使用hash map来解决，主要思想就是，生成一个原来结点和新生成的节点的映射关系，那这样我在遍历的时候，就能将深拷贝的结点之间也建立相邻关系，这题的思路还是比较好的，借鉴别人的思想，所以自己一定要多体会，不然还是不会成为自己的东西。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node)<span class="keyword">return</span> node;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;Node*,Node*&gt;node_map;</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node*&gt;q;</span><br><span class="line">        q.push(node);</span><br><span class="line">        <span class="comment">//BFS遍历，生成一对一映射关系</span></span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            Node* cur_node=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="comment">//生成对应的新节点</span></span><br><span class="line">            Node* newnode=<span class="keyword">new</span> Node(cur_node-&gt;val,&#123;&#125;);</span><br><span class="line">            node_map.insert(&#123;cur_node,newnode&#125;);</span><br><span class="line">            <span class="comment">//遍历邻居</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cur_node-&gt;neighbors.size();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(node_map.find(cur_node-&gt;neighbors[i])==node_map.end())q.push(cur_node-&gt;neighbors[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将深拷贝的结点之间也建立相邻关系</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it=node_map.begin();it!=node_map.end();it++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;it-&gt;first-&gt;neighbors.size();i++)&#123;</span><br><span class="line">                it-&gt;second-&gt;neighbors.push_back(node_map.find(it-&gt;first-&gt;neighbors[i])-&gt;second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node_map.find(node)-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;给定无向&lt;a href=&quot;https://baike.baidu.com/item/连通图/6460995?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;连通&lt;/strong&gt;&lt;/a&gt;图中一个节点的引用，返回该图的&lt;a href=&quot;https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;深拷贝&lt;/strong&gt;&lt;/a&gt;（克隆）。图中的每个节点都包含它的值 &lt;code&gt;val&lt;/code&gt;（&lt;code&gt;Int&lt;/code&gt;） 和其邻居的列表（&lt;code&gt;list[Node]&lt;/code&gt;）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="广度搜索" scheme="https://cblog.club/categories/leetcode/%E5%B9%BF%E5%BA%A6%E6%90%9C%E7%B4%A2/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="广度搜索" scheme="https://cblog.club/tags/%E5%B9%BF%E5%BA%A6%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>494目标和</title>
    <link href="https://cblog.club/ck4iio1sn0038b8g4ez4g66m3.html"/>
    <id>https://cblog.club/ck4iio1sn0038b8g4ez4g66m3.html</id>
    <published>2019-11-30T09:26:47.000Z</published>
    <updated>2019-11-30T09:31:20.593Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 <code>+</code> 和 <code>-</code>。对于数组中的任意一个整数，你都可以从 <code>+</code> 或 <code>-</code>中选择一个符号添加在前面。</p><p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p><a id="more"></a><blockquote><p><strong>示例 1:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入: nums: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], S: <span class="number">3</span></span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line"><span class="number">-1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span> = <span class="number">3</span></span><br><span class="line">+<span class="number">1</span><span class="number">-1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span> = <span class="number">3</span></span><br><span class="line">+<span class="number">1</span>+<span class="number">1</span><span class="number">-1</span>+<span class="number">1</span>+<span class="number">1</span> = <span class="number">3</span></span><br><span class="line">+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span><span class="number">-1</span>+<span class="number">1</span> = <span class="number">3</span></span><br><span class="line">+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span><span class="number">-1</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">一共有<span class="number">5</span>种方法让最终目标和为<span class="number">3</span>。</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li>数组非空，且长度不会超过20。</li><li>初始的数组的和不会超过1000。</li><li>保证返回的最终结果能被32位整数存下。</li></ol></blockquote><h6 id="解题思路：本题算是比较简单的一题，主要思想就是DFS（说白了也就是递归），每次只有两个选择（当前数字是本身呢还是他的相反数），然后一直递归，直到长度和数组长度一致，在和S比较，如何条件就返回，然后DFS会遍历所有的结果，那么符合一个条件，result（返回值）就-1。"><a href="#解题思路：本题算是比较简单的一题，主要思想就是DFS（说白了也就是递归），每次只有两个选择（当前数字是本身呢还是他的相反数），然后一直递归，直到长度和数组长度一致，在和S比较，如何条件就返回，然后DFS会遍历所有的结果，那么符合一个条件，result（返回值）就-1。" class="headerlink" title="解题思路：本题算是比较简单的一题，主要思想就是DFS（说白了也就是递归），每次只有两个选择（当前数字是本身呢还是他的相反数），然后一直递归，直到长度和数组长度一致，在和S比较，如何条件就返回，然后DFS会遍历所有的结果，那么符合一个条件，result（返回值）就+1。"></a>解题思路：本题算是比较简单的一题，主要思想就是DFS（说白了也就是递归），每次只有两个选择（当前数字是本身呢还是他的相反数），然后一直递归，直到长度和数组长度一致，在和S比较，如何条件就返回，然后DFS会遍历所有的结果，那么符合一个条件，result（返回值）就+1。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        getResult(nums,<span class="number">0</span>,S);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getResult</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> count,<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> need_value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count==nums.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(need_value==<span class="number">0</span>)result++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//两种选择，+  -</span></span><br><span class="line">        <span class="comment">//第一种，选择本身</span></span><br><span class="line">        getResult(nums,count+<span class="number">1</span>,need_value-nums[count]);</span><br><span class="line">        <span class="comment">//第二种，选择相反数</span></span><br><span class="line">        getResult(nums,count+<span class="number">1</span>,need_value+nums[count]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 &lt;code&gt;+&lt;/code&gt; 和 &lt;code&gt;-&lt;/code&gt;。对于数组中的任意一个整数，你都可以从 &lt;code&gt;+&lt;/code&gt; 或 &lt;code&gt;-&lt;/code&gt;中选择一个符号添加在前面。&lt;/p&gt;
&lt;p&gt;返回可以使最终数组和为目标数 S 的所有添加符号的方法数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="深度搜索" scheme="https://cblog.club/categories/leetcode/%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="深度搜索" scheme="https://cblog.club/tags/%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>200岛屿数量</title>
    <link href="https://cblog.club/ck4iio1qt000vb8g40v8ldc0i.html"/>
    <id>https://cblog.club/ck4iio1qt000vb8g40v8ldc0i.html</id>
    <published>2019-11-30T01:58:53.000Z</published>
    <updated>2019-11-30T02:01:50.837Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p><a id="more"></a><blockquote><p>示例 1:</p><p>输入:<br>11110<br>11010<br>11000<br>00000</p><p>输出: 1<br>示例 2:</p><p>输入:<br>11000<br>11000<br>00100<br>00011</p><p>输出: 3</p></blockquote><h6 id="解题思路：本题主要思路就是两个，一个是DFS一个是BFS，两个都可以。但是一定要记录下走过的位置，这里可以不用再声明一个数组用于记录走过的位置，可以将走过的置为’2’，然后遍历，统计1的个就行。"><a href="#解题思路：本题主要思路就是两个，一个是DFS一个是BFS，两个都可以。但是一定要记录下走过的位置，这里可以不用再声明一个数组用于记录走过的位置，可以将走过的置为’2’，然后遍历，统计1的个就行。" class="headerlink" title="解题思路：本题主要思路就是两个，一个是DFS一个是BFS，两个都可以。但是一定要记录下走过的位置，这里可以不用再声明一个数组用于记录走过的位置，可以将走过的置为’2’，然后遍历，统计1的个就行。"></a>解题思路：本题主要思路就是两个，一个是DFS一个是BFS，两个都可以。但是一定要记录下走过的位置，这里可以不用再声明一个数组用于记录走过的位置，可以将走过的置为’2’，然后遍历，统计1的个就行。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;</span></span><br><span class="line"><span class="comment">        int result=0;</span></span><br><span class="line"><span class="comment">        int row=grid.size();</span></span><br><span class="line"><span class="comment">        if(row==0)return result;</span></span><br><span class="line"><span class="comment">        int col=grid[0].size();</span></span><br><span class="line"><span class="comment">        for(int i=0;i&lt;row;i++)&#123;</span></span><br><span class="line"><span class="comment">            for(int j=0;j&lt;col;j++)&#123;</span></span><br><span class="line"><span class="comment">                if(grid[i][j]=='1')&#123;</span></span><br><span class="line"><span class="comment">                    dfs(grid,i,j);</span></span><br><span class="line"><span class="comment">                    result++;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return result;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid,int i,int j)&#123;</span></span><br><span class="line"><span class="comment">        //越界</span></span><br><span class="line"><span class="comment">        if(i&lt;0||i&gt;=grid.size()||j&lt;0||j&gt;=grid[0].size())return;</span></span><br><span class="line"><span class="comment">        //走到水或者是走过的</span></span><br><span class="line"><span class="comment">        if(grid[i][j]=='0'||grid[i][j]=='2')return;</span></span><br><span class="line"><span class="comment">        //代表走过了</span></span><br><span class="line"><span class="comment">        grid[i][j]='2';</span></span><br><span class="line"><span class="comment">        //定义四个方向</span></span><br><span class="line"><span class="comment">        int nexti,nextj;</span></span><br><span class="line"><span class="comment">        int direct[2][4]=&#123;&#123;-1,0,1,0&#125;,&#123;0,1,0,-1&#125;&#125;;</span></span><br><span class="line"><span class="comment">        for(int k=0;k&lt;4;k++)&#123;</span></span><br><span class="line"><span class="comment">            nexti=i+direct[0][k];</span></span><br><span class="line"><span class="comment">            nextj=j+direct[1][k];</span></span><br><span class="line"><span class="comment">            dfs(grid,nexti,nextj);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row=grid.size();</span><br><span class="line">        <span class="keyword">if</span>(row==<span class="number">0</span>)<span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">int</span> col=grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                    bfs(grid,i,j);</span><br><span class="line">                    result++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;q;</span><br><span class="line">        q.push(&#123;i,j&#125;);</span><br><span class="line">        grid[i][j]=<span class="string">'2'</span>;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;pos;</span><br><span class="line">        <span class="keyword">int</span> nexti,nextj;</span><br><span class="line">        <span class="keyword">int</span> direct[<span class="number">2</span>][<span class="number">4</span>]=&#123;&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            pos=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="comment">//定义四个方向</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)&#123;</span><br><span class="line">                nexti=pos.first+direct[<span class="number">0</span>][k];</span><br><span class="line">                nextj=pos.second+direct[<span class="number">1</span>][k];</span><br><span class="line">                <span class="keyword">if</span>(nexti&gt;=<span class="number">0</span>&amp;&amp;nexti&lt;grid.size()&amp;&amp;nextj&gt;=<span class="number">0</span>&amp;&amp;nextj&lt;grid[<span class="number">0</span>].size()&amp;&amp;grid[nexti][nextj]!=<span class="string">'2'</span>&amp;&amp;grid[nexti][nextj]!=<span class="string">'0'</span>)&#123;</span><br><span class="line">                    q.push(&#123;nexti,nextj&#125;);</span><br><span class="line">                    grid[nexti][nextj]=<span class="string">'2'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="深度搜索" scheme="https://cblog.club/categories/leetcode/%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2/"/>
    
      <category term="广度搜索" scheme="https://cblog.club/categories/leetcode/%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2/%E5%B9%BF%E5%BA%A6%E6%90%9C%E7%B4%A2/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="广度搜索" scheme="https://cblog.club/tags/%E5%B9%BF%E5%BA%A6%E6%90%9C%E7%B4%A2/"/>
    
      <category term="深度搜索" scheme="https://cblog.club/tags/%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>542之01矩阵</title>
    <link href="https://cblog.club/ck4iio1su003kb8g4bdgudn0p.html"/>
    <id>https://cblog.club/ck4iio1su003kb8g4bdgudn0p.html</id>
    <published>2019-11-30T01:50:31.000Z</published>
    <updated>2019-11-30T01:58:28.972Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。两个相邻元素间的距离为 1 。</p><a id="more"></a><blockquote><p>示例 1:<br>输入:</p><p>0 0 0<br>0 1 0<br>0 0 0<br>输出:</p><p>0 0 0<br>0 1 0<br>0 0 0<br>示例 2:<br>输入:</p><p>0 0 0<br>0 1 0<br>1 1 1<br>输出:</p><p>0 0 0<br>0 1 0<br>1 2 1<br>注意:</p><p>给定矩阵的元素个数不超过 10000。<br>给定矩阵中至少有一个元素是 0。<br>矩阵中的元素只在四个方向上相邻: 上、下、左、右。</p></blockquote><h6 id="解题思路：本题算是比较好的题目了，刚开始使用深度搜索-DFS-，发现超时了-（还没想出优化的方法），然后借鉴了一些想法，发现其实还有DP这一条路走，但是这题的DP还是比较特别的，要循环两次，因为dp-i-j-需要上下左右四个方向的值，但是一次循环只能获取两个方向，比如先从上到下，再从左到右，这样就可以用左边元素和上边元素（因为这两个已经有值了），然后后再从下到上，从右到左，这样右边和下边也有值（这样四个方向都兼顾到了），左后遍历完，输出数组即可。考虑完DP，又看到有BFS可以用，但是需要优化，他是先将所有的0元素入队列，然后从这些0元素向外扩展（很棒，不需要对于所有的元素都使用BFS），然后再将相邻位置-1和当前位置值比较，选择小的即可。"><a href="#解题思路：本题算是比较好的题目了，刚开始使用深度搜索-DFS-，发现超时了-（还没想出优化的方法），然后借鉴了一些想法，发现其实还有DP这一条路走，但是这题的DP还是比较特别的，要循环两次，因为dp-i-j-需要上下左右四个方向的值，但是一次循环只能获取两个方向，比如先从上到下，再从左到右，这样就可以用左边元素和上边元素（因为这两个已经有值了），然后后再从下到上，从右到左，这样右边和下边也有值（这样四个方向都兼顾到了），左后遍历完，输出数组即可。考虑完DP，又看到有BFS可以用，但是需要优化，他是先将所有的0元素入队列，然后从这些0元素向外扩展（很棒，不需要对于所有的元素都使用BFS），然后再将相邻位置-1和当前位置值比较，选择小的即可。" class="headerlink" title="解题思路：本题算是比较好的题目了，刚开始使用深度搜索(DFS)，发现超时了= =（还没想出优化的方法），然后借鉴了一些想法，发现其实还有DP这一条路走，但是这题的DP还是比较特别的，要循环两次，因为dp[i] [j]需要上下左右四个方向的值，但是一次循环只能获取两个方向，比如先从上到下，再从左到右，这样就可以用左边元素和上边元素（因为这两个已经有值了），然后后再从下到上，从右到左，这样右边和下边也有值（这样四个方向都兼顾到了），左后遍历完，输出数组即可。考虑完DP，又看到有BFS可以用，但是需要优化，他是先将所有的0元素入队列，然后从这些0元素向外扩展（很棒，不需要对于所有的元素都使用BFS），然后再将相邻位置+1和当前位置值比较，选择小的即可。"></a>解题思路：本题算是比较好的题目了，刚开始使用深度搜索(DFS)，发现超时了= =（还没想出优化的方法），然后借鉴了一些想法，发现其实还有DP这一条路走，但是这题的DP还是比较特别的，要循环两次，因为dp[i] [j]需要上下左右四个方向的值，但是一次循环只能获取两个方向，比如先从上到下，再从左到右，这样就可以用左边元素和上边元素（因为这两个已经有值了），然后后再从下到上，从右到左，这样右边和下边也有值（这样四个方向都兼顾到了），左后遍历完，输出数组即可。考虑完DP，又看到有BFS可以用，但是需要优化，他是先将所有的0元素入队列，然后从这些0元素向外扩展（很棒，不需要对于所有的元素都使用BFS），然后再将相邻位置+1和当前位置值比较，选择小的即可。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">DFS超时~~~~~~= =！</span></span><br><span class="line"><span class="comment">#define MAX 100000;</span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span></span><br><span class="line"><span class="comment">        vector&lt;vector&lt;int&gt;&gt;result(matrix.size(),vector&lt;int&gt;(matrix[0].size()));</span></span><br><span class="line"><span class="comment">        if(matrix.size()==0||matrix[0].size()==0)return result;</span></span><br><span class="line"><span class="comment">        for(int i=0;i&lt;matrix.size();i++)&#123;</span></span><br><span class="line"><span class="comment">            for(int j=0;j&lt;matrix[0].size();j++)&#123;</span></span><br><span class="line"><span class="comment">                result[i][j]=getMin(matrix,result,i,j,0);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return result;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    int getMin(vector&lt;vector&lt;int&gt;&gt;&amp; matrix,vector&lt;vector&lt;int&gt;&gt;&amp;result,int i,int j,int count)&#123;</span></span><br><span class="line"><span class="comment">        int row,col;</span></span><br><span class="line"><span class="comment">        row=matrix.size();</span></span><br><span class="line"><span class="comment">        col=matrix[0].size();</span></span><br><span class="line"><span class="comment">        //当前位置越界</span></span><br><span class="line"><span class="comment">        if(i&lt;0||i&gt;=row||j&lt;0||j&gt;=col||matrix[i][j]==99999)return MAX;</span></span><br><span class="line"><span class="comment">        if(matrix[i][j]==0)return count;</span></span><br><span class="line"><span class="comment">        matrix[i][j]=99999;</span></span><br><span class="line"><span class="comment">        int up=getMin(matrix,result,i-1,j,count+1);</span></span><br><span class="line"><span class="comment">        int down=getMin(matrix,result,i+1,j,count+1);</span></span><br><span class="line"><span class="comment">        int left=getMin(matrix,result,i,j-1,count+1);</span></span><br><span class="line"><span class="comment">        int right=getMin(matrix,result,i,j+1,count+1);</span></span><br><span class="line"><span class="comment">        matrix[i][j]=1;</span></span><br><span class="line"><span class="comment">        int min_value=min(up,down);</span></span><br><span class="line"><span class="comment">        min_value=min(min_value,left);</span></span><br><span class="line"><span class="comment">        min_value=min(min_value,right);</span></span><br><span class="line"><span class="comment">        return min_value;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span></span><br><span class="line"><span class="comment">        vector&lt;vector&lt;int&gt;&gt;dp(matrix.size(),vector&lt;int&gt;(matrix[0].size(),999999));</span></span><br><span class="line"><span class="comment">        int row=matrix.size();</span></span><br><span class="line"><span class="comment">        int col=matrix[0].size();</span></span><br><span class="line"><span class="comment">        if(row==0||col==0)return dp;</span></span><br><span class="line"><span class="comment">        //从上到下 从左到右遍历，这样就可以根据左边和上边 更新值</span></span><br><span class="line"><span class="comment">        for(int i=0;i&lt;row;i++)&#123;</span></span><br><span class="line"><span class="comment">            for(int j=0;j&lt;col;j++)&#123;</span></span><br><span class="line"><span class="comment">                if(matrix[i][j]==0)dp[i][j]=0;</span></span><br><span class="line"><span class="comment">                else&#123;</span></span><br><span class="line"><span class="comment">                    if(i&gt;0)dp[i][j]=min(dp[i][j],dp[i-1][j]+1);</span></span><br><span class="line"><span class="comment">                    if(j&gt;0)dp[i][j]=min(dp[i][j],dp[i][j-1]+1);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        //从下到上 从右到左遍历，这样就可以根据右边和下边 更新值，这样就满足了四个方向</span></span><br><span class="line"><span class="comment">        for(int i=row-1;i&gt;=0;i--)&#123;</span></span><br><span class="line"><span class="comment">            for(int j=col-1;j&gt;=0;j--)&#123;</span></span><br><span class="line"><span class="comment">                if(i&lt;row-1)dp[i][j]=min(dp[i][j],dp[i+1][j]+1);</span></span><br><span class="line"><span class="comment">                if(j&lt;col-1)dp[i][j]=min(dp[i][j],dp[i][j+1]+1);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return dp;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//其实感觉这一题还是用动态规划做比较好，并不是很经典的广度和深度搜索题目</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; updateMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span>)<span class="keyword">return</span> matrix;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;result(matrix.size(),<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(matrix[<span class="number">0</span>].size(),INT_MAX));</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix.size();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;matrix[<span class="number">0</span>].size();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                    result[i][j]=<span class="number">0</span>;</span><br><span class="line">                    q.push(&#123;i,j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nexti,nextj;</span><br><span class="line">        <span class="keyword">int</span> direct[<span class="number">2</span>][<span class="number">4</span>]=&#123;&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;cur;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            cur=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="comment">//定义四个方向</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)&#123;</span><br><span class="line">                nexti=cur.first+direct[<span class="number">0</span>][k];</span><br><span class="line">                nextj=cur.second+direct[<span class="number">1</span>][k];</span><br><span class="line">                <span class="keyword">if</span>(nexti&gt;=<span class="number">0</span>&amp;&amp;nexti&lt;matrix.size()&amp;&amp;nextj&gt;=<span class="number">0</span>&amp;&amp;nextj&lt;matrix[<span class="number">0</span>].size())&#123;</span><br><span class="line">                    <span class="keyword">if</span>(result[nexti][nextj]&gt;result[cur.first][cur.second]+<span class="number">1</span>)&#123;</span><br><span class="line">                        result[nexti][nextj]=result[cur.first][cur.second]+<span class="number">1</span>;</span><br><span class="line">                        q.push(&#123;nexti,nextj&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。两个相邻元素间的距离为 1 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/categories/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="广度搜索" scheme="https://cblog.club/categories/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%B9%BF%E5%BA%A6%E6%90%9C%E7%B4%A2/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="广度搜索" scheme="https://cblog.club/tags/%E5%B9%BF%E5%BA%A6%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
</feed>

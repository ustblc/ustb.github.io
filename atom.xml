<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>lemon</title>
  
  <subtitle>一直在路上</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cblog.club/"/>
  <updated>2020-01-01T06:08:37.862Z</updated>
  <id>https://cblog.club/</id>
  
  <author>
    <name>lemon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>字符流中第一个不重复的字符</title>
    <link href="https://cblog.club/ck535j1se008mmsg41tp5bxox.html"/>
    <id>https://cblog.club/ck535j1se008mmsg41tp5bxox.html</id>
    <published>2020-01-06T13:58:34.033Z</published>
    <updated>2020-01-01T06:08:37.862Z</updated>
    
    <content type="html"><![CDATA[<h4 id="字符流中第一个不重复的字符"><a href="#字符流中第一个不重复的字符" class="headerlink" title="字符流中第一个不重复的字符"></a>字符流中第一个不重复的字符</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p><p>如果当前字符流没有存在出现一次的字符，返回#字符。</p><a id="more"></a><h5 id="法一：主要借用Java中的相关结构，本题很容易想到hash表来判断字符出现的次数，我们只需要返回第一个出现次数为1的字符即可。stringbuilder-也可以换成其他数据结构，ArrayList也可以。"><a href="#法一：主要借用Java中的相关结构，本题很容易想到hash表来判断字符出现的次数，我们只需要返回第一个出现次数为1的字符即可。stringbuilder-也可以换成其他数据结构，ArrayList也可以。" class="headerlink" title="法一：主要借用Java中的相关结构，本题很容易想到hash表来判断字符出现的次数，我们只需要返回第一个出现次数为1的字符即可。stringbuilder 也可以换成其他数据结构，ArrayList也可以。"></a>法一：主要借用Java中的相关结构，本题很容易想到hash表来判断字符出现的次数，我们只需要返回第一个出现次数为1的字符即可。stringbuilder 也可以换成其他数据结构，ArrayList也可以。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder stringStream = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stringStream.append(ch);</span><br><span class="line">    <span class="comment">//这种hash设置值的写法，很有用。</span></span><br><span class="line">    map.put(ch,map.getOrDefault(ch,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringStream.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = stringStream.charAt(i);</span><br><span class="line">        <span class="keyword">int</span> charCount = map.get(c);</span><br><span class="line">        <span class="keyword">if</span> (charCount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="法二：我们不借助相关结构，就模拟底层实现，使用普通数组来模拟hash表即可。主要思路：因为ascii码总共有256个，所以创建一个数组，用以保存字符对应ascii码出现在字符流中的位置，初始全为-1，如果第一次遇到，就保存为当前字符流中的位置，如果是第二次遇到，就设置为-2，最后我们只观察数组值大于等于0的情况，找出一个在字符流中位置最小的一个，也就代表是第一个出现的字符。"><a href="#法二：我们不借助相关结构，就模拟底层实现，使用普通数组来模拟hash表即可。主要思路：因为ascii码总共有256个，所以创建一个数组，用以保存字符对应ascii码出现在字符流中的位置，初始全为-1，如果第一次遇到，就保存为当前字符流中的位置，如果是第二次遇到，就设置为-2，最后我们只观察数组值大于等于0的情况，找出一个在字符流中位置最小的一个，也就代表是第一个出现的字符。" class="headerlink" title="法二：我们不借助相关结构，就模拟底层实现，使用普通数组来模拟hash表即可。主要思路：因为ascii码总共有256个，所以创建一个数组，用以保存字符对应ascii码出现在字符流中的位置，初始全为-1，如果第一次遇到，就保存为当前字符流中的位置，如果是第二次遇到，就设置为-2，最后我们只观察数组值大于等于0的情况，找出一个在字符流中位置最小的一个，也就代表是第一个出现的字符。"></a>法二：我们不借助相关结构，就模拟底层实现，使用普通数组来模拟hash表即可。主要思路：因为ascii码总共有256个，所以创建一个数组，用以保存字符对应ascii码出现在字符流中的位置，初始全为-1，如果第一次遇到，就保存为当前字符流中的位置，如果是第二次遇到，就设置为-2，最后我们只观察数组值大于等于0的情况，找出一个在字符流中位置最小的一个，也就代表是第一个出现的字符。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] occurence = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">        occurence[i] = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    index = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (occurence[ch] == -<span class="number">1</span>) &#123;</span><br><span class="line">        occurence[ch] = index;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (occurence[ch] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        occurence[ch] = -<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    index++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ascii = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> minIndex = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (occurence[i] &gt;= <span class="number">0</span> &amp;&amp; occurence[i] &lt; minIndex) &#123;</span><br><span class="line">            minIndex = occurence[i];</span><br><span class="line">            ascii = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ascii == -<span class="number">1</span> ? <span class="string">'#'</span> : (<span class="keyword">char</span>)ascii;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结：</p><p>hash表思想的应用，像重复类问题，hash表是经常使用的结构，关键是如果设计hash表。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;字符流中第一个不重复的字符&quot;&gt;&lt;a href=&quot;#字符流中第一个不重复的字符&quot; class=&quot;headerlink&quot; title=&quot;字符流中第一个不重复的字符&quot;&gt;&lt;/a&gt;字符流中第一个不重复的字符&lt;/h4&gt;&lt;h5 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h5&gt;&lt;p&gt;请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。&lt;/p&gt;
&lt;p&gt;如果当前字符流没有存在出现一次的字符，返回#字符。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>重建二叉树</title>
    <link href="https://cblog.club/ck535j26900b9msg41r9o2d8r.html"/>
    <id>https://cblog.club/ck535j26900b9msg41r9o2d8r.html</id>
    <published>2020-01-06T13:58:34.030Z</published>
    <updated>2020-01-03T04:24:16.668Z</updated>
    
    <content type="html"><![CDATA[<h4 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><a id="more"></a><h5 id="法一：学过数据结构，肯定会知道，给出前序和中序（或者中序和后序）可以还原一颗二叉树，因为前序后序可以找到根节点，中序可以找到左右子结点。所以这一题主要思路就是使用递归，只有有前序和中序序列，我们就能生成一棵树，这就可以划分成一个个子任务。我们的工作就是给出每次递归需要使用的前序和中序序列即可！具体细节查看代码："><a href="#法一：学过数据结构，肯定会知道，给出前序和中序（或者中序和后序）可以还原一颗二叉树，因为前序后序可以找到根节点，中序可以找到左右子结点。所以这一题主要思路就是使用递归，只有有前序和中序序列，我们就能生成一棵树，这就可以划分成一个个子任务。我们的工作就是给出每次递归需要使用的前序和中序序列即可！具体细节查看代码：" class="headerlink" title="法一：学过数据结构，肯定会知道，给出前序和中序（或者中序和后序）可以还原一颗二叉树，因为前序后序可以找到根节点，中序可以找到左右子结点。所以这一题主要思路就是使用递归，只有有前序和中序序列，我们就能生成一棵树，这就可以划分成一个个子任务。我们的工作就是给出每次递归需要使用的前序和中序序列即可！具体细节查看代码："></a>法一：学过数据结构，肯定会知道，给出前序和中序（或者中序和后序）可以还原一颗二叉树，因为前序后序可以找到根节点，中序可以找到左右子结点。所以这一题主要思路就是使用递归，只有有前序和中序序列，我们就能生成一棵树，这就可以划分成一个个子任务。我们的工作就是给出每次递归需要使用的前序和中序序列即可！具体细节查看代码：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre, <span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pre == <span class="keyword">null</span> || in == <span class="keyword">null</span> || pre.length == <span class="number">0</span> || in.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先序的第一个结点肯定是根节点</span></span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//找到根节点在中序序列中的位置</span></span><br><span class="line">    <span class="keyword">int</span> len = pre.length;</span><br><span class="line">    <span class="keyword">int</span> rootIndex  = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (in[i] == pre[<span class="number">0</span>]) &#123;</span><br><span class="line">            rootIndex = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//既然找到根节点在中序中的位置，那么我们就可以找出前序的左右子树部分和中序的左右子树部分</span></span><br><span class="line">    <span class="keyword">int</span>[] preLeft = <span class="keyword">new</span> <span class="keyword">int</span>[rootIndex];</span><br><span class="line">    <span class="keyword">int</span>[] preRight = <span class="keyword">new</span> <span class="keyword">int</span>[len - rootIndex - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span>[] inLeft = <span class="keyword">new</span> <span class="keyword">int</span>[rootIndex];</span><br><span class="line">    <span class="keyword">int</span>[] inRight = <span class="keyword">new</span> <span class="keyword">int</span>[len - rootIndex - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//将根节点左边的结点和右边的结点插入到相应的数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rootIndex; i++) &#123;</span><br><span class="line">        preLeft[i] = pre[i + <span class="number">1</span>];</span><br><span class="line">        inLeft[i] = in[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = rootIndex + <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        preRight[k] = pre[i];</span><br><span class="line">        inRight[k++] = in[i];</span><br><span class="line">    &#125;</span><br><span class="line">    root.left = reConstructBinaryTree(preLeft, inLeft);</span><br><span class="line">    root.right = reConstructBinaryTree(preRight, inRight);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="法二：同样的思想，我们可以使代码更优雅一点，使用到了java的函数Arrays-copyOfRange，他的作用就是创建一个新的复制了其他数组一段范围的数组。"><a href="#法二：同样的思想，我们可以使代码更优雅一点，使用到了java的函数Arrays-copyOfRange，他的作用就是创建一个新的复制了其他数组一段范围的数组。" class="headerlink" title="法二：同样的思想，我们可以使代码更优雅一点，使用到了java的函数Arrays.copyOfRange，他的作用就是创建一个新的复制了其他数组一段范围的数组。"></a>法二：同样的思想，我们可以使代码更优雅一点，使用到了java的函数<code>Arrays.copyOfRange</code>，他的作用就是创建一个新的复制了其他数组一段范围的数组。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre, <span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pre == <span class="keyword">null</span> || in == <span class="keyword">null</span> || pre.length == <span class="number">0</span> || in.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先序的第一个结点肯定是根节点</span></span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//找到根节点在中序序列中的位置</span></span><br><span class="line">    <span class="keyword">int</span> len = pre.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (in[i] == pre[<span class="number">0</span>]) &#123;</span><br><span class="line">            root.left = reConstructBinaryTree(Arrays.copyOfRange(pre, <span class="number">1</span>, i + <span class="number">1</span>),</span><br><span class="line">                                              Arrays.copyOfRange(in, <span class="number">0</span>, i));</span><br><span class="line">            root.right = reConstructBinaryTree(Arrays.copyOfRange(pre, i + <span class="number">1</span>, len),</span><br><span class="line">                                               Arrays.copyOfRange(in, i + <span class="number">1</span>, len));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="法三：既然我们传递数组开销会很大，那么传入索引下标的话，就会减少一定的开销："><a href="#法三：既然我们传递数组开销会很大，那么传入索引下标的话，就会减少一定的开销：" class="headerlink" title="法三：既然我们传递数组开销会很大，那么传入索引下标的话，就会减少一定的开销："></a>法三：既然我们传递数组开销会很大，那么传入索引下标的话，就会减少一定的开销：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre, <span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pre == <span class="keyword">null</span> || in == <span class="keyword">null</span> || pre.length == <span class="number">0</span> || in.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getNode(pre, in, <span class="number">0</span>, pre.length - <span class="number">1</span>, <span class="number">0</span>, in.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> [] pre, <span class="keyword">int</span> [] in, <span class="keyword">int</span> startPre, <span class="keyword">int</span> endPre, <span class="keyword">int</span> startIn, <span class="keyword">int</span> endIn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (startPre &gt; endPre || startIn &gt; endIn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(pre[startPre]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = startIn; i &lt;= endIn; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (in[i] == pre[startPre]) &#123;</span><br><span class="line">            root.left = getNode(pre, in, startPre + <span class="number">1</span>, startPre + i - startIn, startIn, i - <span class="number">1</span>);</span><br><span class="line">            root.right = getNode(pre, in, startPre + i - startIn + <span class="number">1</span>, endPre, i + <span class="number">1</span>, endIn);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结：</p><p>树的题目基本都可以使用递归来解决，而对于递归的理解，还是需要一些题目的理解。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;重建二叉树&quot;&gt;&lt;a href=&quot;#重建二叉树&quot; class=&quot;headerlink&quot; title=&quot;重建二叉树&quot;&gt;&lt;/a&gt;重建二叉树&lt;/h4&gt;&lt;h5 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h5&gt;&lt;p&gt;输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>正则表达式匹配</title>
    <link href="https://cblog.club/ck535j20m00a5msg44orp62yu.html"/>
    <id>https://cblog.club/ck535j20m00a5msg44orp62yu.html</id>
    <published>2020-01-06T13:58:34.026Z</published>
    <updated>2020-01-01T02:22:43.577Z</updated>
    
    <content type="html"><![CDATA[<h4 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>请实现一个函数用来匹配包括’.’和’*‘的正则表达式。模式中的字符’.’表示任意一个字符，而’*‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串<code>&quot;aaa&quot;</code>与模式<code>&quot;a.a&quot;</code>和<code>&quot;ab*ac*a&quot;</code>匹配，但是与<code>&quot;aa.a&quot;</code>和<code>&quot;ab*a&quot;</code>均不匹配</p><a id="more"></a><p>本题考察的能力主要就是分析问题能力，思维的严谨性。</p><h5 id="法一：使用递归求解。"><a href="#法一：使用递归求解。" class="headerlink" title="法一：使用递归求解。"></a>法一：使用递归求解。</h5><p>思路：</p><ul><li>当pattern遍历完，return取决于str是否遍历完，str恰好遍历完才返回true，再接下来讨论</li><li>若当前pattern字符串存在下一个字符，看下一个字符是否是 ‘*’，如果是，有2种情况<ul><li>当前匹配（两字符相等或者pattern字符为’.’）<ul><li><code>matchCore(str, pattern, p1 + 1, p2)</code>：保持pattern当前状态，此时代表*前面字符出现次数为多次，举个例子：<code>str = aa,pattern = a*</code>，这种有可能下一个字符还是会匹配的字符，这样选择保持pattern当前的状态。</li><li><code>matchCore(str, pattern, p1 + 1, p2 + 2)</code>：此时代表*前面字符出现次数为1次，举个例子：<code>str = ab,pattern = a*b</code> (这一种可以忽视掉，因为这一步相当于1 3的结合（和先走步骤1再走步骤3是等效的，所以这一个步骤是重复的，会浪费大量时间!））</li><li><code>matchCore(str, pattern, p1, p2 + 2);</code>：忽视当前pattern状态，此时代表*前面字符串次数为0次，举个例子：<code>str = ab,pattern = a*ab</code></li></ul></li><li>当前不匹配（两个字符不相等且pattern字符也不是’.’）<ul><li><code>matchCore(str, pattern, p1, p2 + 2);</code>：忽视当前pattern状态，此时代表*前面字符串次数为0次，直接忽视掉这个不相等的字符。</li></ul></li></ul></li><li>pattern字符串下一个字符不是’*’<ul><li>当前匹配（两字符相等或者pattern字符为’.’）<ul><li><code>matchCore(str, pattern, p1 + 1, p2 + 1);</code>都向后走一步</li></ul></li><li>当前不匹配<ul><li>直接返回false，因为已经匹配失败了。</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">char</span>[] pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || pattern == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matchCore(str, pattern, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matchCore</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">char</span>[] pattern, <span class="keyword">int</span> p1, <span class="keyword">int</span> p2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p2 == pattern.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> p1 == str.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p2 &lt; pattern.length - <span class="number">1</span> &amp;&amp; pattern[p2 + <span class="number">1</span>] == <span class="string">'*'</span> ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1 &lt; str.length &amp;&amp; (str[p1] == pattern[p2] || pattern[p2] == <span class="string">'.'</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> matchCore(str, pattern, p1 + <span class="number">1</span>, p2)</span><br><span class="line">                || matchCore(str, pattern, p1, p2 + <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> matchCore(str, pattern, p1, p2 + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p1 &lt; str.length &amp;&amp; (str[p1] == pattern[p2] || pattern[p2] == <span class="string">'.'</span> )) &#123;</span><br><span class="line">        <span class="keyword">return</span> matchCore(str, pattern, p1 + <span class="number">1</span>, p2 + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="法二：动态规划"><a href="#法二：动态规划" class="headerlink" title="法二：动态规划"></a>法二：动态规划</h5><p>有了前面的认识，我们考虑用动态规划解题。</p><ul><li>看下前面的递归调用：<code>matchCore(str, pattern, p1 + 1, p2 + 1)</code>相当于<code>dp[i][j]=dp[i+1][j+1]</code></li><li>适合反向遍历，于是，我们可以初始化<code>boolean dp[lenStr][lenPattern]</code></li><li>初始化<code>dp[lenStr][lenPattern] = true;</code>,含义是：<code>str=aaa 和pattern=aa*</code>从末尾开始匹配 “” 和 “” 一定为true</li></ul><p>其余逻辑和法一相同，只不过递归我们改成了动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">char</span>[] pattern)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || pattern == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> lenStr = str.length;</span><br><span class="line">    <span class="keyword">int</span> lenPattern = pattern.length;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[lenStr + <span class="number">1</span>][lenPattern + <span class="number">1</span>];</span><br><span class="line">    dp[lenStr][lenPattern] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lenStr; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = lenPattern - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; lenPattern - <span class="number">1</span> &amp;&amp; pattern[j + <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; lenStr &amp;&amp; (str[i] == pattern[j] || pattern[j] == <span class="string">'.'</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j] || dp[i][j + <span class="number">2</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j + <span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; lenStr &amp;&amp; (str[i] == pattern[j] || pattern[j] == <span class="string">'.'</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j + <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结：</p><p>本题十分注重思维的严谨性，要考虑所有的情况，代码的完整性非常重要，有了递归，我们基本就可以使用DP来替换，这个技巧需要掌握。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;正则表达式匹配&quot;&gt;&lt;a href=&quot;#正则表达式匹配&quot; class=&quot;headerlink&quot; title=&quot;正则表达式匹配&quot;&gt;&lt;/a&gt;正则表达式匹配&lt;/h4&gt;&lt;h5 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h5&gt;&lt;p&gt;请实现一个函数用来匹配包括’.’和’*‘的正则表达式。模式中的字符’.’表示任意一个字符，而’*‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&lt;code&gt;&amp;quot;aaa&amp;quot;&lt;/code&gt;与模式&lt;code&gt;&amp;quot;a.a&amp;quot;&lt;/code&gt;和&lt;code&gt;&amp;quot;ab*ac*a&amp;quot;&lt;/code&gt;匹配，但是与&lt;code&gt;&amp;quot;aa.a&amp;quot;&lt;/code&gt;和&lt;code&gt;&amp;quot;ab*a&amp;quot;&lt;/code&gt;均不匹配&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>栈的压入和弹出序列</title>
    <link href="https://cblog.club/ck535j20b00a1msg42fs0gfkq.html"/>
    <id>https://cblog.club/ck535j20b00a1msg42fs0gfkq.html</id>
    <published>2020-01-06T13:58:34.024Z</published>
    <updated>2020-01-06T00:57:19.327Z</updated>
    
    <content type="html"><![CDATA[<h4 id="栈的压入和弹出序列"><a href="#栈的压入和弹出序列" class="headerlink" title="栈的压入和弹出序列"></a>栈的压入和弹出序列</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><a id="more"></a><h5 id="法一：经过自己手动模拟发现，我们先按照pop的第一个元素，依次入栈（比如说题目中给的pop第一个数字为4，就意味着1-2-3都入栈了，然后循环popA，和栈顶元素相比，相同就出栈，不同就入栈），最后如果栈为空就意味着该序列是一个正确的弹出序列。"><a href="#法一：经过自己手动模拟发现，我们先按照pop的第一个元素，依次入栈（比如说题目中给的pop第一个数字为4，就意味着1-2-3都入栈了，然后循环popA，和栈顶元素相比，相同就出栈，不同就入栈），最后如果栈为空就意味着该序列是一个正确的弹出序列。" class="headerlink" title="法一：经过自己手动模拟发现，我们先按照pop的第一个元素，依次入栈（比如说题目中给的pop第一个数字为4，就意味着1 2 3都入栈了，然后循环popA，和栈顶元素相比，相同就出栈，不同就入栈），最后如果栈为空就意味着该序列是一个正确的弹出序列。"></a>法一：经过自己手动模拟发现，我们先按照pop的第一个元素，依次入栈（比如说题目中给的pop第一个数字为4，就意味着1 2 3都入栈了，然后循环popA，和栈顶元素相比，相同就出栈，不同就入栈），最后如果栈为空就意味着该序列是一个正确的弹出序列。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pushA == <span class="keyword">null</span> || popA == <span class="keyword">null</span> || pushA.length == <span class="number">0</span> || popA.length != pushA.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pushA.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pushA[i] == popA[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(pushA[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; popA.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.peek() == popA[i]) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="法二：另外一种解法，和法一很相似，大差不差，只不过看起来优雅一些，主要思路："><a href="#法二：另外一种解法，和法一很相似，大差不差，只不过看起来优雅一些，主要思路：" class="headerlink" title="法二：另外一种解法，和法一很相似，大差不差，只不过看起来优雅一些，主要思路："></a>法二：另外一种解法，和法一很相似，大差不差，只不过看起来优雅一些，主要思路：</h5><p>按照pushA压入栈中，如果当前栈顶元素和pop对应元素一样，出栈，pop向后一个step，最后看栈是否为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pushA == <span class="keyword">null</span> || popA == <span class="keyword">null</span> || pushA.length == <span class="number">0</span> || popA.length != pushA.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> popIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pushA.length; i++) &#123;</span><br><span class="line">        stack.push(pushA[i]);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() == popA[popIndex]) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            popIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结：</p><p>举例子，将抽象的问题具体化，找出其规律。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;栈的压入和弹出序列&quot;&gt;&lt;a href=&quot;#栈的压入和弹出序列&quot; class=&quot;headerlink&quot; title=&quot;栈的压入和弹出序列&quot;&gt;&lt;/a&gt;栈的压入和弹出序列&lt;/h4&gt;&lt;h5 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h5&gt;&lt;p&gt;输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>用两个栈实现队列</title>
    <link href="https://cblog.club/ck535j22500apmsg4ggotgvl8.html"/>
    <id>https://cblog.club/ck535j22500apmsg4ggotgvl8.html</id>
    <published>2020-01-06T13:58:34.020Z</published>
    <updated>2020-01-01T08:58:39.473Z</updated>
    
    <content type="html"><![CDATA[<h4 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><a id="more"></a><h5 id="法一：本题主要考察栈和队列的性质，栈：后进先出，队列：先进先出（二者正好相反）。那么如果我们想用栈实现队列，那么使用两个栈，进出两次，就能实现先进先出的功能了。首先push元素，元素全部压入第一个栈，如果pop元素，那么就将当前栈1的所有元素压入栈2，然后出栈即可。"><a href="#法一：本题主要考察栈和队列的性质，栈：后进先出，队列：先进先出（二者正好相反）。那么如果我们想用栈实现队列，那么使用两个栈，进出两次，就能实现先进先出的功能了。首先push元素，元素全部压入第一个栈，如果pop元素，那么就将当前栈1的所有元素压入栈2，然后出栈即可。" class="headerlink" title="法一：本题主要考察栈和队列的性质，栈：后进先出，队列：先进先出（二者正好相反）。那么如果我们想用栈实现队列，那么使用两个栈，进出两次，就能实现先进先出的功能了。首先push元素，元素全部压入第一个栈，如果pop元素，那么就将当前栈1的所有元素压入栈2，然后出栈即可。"></a>法一：本题主要考察栈和队列的性质，栈：后进先出，队列：先进先出（二者正好相反）。那么如果我们想用栈实现队列，那么使用两个栈，进出两次，就能实现先进先出的功能了。首先push元素，元素全部压入第一个栈，如果pop元素，那么就将当前栈1的所有元素压入栈2，然后出栈即可。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">    stack1.push(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stack1.isEmpty() &amp;&amp; stack2.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Queue is empty!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stack2.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack1.isEmpty()) &#123;</span><br><span class="line">            stack2.add(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack2.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结：</p><p>本题难度很小，也没什么很好的其他方法，另外，Java中的stack的pop()方法是取栈顶元素并且出栈。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;用两个栈实现队列&quot;&gt;&lt;a href=&quot;#用两个栈实现队列&quot; class=&quot;headerlink&quot; title=&quot;用两个栈实现队列&quot;&gt;&lt;/a&gt;用两个栈实现队列&lt;/h4&gt;&lt;h5 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h5&gt;&lt;p&gt;用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>序列化二叉树</title>
    <link href="https://cblog.club/ck535j1v00092msg4abpk2qcj.html"/>
    <id>https://cblog.club/ck535j1v00092msg4abpk2qcj.html</id>
    <published>2020-01-06T13:58:34.017Z</published>
    <updated>2020-01-04T10:13:52.617Z</updated>
    
    <content type="html"><![CDATA[<h4 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>请实现两个函数，分别用来序列化和反序列化二叉树</p><p>二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。</p><p>二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p><a id="more"></a><h5 id="法一：首先，这里我们采用层次遍历，之所以使用层次遍历，是因为从字符串转换为树的时候，左右结点容易确定。我们每个结点之间使用空格，如果空结点使用’-’代替。"><a href="#法一：首先，这里我们采用层次遍历，之所以使用层次遍历，是因为从字符串转换为树的时候，左右结点容易确定。我们每个结点之间使用空格，如果空结点使用’-’代替。" class="headerlink" title="法一：首先，这里我们采用层次遍历，之所以使用层次遍历，是因为从字符串转换为树的时候，左右结点容易确定。我们每个结点之间使用空格，如果空结点使用’#’代替。"></a>法一：首先，这里我们采用层次遍历，之所以使用层次遍历，是因为从字符串转换为树的时候，左右结点容易确定。我们每个结点之间使用空格，如果空结点使用’#’代替。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Queue&lt;TreeNode&gt; nodes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="function">String <span class="title">Serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用StringBuilder效率会高一点</span></span><br><span class="line">    StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    nodes.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!nodes.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = nodes.poll();</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            str.append(node.val);</span><br><span class="line">            <span class="comment">//注意空结点也要入队</span></span><br><span class="line">            nodes.offer(node.left);</span><br><span class="line">            nodes.offer(node.right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            str.append(<span class="string">"#"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        str.append(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode <span class="title">Deserialize</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//之所以使用这个分隔的方法，是因为数字不只是一位的，所以不能采用一位一位的字符判断</span></span><br><span class="line">    String[] nodeStr = str.split(<span class="string">" "</span>);</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(nodeStr[<span class="number">0</span>]));</span><br><span class="line">    nodes.offer(root);</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!nodes.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = nodes.poll();</span><br><span class="line">        <span class="keyword">if</span> (index &lt; nodeStr.length) &#123;</span><br><span class="line">            node.left = nodeStr[index].equals(<span class="string">"#"</span>) ? <span class="keyword">null</span> : <span class="keyword">new</span> TreeNode(Integer.parseInt(nodeStr[index]));</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; nodeStr.length) &#123;</span><br><span class="line">            node.right = nodeStr[index].equals(<span class="string">"#"</span>) ? <span class="keyword">null</span> : <span class="keyword">new</span> TreeNode(Integer.parseInt(nodeStr[index]));</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            nodes.offer(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            nodes.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结：</p><p>树转换为字符串比较容易，反过来，会稍微复杂一点，一定要动手。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;序列化二叉树&quot;&gt;&lt;a href=&quot;#序列化二叉树&quot; class=&quot;headerlink&quot; title=&quot;序列化二叉树&quot;&gt;&lt;/a&gt;序列化二叉树&lt;/h4&gt;&lt;h5 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h5&gt;&lt;p&gt;请实现两个函数，分别用来序列化和反序列化二叉树&lt;/p&gt;
&lt;p&gt;二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。&lt;/p&gt;
&lt;p&gt;二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>跳台阶</title>
    <link href="https://cblog.club/ck535j24z00b4msg49ko3371s.html"/>
    <id>https://cblog.club/ck535j24z00b4msg49ko3371s.html</id>
    <published>2020-01-06T13:58:34.014Z</published>
    <updated>2020-01-06T13:03:03.523Z</updated>
    
    <content type="html"><![CDATA[<h4 id="跳台阶"><a href="#跳台阶" class="headerlink" title="跳台阶"></a>跳台阶</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><a id="more"></a><h5 id="法一：我们通过分析发现，其实这个斐波那契数列是一个问题，因为我们当前的台阶可以通过前一阶或者前两阶跳上来，那么当前台阶的跳法就等于前者跳法之和。"><a href="#法一：我们通过分析发现，其实这个斐波那契数列是一个问题，因为我们当前的台阶可以通过前一阶或者前两阶跳上来，那么当前台阶的跳法就等于前者跳法之和。" class="headerlink" title="法一：我们通过分析发现，其实这个斐波那契数列是一个问题，因为我们当前的台阶可以通过前一阶或者前两阶跳上来，那么当前台阶的跳法就等于前者跳法之和。"></a>法一：我们通过分析发现，其实这个斐波那契数列是一个问题，因为我们当前的台阶可以通过前一阶或者前两阶跳上来，那么当前台阶的跳法就等于前者跳法之和。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">1</span> || target == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  JumpFloor(target - <span class="number">1</span>) + JumpFloor(target - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="法二：同斐波那契那题，动态规划解法（O-1-空间复杂度）："><a href="#法二：同斐波那契那题，动态规划解法（O-1-空间复杂度）：" class="headerlink" title="法二：同斐波那契那题，动态规划解法（O(1)空间复杂度）："></a>法二：同斐波那契那题，动态规划解法（O(1)空间复杂度）：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">1</span> || target == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dp1 = <span class="number">1</span>, dp2 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> dp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            dp = dp1 + dp2;</span><br><span class="line">            dp1 = dp2;</span><br><span class="line">            dp2 = dp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;跳台阶&quot;&gt;&lt;a href=&quot;#跳台阶&quot; class=&quot;headerlink&quot; title=&quot;跳台阶&quot;&gt;&lt;/a&gt;跳台阶&lt;/h4&gt;&lt;h5 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h5&gt;&lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>替换空格</title>
    <link href="https://cblog.club/ck535j1yx009lmsg40qq3br23.html"/>
    <id>https://cblog.club/ck535j1yx009lmsg40qq3br23.html</id>
    <published>2020-01-06T13:58:34.011Z</published>
    <updated>2019-12-31T06:38:02.146Z</updated>
    
    <content type="html"><![CDATA[<h4 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为<code>We Are Happy</code>。则经过替换之后的字符串为<code>We%20Are%20Happy</code>。</p><a id="more"></a><h5 id="法一：第一种思路就是另外开辟一个字符串，碰到空格改成”-20”即可，其余不变插入到新字符串中，时间复杂度为O-n-，空间复杂度为O-n-。"><a href="#法一：第一种思路就是另外开辟一个字符串，碰到空格改成”-20”即可，其余不变插入到新字符串中，时间复杂度为O-n-，空间复杂度为O-n-。" class="headerlink" title="法一：第一种思路就是另外开辟一个字符串，碰到空格改成”%20”即可，其余不变插入到新字符串中，时间复杂度为O(n)，空间复杂度为O(n)。"></a>法一：第一种思路就是另外开辟一个字符串，碰到空格改成”%20”即可，其余不变插入到新字符串中，时间复杂度为O(n)，空间复杂度为O(n)。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">//String ans = "";</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;str.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(i) != <span class="string">' '</span>) &#123;</span><br><span class="line">            ans.append(str.charAt(i));</span><br><span class="line">            <span class="comment">//ans += str.charAt(i);</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans.append(<span class="string">"%20"</span>);</span><br><span class="line">            <span class="comment">//ans += "%20";</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.toString();</span><br><span class="line">    <span class="comment">//return ans;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然你还可以直接用字符串的 + 来拼接字符串，但是这种方法并没有<code>StringBuilder</code>效率高。来看廖雪峰老师关于这方面的说明：+ 虽然可以直接拼接字符串，但是，在循环中，每次循环都会创建新的字符串对象，然后扔掉旧的字符串。这样，绝大部分字符串都是临时对象，不但浪费内存，还会影响GC（垃圾回收）效率。为了能高效拼接字符串，Java标准库提供了<code>StringBuilder</code>，它是一个可变对象，可以预分配缓冲区，这样，往<code>StringBuilder</code>中新增字符时，不会创建新的临时对象。再多说一句，char是基本类型，可以用 == 来比较，不用<code>equals</code></p><h5 id="法二：如果题目要求不能使用辅助字符串的话，我们只能在原字符串的基础上进行替换和移动了。暴力破解的话，就是遇到空格就替换，然后将其后面所有元素向后移动两位，时间复杂度为O-n-2-，空间复杂度为O-1-。"><a href="#法二：如果题目要求不能使用辅助字符串的话，我们只能在原字符串的基础上进行替换和移动了。暴力破解的话，就是遇到空格就替换，然后将其后面所有元素向后移动两位，时间复杂度为O-n-2-，空间复杂度为O-1-。" class="headerlink" title="法二：如果题目要求不能使用辅助字符串的话，我们只能在原字符串的基础上进行替换和移动了。暴力破解的话，就是遇到空格就替换，然后将其后面所有元素向后移动两位，时间复杂度为O(n^2)，空间复杂度为O(1)。"></a>法二：如果题目要求不能使用辅助字符串的话，我们只能在原字符串的基础上进行替换和移动了。暴力破解的话，就是遇到空格就替换，然后将其后面所有元素向后移动两位，时间复杂度为O(n^2)，空间复杂度为O(1)。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    <span class="keyword">int</span> blankCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(i) == <span class="string">' '</span>) &#123;</span><br><span class="line">            blankCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> trueLen = len + blankCount * <span class="number">2</span>;</span><br><span class="line">    str.setLength(trueLen);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; trueLen; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(i) == <span class="string">' '</span>) &#123;</span><br><span class="line">            str.setCharAt(i, <span class="string">'%'</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = len - <span class="number">1</span>; j &gt;= i + <span class="number">1</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = str.charAt(j);</span><br><span class="line">                str.setCharAt(j + <span class="number">2</span>, c);</span><br><span class="line">            &#125;</span><br><span class="line">            str.setCharAt(i + <span class="number">1</span>, <span class="string">'2'</span>);</span><br><span class="line">            str.setCharAt(i + <span class="number">2</span>, <span class="string">'0'</span>);</span><br><span class="line">            len += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题参数给的是<code>StringBuffer</code>，刚开始就在想为什么给这个，后来才发现，<code>String</code>字符串是不允许更改的，而<code>StringBuffer</code>是允许更改字符的！所以这一题的本意就应该考察的是在原字符串的基础上进行改动，第一种思路虽然也不错，但是不是考察的内容。</p><p>要注意的是，我们只能从最后一个字符开始替换，不然会覆盖掉后边的元素，然而我们每替换一次，最后一个字符就会向后走两位，<code>len += 2;</code>很关键。</p><h5 id="法三：既然第二种方法的时间复杂度是o-n-2-，那我们能不能再优化一下，降低到O-n-呢？之前我们替换是从前往后，那么我们从后往前替换。"><a href="#法三：既然第二种方法的时间复杂度是o-n-2-，那我们能不能再优化一下，降低到O-n-呢？之前我们替换是从前往后，那么我们从后往前替换。" class="headerlink" title="法三：既然第二种方法的时间复杂度是o(n^2)，那我们能不能再优化一下，降低到O(n)呢？之前我们替换是从前往后，那么我们从后往前替换。"></a>法三：既然第二种方法的时间复杂度是o(n^2)，那我们能不能再优化一下，降低到O(n)呢？之前我们替换是从前往后，那么我们从后往前替换。</h5><ul><li>首先计算空格的总数，这样就能计算出最后要返回的字符串的最终长度。</li><li>双指针技巧，一个指向原字符串的末尾，一个指向最终字符串的末尾。<ul><li>如果不是空格，就将原字符放到最终字符的位置</li><li>如果是空格，替换三个字符</li><li>直到第一个指针走到字符串初始位置位置</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    <span class="keyword">int</span> blankCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(i) == <span class="string">' '</span>) &#123;</span><br><span class="line">            blankCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> trueLen = len + blankCount * <span class="number">2</span>;</span><br><span class="line">    str.setLength(trueLen);</span><br><span class="line">    <span class="keyword">int</span> p1 = len - <span class="number">1</span>, p2 = trueLen - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &gt;= <span class="number">0</span> &amp;&amp; trueLen &gt; len) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = str.charAt(p1--);</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="string">' '</span>) &#123;</span><br><span class="line">            str.setCharAt(p2--, c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            str.setCharAt(p2--, <span class="string">'0'</span>);</span><br><span class="line">            str.setCharAt(p2--, <span class="string">'2'</span>);</span><br><span class="line">            str.setCharAt(p2--, <span class="string">'%'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结：</p><p>两个思路，一是开辟一个新字符串，二是在原字符串基础上替换移动，这一题想考察的应该就是第二个思路，然后从第二个思路出发，将O(n^2)优化到O(n)，还是值得借鉴。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;替换空格&quot;&gt;&lt;a href=&quot;#替换空格&quot; class=&quot;headerlink&quot; title=&quot;替换空格&quot;&gt;&lt;/a&gt;替换空格&lt;/h4&gt;&lt;h5 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h5&gt;&lt;p&gt;请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为&lt;code&gt;We Are Happy&lt;/code&gt;。则经过替换之后的字符串为&lt;code&gt;We%20Are%20Happy&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>顺时针打印矩阵</title>
    <link href="https://cblog.club/ck535j2pb00cpmsg487rl76el.html"/>
    <id>https://cblog.club/ck535j2pb00cpmsg487rl76el.html</id>
    <published>2020-01-06T13:58:34.007Z</published>
    <updated>2020-01-05T03:16:18.940Z</updated>
    
    <content type="html"><![CDATA[<h4 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵：<code>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</code></p><a id="more"></a><h5 id="法一：这一题就是leetcode上的螺旋矩阵，大体思路就是模拟四个方向，如果一旦越界，就调整方向，并且还要使用一个标志数组标记走过的数字（另外有一种方法，走过的数字改成Integer-MAX-VALUE，但是这种方法还是不太好，万一数组中就有一个数字是这个数呢，虽然可能leetcoe包括牛客后台数据能过，但是还是不保险，最好还是使用标记数组）："><a href="#法一：这一题就是leetcode上的螺旋矩阵，大体思路就是模拟四个方向，如果一旦越界，就调整方向，并且还要使用一个标志数组标记走过的数字（另外有一种方法，走过的数字改成Integer-MAX-VALUE，但是这种方法还是不太好，万一数组中就有一个数字是这个数呢，虽然可能leetcoe包括牛客后台数据能过，但是还是不保险，最好还是使用标记数组）：" class="headerlink" title="法一：这一题就是leetcode上的螺旋矩阵，大体思路就是模拟四个方向，如果一旦越界，就调整方向，并且还要使用一个标志数组标记走过的数字（另外有一种方法，走过的数字改成Integer.MAX_VALUE，但是这种方法还是不太好，万一数组中就有一个数字是这个数呢，虽然可能leetcoe包括牛客后台数据能过，但是还是不保险，最好还是使用标记数组）："></a>法一：这一题就是leetcode上的螺旋矩阵，大体思路就是模拟四个方向，如果一旦越界，就调整方向，并且还要使用一个标志数组标记走过的数字（另外有一种方法，走过的数字改成<code>Integer.MAX_VALUE</code>，但是这种方法还是不太好，万一数组中就有一个数字是这个数呢，虽然可能leetcoe包括牛客后台数据能过，但是还是不保险，最好还是使用标记数组）：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">//获取最终要返回数组的元素的个数</span></span><br><span class="line">    <span class="keyword">int</span> size = row * col;</span><br><span class="line">    <span class="comment">//定义四个方向</span></span><br><span class="line">    <span class="keyword">int</span>[][] direct = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> curX, curY, nextX, nextY, der;</span><br><span class="line">    <span class="comment">//定义初始位置和初始方向</span></span><br><span class="line">    curX = curY = der =  <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[row][col];</span><br><span class="line">    <span class="keyword">while</span> (ans.size() &lt; size) &#123;</span><br><span class="line">        <span class="comment">//如果当前位置没有访问过，就插入到最终结果数组中</span></span><br><span class="line">        <span class="keyword">if</span> (!visited[curX][curY]) &#123;</span><br><span class="line">            ans.add(matrix[curX][curY]);</span><br><span class="line">            visited[curX][curY] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取下一个位置</span></span><br><span class="line">        nextX = curX + direct[<span class="number">0</span>][der];</span><br><span class="line">        nextY = curY + direct[<span class="number">1</span>][der];</span><br><span class="line">        <span class="comment">//判断该位置是否越界和被访问过</span></span><br><span class="line">        <span class="keyword">if</span> (nextX &gt;= <span class="number">0</span> &amp;&amp; nextX &lt; row &amp;&amp; nextY &gt;=<span class="number">0</span> &amp;&amp; nextY &lt; col &amp;&amp; !visited[nextX][nextY]) &#123;</span><br><span class="line">            curX = nextX;</span><br><span class="line">            curY = nextY;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//转向，这个%4很精髓，因为数组很大的时候，要转多次向！</span></span><br><span class="line">            der = (der + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="法二：这一种解法是剑指offer书上的解法，个人觉得还可以。他的主要思想："><a href="#法二：这一种解法是剑指offer书上的解法，个人觉得还可以。他的主要思想：" class="headerlink" title="法二：这一种解法是剑指offer书上的解法，个人觉得还可以。他的主要思想："></a>法二：这一种解法是剑指offer书上的解法，个人觉得还可以。他的主要思想：</h5><p>我们每次循环的开始起点总是x、y相等的位置，然后通过模拟发现，循环的条件是起点(start, start)中，行数和列数均&gt;start*2，讲道理，如果第一次做，一般是总结不出来这个规律的= =！之后，我们就要分为四次的循环，完成一圈的遍历，具体细节看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (row &gt; start * <span class="number">2</span> &amp;&amp; col &gt; start * <span class="number">2</span>) &#123;</span><br><span class="line">        printMatrixEdge(matrix, row, col, start);</span><br><span class="line">        start++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMatrixEdge</span><span class="params">(<span class="keyword">int</span> [][] matrix, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//首先计算终止坐标</span></span><br><span class="line">    <span class="keyword">int</span> endX = row - <span class="number">1</span> - start;</span><br><span class="line">    <span class="keyword">int</span> endY = col - <span class="number">1</span> - start;</span><br><span class="line">    <span class="comment">//从左往右打印一行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= endY; i++) &#123;</span><br><span class="line">        ans.add(matrix[start][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从上到下打印一列，前提条件是起始行号要小于终止行号</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; endX) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i  &lt;= endX; i++) &#123;</span><br><span class="line">            ans.add(matrix[i][endY]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从右往左打印一行，前提条件是起始行号小于终止行号并且还要终止列号小于起始列号</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; endX &amp;&amp; start &lt; endY) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = endY - <span class="number">1</span>; i &gt;= start; i--) &#123;</span><br><span class="line">            ans.add(matrix[endX][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从下到上打印一列，前提条件是起始行号小于终止行号-1并且还要终止列号小于起始列号</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; endX - <span class="number">1</span> &amp;&amp; start &lt; endY) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = endX - <span class="number">1</span>; i &gt;= start + <span class="number">1</span>; i--) &#123;</span><br><span class="line">            ans.add(matrix[i][start]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结：</p><p>这种题目虽然没有涉及到任何的算法和数据结构相关的东西，但是想要完成的很完整也是一件不是简单的事情，刚开始做会做的很乱，没有归纳中一般的规律，导致越做越乱，最终失败，所以这类题目，做之前，一定要手动画一画，没有总结书规律之前，不要动手写。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;顺时针打印矩阵&quot;&gt;&lt;a href=&quot;#顺时针打印矩阵&quot; class=&quot;headerlink&quot; title=&quot;顺时针打印矩阵&quot;&gt;&lt;/a&gt;顺时针打印矩阵&lt;/h4&gt;&lt;h5 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h5&gt;&lt;p&gt;输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵：&lt;code&gt;1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>数据流中的中位数</title>
    <link href="https://cblog.club/ck535j1zc009pmsg4e6p8amvq.html"/>
    <id>https://cblog.club/ck535j1zc009pmsg4e6p8amvq.html</id>
    <published>2020-01-06T13:58:33.998Z</published>
    <updated>2020-01-04T07:59:47.712Z</updated>
    
    <content type="html"><![CDATA[<h4 id="数据流中的中位数"><a href="#数据流中的中位数" class="headerlink" title="数据流中的中位数"></a>数据流中的中位数</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用<code>Insert()</code>方法读取数据流，使用<code>GetMedian()</code>方法获取当前读取数据的中位数。</p><a id="more"></a><h5 id="法一：这一题主要分析的就是我们采用什么容器来放这些数据呢？考虑到插入和取中位数的时间复杂度，这两者都尽量最低，仔细分析一下，貌似只有平衡二叉排序树-AVL-和堆能实现我们的要求，如果使用AVL，那么插入的时间复杂度为O-logn-，取数的时间复杂度为O-1-，因为如果是奇数，根节点就是中位数，反之，记录一下左子树结点个数和右子树节点个数，找到另一个中间的数字即可。我们这里讨论如何使用堆来解决这一题。"><a href="#法一：这一题主要分析的就是我们采用什么容器来放这些数据呢？考虑到插入和取中位数的时间复杂度，这两者都尽量最低，仔细分析一下，貌似只有平衡二叉排序树-AVL-和堆能实现我们的要求，如果使用AVL，那么插入的时间复杂度为O-logn-，取数的时间复杂度为O-1-，因为如果是奇数，根节点就是中位数，反之，记录一下左子树结点个数和右子树节点个数，找到另一个中间的数字即可。我们这里讨论如何使用堆来解决这一题。" class="headerlink" title="法一：这一题主要分析的就是我们采用什么容器来放这些数据呢？考虑到插入和取中位数的时间复杂度，这两者都尽量最低，仔细分析一下，貌似只有平衡二叉排序树(AVL)和堆能实现我们的要求，如果使用AVL，那么插入的时间复杂度为O(logn)，取数的时间复杂度为O(1)，因为如果是奇数，根节点就是中位数，反之，记录一下左子树结点个数和右子树节点个数，找到另一个中间的数字即可。我们这里讨论如何使用堆来解决这一题。"></a>法一：这一题主要分析的就是我们采用什么容器来放这些数据呢？考虑到插入和取中位数的时间复杂度，这两者都尽量最低，仔细分析一下，貌似只有平衡二叉排序树(AVL)和堆能实现我们的要求，如果使用AVL，那么插入的时间复杂度为O(logn)，取数的时间复杂度为O(1)，因为如果是奇数，根节点就是中位数，反之，记录一下左子树结点个数和右子树节点个数，找到另一个中间的数字即可。我们这里讨论如何使用堆来解决这一题。</h5><p>首先，我们要找中位数，中位数将整个序列分为两个部分，那么设置两个堆，一个小根堆，一个大根堆，左边是大根堆，右边是小根堆，并且左边的最大元素也要比右边的最小元素小，但是各自内部，允许是无序的，所以我们插入的过程中，需要设置一个标志，表示往哪个堆里插入，并且为了满足<strong>左边的最大元素也要比右边的最小元素小</strong>这一条件，我们总是先插入到堆里，再将堆顶插入到另一个堆中，详细见代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Queue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> Queue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer a, Integer b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b - a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (count % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//先插入到大根堆，然后再将大根堆的堆顶插入到小根堆中，这样做的目的是保持大根堆的所有值都小于小根堆的所有值</span></span><br><span class="line">        maxHeap.offer(num);</span><br><span class="line">        <span class="keyword">int</span> maxVal = maxHeap.poll();</span><br><span class="line">        minHeap.offer(maxVal);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//操作与上相反</span></span><br><span class="line">        minHeap.offer(num);</span><br><span class="line">        <span class="keyword">int</span> minVal = minHeap.poll();</span><br><span class="line">        maxHeap.offer(minVal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>)minHeap.peek();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">double</span>)maxHeap.peek() + (<span class="keyword">double</span>)minHeap.peek()) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结：</p><p>这种看起来特别简单的题目，往往在时间复杂度和空间复杂度上有着很高的要求，需要我们对于其分析的能力，找到一个最优的解法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;数据流中的中位数&quot;&gt;&lt;a href=&quot;#数据流中的中位数&quot; class=&quot;headerlink&quot; title=&quot;数据流中的中位数&quot;&gt;&lt;/a&gt;数据流中的中位数&lt;/h4&gt;&lt;h5 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h5&gt;&lt;p&gt;如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用&lt;code&gt;Insert()&lt;/code&gt;方法读取数据流，使用&lt;code&gt;GetMedian()&lt;/code&gt;方法获取当前读取数据的中位数。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>删除链表中重复的结点</title>
    <link href="https://cblog.club/ck535j1po007umsg44i146r43.html"/>
    <id>https://cblog.club/ck535j1po007umsg44i146r43.html</id>
    <published>2020-01-06T13:58:33.993Z</published>
    <updated>2020-01-02T04:05:25.954Z</updated>
    
    <content type="html"><![CDATA[<h4 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表<code>1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</code> 处理后为 <code>1-&gt;2-&gt;5</code></p><a id="more"></a><h5 id="法一：又遇到重复的问题，所以可以想到使用相关容器来判断重复。我们只需要找出来不重复的结点，将他们连起来即可（也就是插入到新链表中即可）-具体细节代码中有给出。很清晰，时间复杂度和空间复杂度均为O-n-。"><a href="#法一：又遇到重复的问题，所以可以想到使用相关容器来判断重复。我们只需要找出来不重复的结点，将他们连起来即可（也就是插入到新链表中即可）-具体细节代码中有给出。很清晰，时间复杂度和空间复杂度均为O-n-。" class="headerlink" title="法一：又遇到重复的问题，所以可以想到使用相关容器来判断重复。我们只需要找出来不重复的结点，将他们连起来即可（也就是插入到新链表中即可）,具体细节代码中有给出。很清晰，时间复杂度和空间复杂度均为O(n)。"></a>法一：又遇到重复的问题，所以可以想到使用相关容器来判断重复。我们只需要找出来不重复的结点，将他们连起来即可（也就是插入到新链表中即可）,具体细节代码中有给出。很清晰，时间复杂度和空间复杂度均为O(n)。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    ListNode p = pHead;</span><br><span class="line">    <span class="comment">//记录每个结点值出现的次数，不能记录每个结点出现的次数（结点值一样，结点不一样！）</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        map.put(p.val, map.getOrDefault(p.val, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    p = pHead;</span><br><span class="line">    pHead = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//找出第一个出现次数为1的结点（也就是不重复结点）当作头结点</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.get(p.val) == <span class="number">1</span>) &#123;</span><br><span class="line">            pHead = p;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//全部都是重复的</span></span><br><span class="line">    <span class="keyword">if</span> (pHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始连接，找出之后的所有出现次数为1的结点，连接起来</span></span><br><span class="line">    ListNode pre = pHead;</span><br><span class="line">    p = pHead.next;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.get(p.val) == <span class="number">1</span>) &#123;</span><br><span class="line">            pre.next = p;</span><br><span class="line">            pre = p;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这一步很关键，因为我们采用的是尾插法，所以最后一个结点的next一定要置为null</span></span><br><span class="line">    pre.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> pHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="法二：我们借助容器来判断重复，就意味着空间上有所损耗，是否可以不用容器呢？这里，我们可以利用一个小trick（增加一个头结点），之所以增加这个头结点，主要是为了解决从一开始就有重复结点的问题。具体细节代码中有涉及。"><a href="#法二：我们借助容器来判断重复，就意味着空间上有所损耗，是否可以不用容器呢？这里，我们可以利用一个小trick（增加一个头结点），之所以增加这个头结点，主要是为了解决从一开始就有重复结点的问题。具体细节代码中有涉及。" class="headerlink" title="法二：我们借助容器来判断重复，就意味着空间上有所损耗，是否可以不用容器呢？这里，我们可以利用一个小trick（增加一个头结点），之所以增加这个头结点，主要是为了解决从一开始就有重复结点的问题。具体细节代码中有涉及。"></a>法二：我们借助容器来判断重复，就意味着空间上有所损耗，是否可以不用容器呢？这里，我们可以利用一个小trick（增加一个头结点），之所以增加这个头结点，主要是为了解决从一开始就有重复结点的问题。具体细节代码中有涉及。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个头结点</span></span><br><span class="line">    ListNode head = <span class="keyword">new</span> ListNode(Integer.MAX_VALUE);</span><br><span class="line">    head.next = pHead;</span><br><span class="line">    ListNode pre = head;</span><br><span class="line">    ListNode last = pHead;</span><br><span class="line">    <span class="keyword">while</span> (last != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果当前结点重复出现</span></span><br><span class="line">        <span class="keyword">if</span> (last.next != <span class="keyword">null</span> &amp;&amp; last.val == last.next.val) &#123;</span><br><span class="line">            <span class="comment">//找到重复结点最后一次出现的位置</span></span><br><span class="line">            <span class="keyword">while</span> (last.next != <span class="keyword">null</span> &amp;&amp; last.val == last.next.val) &#123;</span><br><span class="line">                last = last.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//跳过重复结点</span></span><br><span class="line">            pre.next = last.next;</span><br><span class="line">            last = last.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            last = last.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结：</p><p>链表的题目，一般来说细节非常重要（空指针的滥用！），然后Java有垃圾回收机制，所以不用担心内存泄漏问题，建议做之前，一定要动手模拟一遍。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;替换空格&quot;&gt;&lt;a href=&quot;#替换空格&quot; class=&quot;headerlink&quot; title=&quot;替换空格&quot;&gt;&lt;/a&gt;替换空格&lt;/h4&gt;&lt;h5 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h5&gt;&lt;p&gt;在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表&lt;code&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5&lt;/code&gt; 处理后为 &lt;code&gt;1-&amp;gt;2-&amp;gt;5&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>扑克牌顺子</title>
    <link href="https://cblog.club/ck535j1vo0095msg46e098poi.html"/>
    <id>https://cblog.club/ck535j1vo0095msg46e098poi.html</id>
    <published>2020-01-06T13:58:33.990Z</published>
    <updated>2020-01-06T06:11:15.369Z</updated>
    
    <content type="html"><![CDATA[<h4 id="扑克牌顺子"><a href="#扑克牌顺子" class="headerlink" title="扑克牌顺子"></a>扑克牌顺子</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大小王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。</p><a id="more"></a><h5 id="法一：我们先统计0的个数，也就是大小王的个数，然后在统计此外的数之间的距离大小（这需要先排序），如果0的个数≥距离（也就是说除了大小王之外的数字之间的间隔可以通过大小王弥补掉），就返回true，这个方法适用于N张牌，并不一定只是抽五张牌，当然题目中规定是五张牌。"><a href="#法一：我们先统计0的个数，也就是大小王的个数，然后在统计此外的数之间的距离大小（这需要先排序），如果0的个数≥距离（也就是说除了大小王之外的数字之间的间隔可以通过大小王弥补掉），就返回true，这个方法适用于N张牌，并不一定只是抽五张牌，当然题目中规定是五张牌。" class="headerlink" title="法一：我们先统计0的个数，也就是大小王的个数，然后在统计此外的数之间的距离大小（这需要先排序），如果0的个数≥距离（也就是说除了大小王之外的数字之间的间隔可以通过大小王弥补掉），就返回true，这个方法适用于N张牌，并不一定只是抽五张牌，当然题目中规定是五张牌。"></a>法一：我们先统计0的个数，也就是大小王的个数，然后在统计此外的数之间的距离大小（这需要先排序），如果0的个数≥距离（也就是说除了大小王之外的数字之间的间隔可以通过大小王弥补掉），就返回true，这个方法适用于N张牌，并不一定只是抽五张牌，当然题目中规定是五张牌。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numbers == <span class="keyword">null</span> || numbers.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(numbers);</span><br><span class="line">    <span class="keyword">int</span> kingCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            index = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        kingCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> distence = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index + <span class="number">1</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] == numbers[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        distence += (numbers[i] - numbers[i - <span class="number">1</span>] - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> distence &lt;= kingCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="法二：我们发现，这一题必须满足如下条件："><a href="#法二：我们发现，这一题必须满足如下条件：" class="headerlink" title="法二：我们发现，这一题必须满足如下条件："></a>法二：我们发现，这一题必须满足如下条件：</h5><ul><li>不能有重复数字，这个可以用bool数组来解决（重复问题，方法有很多，相关容器也可以）</li><li>除了0之外，最大值 - 最小值 不能超过4（这一点其实归纳出来还真的不太好想）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numbers == <span class="keyword">null</span> || numbers.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//为了判断重复，之所以是14，是因为扑克牌牌面有1-13，0代表大小王</span></span><br><span class="line">    <span class="keyword">boolean</span>[] card = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">14</span>];</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (card[numbers[i]]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        card[numbers[i]] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (max &lt; numbers[i]) &#123;</span><br><span class="line">            max = numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min &gt; numbers[i]) &#123;</span><br><span class="line">            min = numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max - min &lt; <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结：</p><p>题目不涉及任何数据结构和算法，但是需要一定的总结概括能力，手动模拟能力。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;扑克牌顺子&quot;&gt;&lt;a href=&quot;#扑克牌顺子&quot; class=&quot;headerlink&quot; title=&quot;扑克牌顺子&quot;&gt;&lt;/a&gt;扑克牌顺子&lt;/h4&gt;&lt;h5 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h5&gt;&lt;p&gt;LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大小王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>链表中环的入口结点</title>
    <link href="https://cblog.club/ck535j26s00bcmsg401ezhps7.html"/>
    <id>https://cblog.club/ck535j26s00bcmsg401ezhps7.html</id>
    <published>2020-01-06T13:58:33.987Z</published>
    <updated>2020-01-02T01:28:01.817Z</updated>
    
    <content type="html"><![CDATA[<h4 id="链表中环的入口结点"><a href="#链表中环的入口结点" class="headerlink" title="链表中环的入口结点"></a>链表中环的入口结点</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p><a id="more"></a><h5 id="法一：首先判断一个链表中是否存在环，我们很容易就想到快慢指针向后推进，如果最后两个相等，那么肯定存在环。如果有了环，如何找出环的入口结点呢？我们通过手动模拟，会发现这样一个定律：我们从第一次相遇的结点开始，令一个指针返回到头结点，二者同步走（注意，此时速度是一样的），如果再次相遇，那么此节点必为环的入口结点。"><a href="#法一：首先判断一个链表中是否存在环，我们很容易就想到快慢指针向后推进，如果最后两个相等，那么肯定存在环。如果有了环，如何找出环的入口结点呢？我们通过手动模拟，会发现这样一个定律：我们从第一次相遇的结点开始，令一个指针返回到头结点，二者同步走（注意，此时速度是一样的），如果再次相遇，那么此节点必为环的入口结点。" class="headerlink" title="法一：首先判断一个链表中是否存在环，我们很容易就想到快慢指针向后推进，如果最后两个相等，那么肯定存在环。如果有了环，如何找出环的入口结点呢？我们通过手动模拟，会发现这样一个定律：我们从第一次相遇的结点开始，令一个指针返回到头结点，二者同步走（注意，此时速度是一样的），如果再次相遇，那么此节点必为环的入口结点。"></a>法一：首先判断一个链表中是否存在环，我们很容易就想到快慢指针向后推进，如果最后两个相等，那么肯定存在环。如果有了环，如何找出环的入口结点呢？我们通过手动模拟，会发现这样一个定律：我们从第一次相遇的结点开始，令一个指针返回到头结点，二者同步走（注意，此时速度是一样的），如果再次相遇，那么此节点必为环的入口结点。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode fast = pHead, slow = pHead;</span><br><span class="line">    <span class="keyword">boolean</span> hasCircle= <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">            hasCircle = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasCircle == <span class="keyword">false</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fast = pHead;</span><br><span class="line">    <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="法二：其实我们再想一下，环的入口结点不就是相当于第一个重复的结点嘛（我们第二次进入到这个结点），那么我们之前做过怎么找出第一个重复的数字，这一题只不过类型改成了结点类型而已，大致思路一样，利用一个容器进行判断即可（这里我使用hashset）。"><a href="#法二：其实我们再想一下，环的入口结点不就是相当于第一个重复的结点嘛（我们第二次进入到这个结点），那么我们之前做过怎么找出第一个重复的数字，这一题只不过类型改成了结点类型而已，大致思路一样，利用一个容器进行判断即可（这里我使用hashset）。" class="headerlink" title="法二：其实我们再想一下，环的入口结点不就是相当于第一个重复的结点嘛（我们第二次进入到这个结点），那么我们之前做过怎么找出第一个重复的数字，这一题只不过类型改成了结点类型而已，大致思路一样，利用一个容器进行判断即可（这里我使用hashset）。"></a>法二：其实我们再想一下，环的入口结点不就是相当于第一个重复的结点嘛（我们第二次进入到这个结点），那么我们之前做过怎么找出第一个重复的数字，这一题只不过类型改成了结点类型而已，大致思路一样，利用一个容器进行判断即可（这里我使用hashset）。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;ListNode&gt; node = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (pHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.contains(pHead)) &#123;</span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        &#125;</span><br><span class="line">        node.add(pHead);</span><br><span class="line">        pHead = pHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结：</p><p>重复类的问题，一般的容器都可以解决。</p><p>双指针是一个很好的技巧，要总结一些双指针的用法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;链表中环的入口结点&quot;&gt;&lt;a href=&quot;#链表中环的入口结点&quot; class=&quot;headerlink&quot; title=&quot;链表中环的入口结点&quot;&gt;&lt;/a&gt;链表中环的入口结点&lt;/h4&gt;&lt;h5 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h5&gt;&lt;p&gt;给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>矩阵中的路径</title>
    <link href="https://cblog.club/ck535j22y00avmsg49yh7ek1h.html"/>
    <id>https://cblog.club/ck535j22y00avmsg49yh7ek1h.html</id>
    <published>2020-01-06T13:58:33.983Z</published>
    <updated>2020-01-02T13:05:56.639Z</updated>
    
    <content type="html"><![CDATA[<h4 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p><a id="more"></a><h5 id="法一：之前做了蛮多的这种搜索的题目，所以形成了思维定式，初次见到一维数组的搜索，我就想着把他给二维化，再进行搜索。此题满足回溯的使用条件（简单来说，回溯就是三步骤：做出选择，递归，撤销选择），其实回溯和DFS感觉区别不太大，可能回溯多了一步（”在回之前，修改了一次”）。具体思路代码中体现："><a href="#法一：之前做了蛮多的这种搜索的题目，所以形成了思维定式，初次见到一维数组的搜索，我就想着把他给二维化，再进行搜索。此题满足回溯的使用条件（简单来说，回溯就是三步骤：做出选择，递归，撤销选择），其实回溯和DFS感觉区别不太大，可能回溯多了一步（”在回之前，修改了一次”）。具体思路代码中体现：" class="headerlink" title="法一：之前做了蛮多的这种搜索的题目，所以形成了思维定式，初次见到一维数组的搜索，我就想着把他给二维化，再进行搜索。此题满足回溯的使用条件（简单来说，回溯就是三步骤：做出选择，递归，撤销选择），其实回溯和DFS感觉区别不太大，可能回溯多了一步（”在回之前，修改了一次”）。具体思路代码中体现："></a>法一：之前做了蛮多的这种搜索的题目，所以形成了思维定式，初次见到一维数组的搜索，我就想着把他给二维化，再进行搜索。此题满足回溯的使用条件（简单来说，回溯就是三步骤：做出选择，递归，撤销选择），其实回溯和DFS感觉区别不太大，可能回溯多了一步（”在回之前，修改了一次”）。具体思路代码中体现：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">char</span>[][] newMatrix;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[][] visited;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> ans = <span class="keyword">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || rows &lt; <span class="number">1</span> || cols &lt; <span class="number">1</span> || str == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (str.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    newMatrix = <span class="keyword">new</span> <span class="keyword">char</span>[rows][cols];</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; startPos = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            <span class="comment">//二维化</span></span><br><span class="line">            newMatrix[i][j] = matrix[k++];</span><br><span class="line">            <span class="keyword">if</span> (newMatrix[i][j] == str[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="comment">//记录下起点的所有可能位置</span></span><br><span class="line">                startPos.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] cur : startPos) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = cur[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> y = cur[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//做出选择</span></span><br><span class="line">        visited[x][y] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        backTracing(x, y, str, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//一旦包含字符串，就返回true，不然可能会被以后的false覆盖掉</span></span><br><span class="line">        <span class="keyword">if</span> (ans) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//撤销选择</span></span><br><span class="line">        visited[x][y] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backTracing</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">char</span>[] str, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//所有字符串都满足要求</span></span><br><span class="line">    <span class="keyword">if</span> (pos == str.length - <span class="number">1</span>) &#123;</span><br><span class="line">        ans = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义四个方向</span></span><br><span class="line">    <span class="keyword">int</span>[][] direct = &#123;&#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">4</span>; d++) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextX = x + direct[<span class="number">0</span>][d];</span><br><span class="line">        <span class="keyword">int</span> nextY = y + direct[<span class="number">1</span>][d];</span><br><span class="line">        <span class="comment">//条件众多：不能越界，下一个字符必须是所需字符串中的字符，下一个位置不能被访问过</span></span><br><span class="line">        <span class="keyword">if</span> (nextX &gt;= <span class="number">0</span> &amp;&amp; nextX &lt; newMatrix.length &amp;&amp; nextY &gt;=<span class="number">0</span> &amp;&amp; nextY &lt; newMatrix[<span class="number">0</span>].length &amp;&amp; !visited[nextX][nextY] &amp;&amp; pos + <span class="number">1</span> &lt; str.length  &amp;&amp; newMatrix[nextX][nextY] == str[pos + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="comment">//做出选择</span></span><br><span class="line">            visited[nextX][nextY] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//递归</span></span><br><span class="line">            backTracing(nextX, nextY, str, pos + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//撤销选择</span></span><br><span class="line">            visited[nextX][nextY] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="法二：刚开始就很奇怪，题目说是矩阵，但是给了一个一维数组，所以一维还是可以看成二维的嘛！最终位置-i-cols-j-其中i为行数，j为列数-。这样就能节省空间（之前的二维数组空间开销有点大），并且我们也没必要声明一个ans作为判断的依据，直接将递归的函数设置成boolean类型即可。另外，不要在递归函数里声明，尽量放在外边，减小开销。"><a href="#法二：刚开始就很奇怪，题目说是矩阵，但是给了一个一维数组，所以一维还是可以看成二维的嘛！最终位置-i-cols-j-其中i为行数，j为列数-。这样就能节省空间（之前的二维数组空间开销有点大），并且我们也没必要声明一个ans作为判断的依据，直接将递归的函数设置成boolean类型即可。另外，不要在递归函数里声明，尽量放在外边，减小开销。" class="headerlink" title="法二：刚开始就很奇怪，题目说是矩阵，但是给了一个一维数组，所以一维还是可以看成二维的嘛！最终位置=i*cols +j(其中i为行数，j为列数)。这样就能节省空间（之前的二维数组空间开销有点大），并且我们也没必要声明一个ans作为判断的依据，直接将递归的函数设置成boolean类型即可。另外，不要在递归函数里声明，尽量放在外边，减小开销。"></a>法二：刚开始就很奇怪，题目说是矩阵，但是给了一个一维数组，所以一维还是可以看成二维的嘛！最终位置=<code>i*cols +j</code>(其中i为行数，j为列数)。这样就能节省空间（之前的二维数组空间开销有点大），并且我们也没必要声明一个ans作为判断的依据，直接将递归的函数设置成boolean类型即可。另外，不要在递归函数里声明，尽量放在外边，减小开销。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] visited;</span><br><span class="line"><span class="keyword">int</span>[][] direct = &#123;&#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> nextX, nextY;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || rows &lt; <span class="number">1</span> || cols &lt; <span class="number">1</span> || str == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (str.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows * cols];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i * cols + j] == str[<span class="number">0</span>] &amp;&amp; backTracing(matrix, i, j, str, <span class="number">0</span>, rows, cols)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backTracing</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">char</span>[] str, <span class="keyword">int</span> pos, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//所有字符串都满足要求</span></span><br><span class="line">    <span class="keyword">if</span> (pos == str.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//做出选择</span></span><br><span class="line">    visited[x * cols + y] =<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">4</span>; d++) &#123;</span><br><span class="line">        nextX = x + direct[<span class="number">0</span>][d];</span><br><span class="line">        nextY = y + direct[<span class="number">1</span>][d];</span><br><span class="line">        <span class="comment">//条件众多：不能越界，下一个字符必须是所需字符串中的字符，下一个位置不能被访问过</span></span><br><span class="line">        <span class="keyword">if</span> (nextX &gt;=<span class="number">0</span> &amp;&amp; nextX &lt; rows &amp;&amp; nextY &gt;= <span class="number">0</span> &amp;&amp; nextY &lt; cols  &amp;&amp; !visited[nextX * cols + nextY] &amp;&amp; pos + <span class="number">1</span> &lt; str.length  &amp;&amp; matrix[nextX * cols + nextY] == str[pos + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="comment">//递归</span></span><br><span class="line">            <span class="keyword">if</span> (backTracing(matrix, nextX, nextY, str, pos + <span class="number">1</span>, rows, cols)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//撤销选择</span></span><br><span class="line">    visited[x * cols + y] =<span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样代码较之于第一个版本就优雅了许多，所以代码的整洁度，优雅性也是很重要的。</p><p>小结：</p><p>一些声明，放在递归函数外部。</p><p>回溯其实和DFS真的几乎一致，就是在于递归”回去”的时候要修改。但是本题使用BFS不行！= =（调了蛮长时间，发现根本就不行！因为他访问过的字符，以后可能会用到）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;矩阵中的路径&quot;&gt;&lt;a href=&quot;#矩阵中的路径&quot; class=&quot;headerlink&quot; title=&quot;矩阵中的路径&quot;&gt;&lt;/a&gt;矩阵中的路径&lt;/h4&gt;&lt;h5 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h5&gt;&lt;p&gt;请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>矩形覆盖</title>
    <link href="https://cblog.club/ck535j22f00asmsg4965d11kr.html"/>
    <id>https://cblog.club/ck535j22f00asmsg4965d11kr.html</id>
    <published>2020-01-06T13:58:33.980Z</published>
    <updated>2020-01-06T13:46:09.999Z</updated>
    
    <content type="html"><![CDATA[<h4 id="矩形覆盖"><a href="#矩形覆盖" class="headerlink" title="矩形覆盖"></a>矩形覆盖</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2<em>1的小矩形无重叠地覆盖一个2\</em>n的大矩形，总共有多少种方法？</p><a id="more"></a><h5 id="法一：这种题目肯定是需要手动模拟，然后找出一定的规律，进而使用递归和动态规划。这一题说实话，能归纳出正确的规律并不是一件特别简单的事情，通过一些帮助，发现，他最终又回到了斐波那契数列上了-！（f-n-f-n-1-f-n-2-，n-gt-2）"><a href="#法一：这种题目肯定是需要手动模拟，然后找出一定的规律，进而使用递归和动态规划。这一题说实话，能归纳出正确的规律并不是一件特别简单的事情，通过一些帮助，发现，他最终又回到了斐波那契数列上了-！（f-n-f-n-1-f-n-2-，n-gt-2）" class="headerlink" title="法一：这种题目肯定是需要手动模拟，然后找出一定的规律，进而使用递归和动态规划。这一题说实话，能归纳出正确的规律并不是一件特别简单的事情，通过一些帮助，发现，他最终又回到了斐波那契数列上了~！（f(n)=f(n-1)+f(n-2)，n&gt;2）"></a>法一：这种题目肯定是需要手动模拟，然后找出一定的规律，进而使用递归和动态规划。这一题说实话，能归纳出正确的规律并不是一件特别简单的事情，通过一些帮助，发现，他最终又回到了斐波那契数列上了~！（f(n)=f(n-1)+f(n-2)，n&gt;2）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">1</span> || target == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> RectCover(target - <span class="number">1</span>) + RectCover(target - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="法二：直接动态规划优化"><a href="#法二：直接动态规划优化" class="headerlink" title="法二：直接动态规划优化"></a>法二：直接动态规划优化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">1</span> || target == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> dp1 = <span class="number">1</span>, dp2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> dp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= target; i++) &#123;</span><br><span class="line">        dp = dp1 + dp2;</span><br><span class="line">        dp1 = dp2;</span><br><span class="line">        dp2 = dp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;矩形覆盖&quot;&gt;&lt;a href=&quot;#矩形覆盖&quot; class=&quot;headerlink&quot; title=&quot;矩形覆盖&quot;&gt;&lt;/a&gt;矩形覆盖&lt;/h4&gt;&lt;h5 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h5&gt;&lt;p&gt;我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2&lt;em&gt;1的小矩形无重叠地覆盖一个2\&lt;/em&gt;n的大矩形，总共有多少种方法？&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>剪绳子</title>
    <link href="https://cblog.club/ck535j1q2007ymsg444lbh0bo.html"/>
    <id>https://cblog.club/ck535j1q2007ymsg444lbh0bo.html</id>
    <published>2020-01-06T13:58:33.977Z</published>
    <updated>2020-01-04T06:57:55.826Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剪绳子"><a href="#剪绳子" class="headerlink" title="剪绳子"></a>剪绳子</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为<code>k[0],k[1],...,k[m]</code>。请问<code>k[0]xk[1]x...xk[m]</code>可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><a id="more"></a><h5 id="法一：动态规划解法，像求最值问题，一般都可以用DP来解决。这题我们把4当作一个临界点，之所以取4是因为，1-2-3这三个点的最终结果很直观就能得到-而且这三个值与dp的值还不同，因为默认至少要剪两刀-并且使用dp最关键的就是在于重复问题的剪枝，自底向上，去除了重复的计算，具体思想可以看看动态规划思想："><a href="#法一：动态规划解法，像求最值问题，一般都可以用DP来解决。这题我们把4当作一个临界点，之所以取4是因为，1-2-3这三个点的最终结果很直观就能得到-而且这三个值与dp的值还不同，因为默认至少要剪两刀-并且使用dp最关键的就是在于重复问题的剪枝，自底向上，去除了重复的计算，具体思想可以看看动态规划思想：" class="headerlink" title="法一：动态规划解法，像求最值问题，一般都可以用DP来解决。这题我们把4当作一个临界点，之所以取4是因为，1 2 3这三个点的最终结果很直观就能得到(而且这三个值与dp的值还不同，因为默认至少要剪两刀),并且使用dp最关键的就是在于重复问题的剪枝，自底向上，去除了重复的计算，具体思想可以看看动态规划思想："></a>法一：动态规划解法，像求最值问题，一般都可以用DP来解决。这题我们把4当作一个临界点，之所以取4是因为，1 2 3这三个点的最终结果很直观就能得到(而且这三个值与dp的值还不同，因为默认至少要剪两刀),并且使用dp最关键的就是在于重复问题的剪枝，自底向上，去除了重复的计算，具体思想可以看看动态规划思想：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cutRope</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    dp[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= target; i++) &#123;</span><br><span class="line">        <span class="comment">//i / 2 是因为此后的乘法相当于倒过来再乘一次，没必要计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i / <span class="number">2</span>; j++)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i], dp[j] * dp[i - j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="法二：贪心算法，思想就是每一步都取当前能取到的局部最优值，最后合并成一个全局最优值，使用贪心的前提是，你要证明贪心的正确性。"><a href="#法二：贪心算法，思想就是每一步都取当前能取到的局部最优值，最后合并成一个全局最优值，使用贪心的前提是，你要证明贪心的正确性。" class="headerlink" title="法二：贪心算法，思想就是每一步都取当前能取到的局部最优值，最后合并成一个全局最优值，使用贪心的前提是，你要证明贪心的正确性。"></a>法二：贪心算法，思想就是每一步都取当前能取到的局部最优值，最后合并成一个全局最优值，使用贪心的前提是，你要证明贪心的正确性。</h5><p>当 n≥5 时，我们尽可能多的剪长度为3的绳子；当剩下的绳子长度为4时，把绳子剪成两段长度为2的绳子。 为什么选2，3为最小的子问题？因为2，3包含于各个问题中，如果再往下剪得话，乘积就会变小。 为什么选长度为3？因为当n≥5时，3(n−3)≥2(n−2)，并且3(n−3)≥n，2(n−2)≥n。</p><p>简单来说就是，尽量都分割成长度为3的绳子，如果剩下的绳子长度为4，就不能再这样分了，就要分成两个2，因为2x2&gt;1x3。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cutRope</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count3 = target / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (target % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        count3 -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count2 = (target - count3 * <span class="number">3</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>, count3) * (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, count2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结：</p><p>碰到最值问题，一般来说，动态规划和贪心算法，可以使用，但是使用贪心算法之前，一定要能证明他的正确性。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;剪绳子&quot;&gt;&lt;a href=&quot;#剪绳子&quot; class=&quot;headerlink&quot; title=&quot;剪绳子&quot;&gt;&lt;/a&gt;剪绳子&lt;/h4&gt;&lt;h5 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h5&gt;&lt;p&gt;给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&amp;gt;1并且m&amp;gt;1），每段绳子的长度记为&lt;code&gt;k[0],k[1],...,k[m]&lt;/code&gt;。请问&lt;code&gt;k[0]xk[1]x...xk[m]&lt;/code&gt;可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>机器人的运动范围</title>
    <link href="https://cblog.club/ck535j1zs009tmsg4gda5ea8c.html"/>
    <id>https://cblog.club/ck535j1zs009tmsg4gda5ea8c.html</id>
    <published>2020-01-06T13:58:33.974Z</published>
    <updated>2020-01-02T14:07:56.814Z</updated>
    
    <content type="html"><![CDATA[<h4 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p><a id="more"></a><h5 id="法一：DFS，这一题归类为回溯，不如归类为搜索！具体细节代码中体现："><a href="#法一：DFS，这一题归类为回溯，不如归类为搜索！具体细节代码中体现：" class="headerlink" title="法一：DFS，这一题归类为回溯，不如归类为搜索！具体细节代码中体现："></a>法一：DFS，这一题归类为回溯，不如归类为搜索！具体细节代码中体现：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] direct = &#123;&#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> nextI, nextJ;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] visited;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (threshold &lt; <span class="number">0</span> || rows &lt; <span class="number">1</span> || cols &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows * cols];</span><br><span class="line">    <span class="keyword">return</span> stepCount(threshold, <span class="number">0</span>, <span class="number">0</span>, rows, cols);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">stepCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> i, <span class="keyword">int</span> j,<span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    visited[i * cols + j] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//四个方向</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">4</span>; d++) &#123;</span><br><span class="line">        nextI = i + direct[<span class="number">0</span>][d];</span><br><span class="line">        nextJ = j + direct[<span class="number">1</span>][d];</span><br><span class="line">        <span class="comment">//判断是否符合条件</span></span><br><span class="line">        <span class="keyword">if</span> (nextI &gt;= <span class="number">0</span> &amp;&amp; nextI &lt; rows &amp;&amp; nextJ &gt;= <span class="number">0</span> &amp;&amp; nextJ &lt; cols &amp;&amp; !visited[nextI * cols + nextJ] &amp;&amp; digitSum(nextI, nextJ) &lt;= threshold) &#123;</span><br><span class="line">            count += stepCount(threshold, nextI, nextJ, rows, cols);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求行和列的和</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">digitSum</span><span class="params">(<span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (rows &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sum += rows % <span class="number">10</span>;</span><br><span class="line">        rows /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (cols &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sum += cols % <span class="number">10</span>;</span><br><span class="line">        cols /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="法二：既然能用DFS，那么BFS通常也可以。"><a href="#法二：既然能用DFS，那么BFS通常也可以。" class="headerlink" title="法二：既然能用DFS，那么BFS通常也可以。"></a>法二：既然能用DFS，那么BFS通常也可以。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (threshold &lt; <span class="number">0</span> || rows &lt; <span class="number">1</span> || cols &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[][] direct = &#123;&#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> nextI, nextJ;</span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows * cols];</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    visited[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] pos = queue.poll();</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">4</span>; d++) &#123;</span><br><span class="line">            nextI = pos[<span class="number">0</span>] + direct[<span class="number">0</span>][d];</span><br><span class="line">            nextJ = pos[<span class="number">1</span>] + direct[<span class="number">1</span>][d];</span><br><span class="line">            <span class="keyword">if</span> (nextI &gt;= <span class="number">0</span> &amp;&amp; nextI &lt; rows &amp;&amp; nextJ &gt;= <span class="number">0</span> &amp;&amp; nextJ &lt; cols &amp;&amp; !visited[nextI * cols + nextJ] &amp;&amp; digitSum(nextI) + digitSum(nextJ) &lt;= threshold) &#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nextI, nextJ&#125;);</span><br><span class="line">                visited[nextI * cols + nextJ] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">digitSum</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sum += pos % <span class="number">10</span>;</span><br><span class="line">        pos /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结：</p><p>搜索通常DFS和BFS都可以使用，建议使用BFS，这样出现错误比较容易找出来，对于递归，检查错误是一个不容易的事情，很容易就先陷入到无穷无尽的坑里- -！</p><p>对于DFS和BFS尽量整理出自己的模板。对于走过的是用数组标记还是在原来的给出的矩阵里修改值（这样可以节省一些空间）取决于题目具体要求。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;矩阵中的路径&quot;&gt;&lt;a href=&quot;#矩阵中的路径&quot; class=&quot;headerlink&quot; title=&quot;矩阵中的路径&quot;&gt;&lt;/a&gt;矩阵中的路径&lt;/h4&gt;&lt;h5 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h5&gt;&lt;p&gt;地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>滑动窗口最大值</title>
    <link href="https://cblog.club/ck535j21800agmsg47of0fz1s.html"/>
    <id>https://cblog.club/ck535j21800agmsg47of0fz1s.html</id>
    <published>2020-01-06T13:58:33.970Z</published>
    <updated>2020-01-01T12:30:31.079Z</updated>
    
    <content type="html"><![CDATA[<h4 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p><code>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</code></p><a id="more"></a><h5 id="法一：暴力破解不说了，很简单，时间复杂度为O-n-size-，我们思考一下，其实这个滑动窗口就很像一个队列，尾进头出，而我们的工作是每次都要在这个队列中找一个最大值，所以我刚开始将想到了一个数据结构，优先队列PriorityQueue，这样的话，我们按照降序，队头始终就是最大值。时间复杂度为O-k-logn-，因为优先队列底层使用堆来进行排序的，我们插入和删除的时间复杂度就是O-logn-。"><a href="#法一：暴力破解不说了，很简单，时间复杂度为O-n-size-，我们思考一下，其实这个滑动窗口就很像一个队列，尾进头出，而我们的工作是每次都要在这个队列中找一个最大值，所以我刚开始将想到了一个数据结构，优先队列PriorityQueue，这样的话，我们按照降序，队头始终就是最大值。时间复杂度为O-k-logn-，因为优先队列底层使用堆来进行排序的，我们插入和删除的时间复杂度就是O-logn-。" class="headerlink" title="法一：暴力破解不说了，很简单，时间复杂度为O(n*size)，我们思考一下，其实这个滑动窗口就很像一个队列，尾进头出，而我们的工作是每次都要在这个队列中找一个最大值，所以我刚开始将想到了一个数据结构，优先队列PriorityQueue，这样的话，我们按照降序，队头始终就是最大值。时间复杂度为O(k*logn)，因为优先队列底层使用堆来进行排序的，我们插入和删除的时间复杂度就是O(logn)。"></a>法一：暴力破解不说了，很简单，时间复杂度为O(n*size)，我们思考一下，其实这个滑动窗口就很像一个队列，尾进头出，而我们的工作是每次都要在这个队列中找一个最大值，所以我刚开始将想到了一个数据结构，优先队列<code>PriorityQueue</code>，这样的话，我们按照降序，队头始终就是最大值。时间复杂度为O(k*logn)，因为优先队列底层使用堆来进行排序的，我们插入和删除的时间复杂度就是O(logn)。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="keyword">null</span> || num.length == <span class="number">0</span> || num.length &lt; size || size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Integer&gt; slideWindow = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer a, Integer b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> b - a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; size - <span class="number">1</span>) &#123;</span><br><span class="line">            slideWindow.add(num[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            slideWindow.add(num[i]);</span><br><span class="line">            <span class="keyword">int</span> curMax = slideWindow.peek();</span><br><span class="line">            slideWindow.remove(num[i - size + <span class="number">1</span>]);</span><br><span class="line">            ans.add(curMax);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="法二：既然优先队列的复杂度有点高，那么我们有O-1-复杂度的操作吗？这里，我们使用双端队列（模拟成一个单调队列），对于这个单调队列操作，时间复杂度都是O-1-级别的。"><a href="#法二：既然优先队列的复杂度有点高，那么我们有O-1-复杂度的操作吗？这里，我们使用双端队列（模拟成一个单调队列），对于这个单调队列操作，时间复杂度都是O-1-级别的。" class="headerlink" title="法二：既然优先队列的复杂度有点高，那么我们有O(1)复杂度的操作吗？这里，我们使用双端队列（模拟成一个单调队列），对于这个单调队列操作，时间复杂度都是O(1)级别的。"></a>法二：既然优先队列的复杂度有点高，那么我们有O(1)复杂度的操作吗？这里，我们使用双端队列（模拟成一个单调队列），对于这个单调队列操作，时间复杂度都是O(1)级别的。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SlideWindow</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;Integer&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dataPush</span> <span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; num) &#123;</span><br><span class="line">            deque.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        deque.addLast(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dataPop</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!deque.isEmpty() &amp;&amp; deque.element() == num) &#123;</span><br><span class="line">            deque.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxVal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deque.element();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="keyword">null</span> || num.length == <span class="number">0</span> || num.length &lt; size || size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        SlideWindow slideWindow = <span class="keyword">new</span> SlideWindow();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; size - <span class="number">1</span>) &#123;</span><br><span class="line">                slideWindow.dataPush(num[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                slideWindow.dataPush(num[i]);</span><br><span class="line">                ans.add(slideWindow.maxVal());</span><br><span class="line">                slideWindow.dataPop(num[i - size + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们这样分模块写，可读性很强，当然我们也可以将插入删除放在主函数里，但是就比较冗余，有重复部分。</p><p>小结：</p><p>本题考察我们的就是如果在O(1)级别时间内找出最大值，所以就会使用到单调队列（之前还有单调栈）这种结构。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;滑动窗口最大值&quot;&gt;&lt;a href=&quot;#滑动窗口最大值&quot; class=&quot;headerlink&quot; title=&quot;滑动窗口最大值&quot;&gt;&lt;/a&gt;滑动窗口最大值&lt;/h4&gt;&lt;h5 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h5&gt;&lt;p&gt;&lt;code&gt;给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>斐波那契数列</title>
    <link href="https://cblog.club/ck535j1yg009hmsg4e8lm9t8f.html"/>
    <id>https://cblog.club/ck535j1yg009hmsg4e8lm9t8f.html</id>
    <published>2020-01-06T13:58:33.961Z</published>
    <updated>2020-01-06T13:03:09.845Z</updated>
    
    <content type="html"><![CDATA[<h4 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。</p><p>n&lt;=39</p><a id="more"></a><h5 id="法一：这是最基础的入门递归的例子（已经被举的看吐了），注意第0项是0）"><a href="#法一：这是最基础的入门递归的例子（已经被举的看吐了），注意第0项是0）" class="headerlink" title="法一：这是最基础的入门递归的例子（已经被举的看吐了），注意第0项是0）"></a>法一：这是最基础的入门递归的例子（已经被举的看吐了），注意第0项是0）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Fibonacci(n - <span class="number">2</span>) + Fibonacci(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="法二：使用递归，时间开销会很大，那么既然能使用递归，我们也可以使用自底向上的动态规划。"><a href="#法二：使用递归，时间开销会很大，那么既然能使用递归，我们也可以使用自底向上的动态规划。" class="headerlink" title="法二：使用递归，时间开销会很大，那么既然能使用递归，我们也可以使用自底向上的动态规划。"></a>法二：使用递归，时间开销会很大，那么既然能使用递归，我们也可以使用自底向上的动态规划。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="法三：我们还可以对于动态规划进行一定的空间优化，其实没必要使用一维DP数组，使用三个变量即可，因为每次需要的数据都只是前两个而已，没必要存之前不需要的数据。"><a href="#法三：我们还可以对于动态规划进行一定的空间优化，其实没必要使用一维DP数组，使用三个变量即可，因为每次需要的数据都只是前两个而已，没必要存之前不需要的数据。" class="headerlink" title="法三：我们还可以对于动态规划进行一定的空间优化，其实没必要使用一维DP数组，使用三个变量即可，因为每次需要的数据都只是前两个而已，没必要存之前不需要的数据。"></a>法三：我们还可以对于动态规划进行一定的空间优化，其实没必要使用一维DP数组，使用三个变量即可，因为每次需要的数据都只是前两个而已，没必要存之前不需要的数据。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">int</span> dp1 = <span class="number">1</span>, dp2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> dp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp = dp1 + dp2;</span><br><span class="line">        dp2 = dp1;</span><br><span class="line">        dp1 = dp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;斐波那契数列&quot;&gt;&lt;a href=&quot;#斐波那契数列&quot; class=&quot;headerlink&quot; title=&quot;斐波那契数列&quot;&gt;&lt;/a&gt;斐波那契数列&lt;/h4&gt;&lt;h5 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h5&gt;&lt;p&gt;大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。&lt;/p&gt;
&lt;p&gt;n&amp;lt;=39&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>二叉搜索树的后序遍历序列</title>
    <link href="https://cblog.club/ck535j1kv006rmsg4dias7rok.html"/>
    <id>https://cblog.club/ck535j1kv006rmsg4dias7rok.html</id>
    <published>2020-01-06T13:58:33.951Z</published>
    <updated>2020-01-06T02:06:18.971Z</updated>
    
    <content type="html"><![CDATA[<h4 id="二叉树搜索树的后序遍历序列"><a href="#二叉树搜索树的后序遍历序列" class="headerlink" title="二叉树搜索树的后序遍历序列"></a>二叉树搜索树的后序遍历序列</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p><a id="more"></a><h5 id="法一：刚开始拿到这一题，并没有归纳出一般的规律-，剑指offer上的思路是这样的，对于二叉搜索树的后序遍历序列来讲，最后一个结点是根节点，那么根节点将二叉树分为两个部分，前半部分一定都小于根节点，后半部分一定都大于根节点，并且所有的子树都满足这样一个特点，这也就暗含了一个递归，对于每一个序列（子树的序列），都要符合这一要求。"><a href="#法一：刚开始拿到这一题，并没有归纳出一般的规律-，剑指offer上的思路是这样的，对于二叉搜索树的后序遍历序列来讲，最后一个结点是根节点，那么根节点将二叉树分为两个部分，前半部分一定都小于根节点，后半部分一定都大于根节点，并且所有的子树都满足这样一个特点，这也就暗含了一个递归，对于每一个序列（子树的序列），都要符合这一要求。" class="headerlink" title="法一：刚开始拿到这一题，并没有归纳出一般的规律= =，剑指offer上的思路是这样的，对于二叉搜索树的后序遍历序列来讲，最后一个结点是根节点，那么根节点将二叉树分为两个部分，前半部分一定都小于根节点，后半部分一定都大于根节点，并且所有的子树都满足这样一个特点，这也就暗含了一个递归，对于每一个序列（子树的序列），都要符合这一要求。"></a>法一：刚开始拿到这一题，并没有归纳出一般的规律= =，剑指offer上的思路是这样的，对于二叉搜索树的后序遍历序列来讲，最后一个结点是根节点，那么根节点将二叉树分为两个部分，前半部分一定都小于根节点，后半部分一定都大于根节点，并且所有的子树都满足这样一个特点，这也就暗含了一个递归，对于每一个序列（子树的序列），都要符合这一要求。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sequence == <span class="keyword">null</span> || sequence.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> veritySequenceCore(sequence, <span class="number">0</span> , sequence.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">veritySequenceCore</span><span class="params">(<span class="keyword">int</span> [] sequence, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> rootVal = sequence[end];</span><br><span class="line">    <span class="keyword">int</span> midIndex = end;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sequence[i] &gt; rootVal) &#123;</span><br><span class="line">            midIndex = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = midIndex; j &lt;= end - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sequence[j] &lt; rootVal) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> veritySequenceCore(sequence, <span class="number">0</span> , midIndex - <span class="number">1</span>) &amp;&amp; veritySequenceCore(sequence, midIndex , end - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结：</p><p>本题包含的思想是分治思想，分而治之，不断递归，分为两部分，只有两部分都符合要求，我们才认为这个序列是正确的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;二叉树搜索树的后序遍历序列&quot;&gt;&lt;a href=&quot;#二叉树搜索树的后序遍历序列&quot; class=&quot;headerlink&quot; title=&quot;二叉树搜索树的后序遍历序列&quot;&gt;&lt;/a&gt;二叉树搜索树的后序遍历序列&lt;/h4&gt;&lt;h5 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h5&gt;&lt;p&gt;输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>

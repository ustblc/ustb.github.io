<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>lemon</title>
  
  <subtitle>一直在路上</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cblog.club/"/>
  <updated>2019-11-19T12:17:25.556Z</updated>
  <id>https://cblog.club/</id>
  
  <author>
    <name>lemon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>198打家劫舍</title>
    <link href="https://cblog.club/ck35tptb50001u8g4a6q63z39.html"/>
    <id>https://cblog.club/ck35tptb50001u8g4a6q63z39.html</id>
    <published>2019-11-19T12:06:04.000Z</published>
    <updated>2019-11-19T12:17:25.556Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>在不触动警报装置的情况下，</strong>能够偷窃到的最高金额。</p><a id="more"></a><blockquote><p><strong>示例 1:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: 偷窃 <span class="number">1</span> 号房屋 (金额 = <span class="number">1</span>) ，然后偷窃 <span class="number">3</span> 号房屋 (金额 = <span class="number">3</span>)。</span><br><span class="line">     偷窃到的最高金额 = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">12</span></span><br><span class="line">解释: 偷窃 <span class="number">1</span> 号房屋 (金额 = <span class="number">2</span>), 偷窃 <span class="number">3</span> 号房屋 (金额 = <span class="number">9</span>)，接着偷窃 <span class="number">5</span> 号房屋 (金额 = <span class="number">1</span>)。</span><br><span class="line">     偷窃到的最高金额 = <span class="number">2</span> + <span class="number">9</span> + <span class="number">1</span> = <span class="number">12</span> 。</span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：本题还算是比较简单，仔细分析一下还是能做出来的，状态转移方程dp-i-max-dp-i-2-nums-i-dp-i-3-nums-i-因为要隔着一个，那么就只能考虑这俩个，因为再往前就会影响到其他的房间了（不是相互独立的了），还有就是如果i-3没有的话，就直接选dp-i-2-nums-i-即可。"><a href="#解题思路：本题还算是比较简单，仔细分析一下还是能做出来的，状态转移方程dp-i-max-dp-i-2-nums-i-dp-i-3-nums-i-因为要隔着一个，那么就只能考虑这俩个，因为再往前就会影响到其他的房间了（不是相互独立的了），还有就是如果i-3没有的话，就直接选dp-i-2-nums-i-即可。" class="headerlink" title="解题思路：本题还算是比较简单，仔细分析一下还是能做出来的，状态转移方程dp[i]=max(dp[i-2]+nums[i],dp[i-3]+nums[i]);因为要隔着一个，那么就只能考虑这俩个，因为再往前就会影响到其他的房间了（不是相互独立的了），还有就是如果i-3没有的话，就直接选dp[i-2]+nums[i]即可。"></a>解题思路：本题还算是比较简单，仔细分析一下还是能做出来的，状态转移方程dp[i]=max(dp[i-2]+nums[i],dp[i-3]+nums[i]);因为要隔着一个，那么就只能考虑这俩个，因为再往前就会影响到其他的房间了（不是相互独立的了），还有就是如果i-3没有的话，就直接选dp[i-2]+nums[i]即可。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size=nums.size();</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">1</span>)<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(size);</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>]=nums[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> result=max(dp[<span class="number">0</span>],dp[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i<span class="number">-3</span>&lt;<span class="number">0</span>)dp[i]=dp[i<span class="number">-2</span>]+nums[i];</span><br><span class="line">            <span class="keyword">else</span> dp[i]=max(dp[i<span class="number">-2</span>]+nums[i],dp[i<span class="number">-3</span>]+nums[i]);</span><br><span class="line">            result=max(dp[i],result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，&lt;strong&gt;如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;给定一个代表每个房屋存放金额的非负整数数组，计算你&lt;strong&gt;在不触动警报装置的情况下，&lt;/strong&gt;能够偷窃到的最高金额。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/categories/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>53最大子序和</title>
    <link href="https://cblog.club/ck35tptek0020u8g4f37h4bn8.html"/>
    <id>https://cblog.club/ck35tptek0020u8g4f37h4bn8.html</id>
    <published>2019-11-19T11:57:50.000Z</published>
    <updated>2019-11-19T12:05:25.942Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p> 给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 </p><a id="more"></a><blockquote><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong></p><p>如果你已经实现复杂度为 O(<em>n</em>) 的解法，尝试使用更为精妙的分治法求解。</p></blockquote><h6 id="解题思路：本题刚开始我就在纠结于，遍历到当前元素时dp-i-的值，但是发现自己想的有点乱，借鉴了别人的思路，发现很不错，dp-i-代表以当前元素为终止元素的子序和（dp的选值就是max-以当前元素为终止结点的序列和，当前节点值-），因为我们要找的子序列一定是以某个元素为终止元素的，所以这么找一定会找到最终的结果，但是要注意的是，虽然当前元素会只用到前一个节点的dp值，但是最终结点的dp值不一定是最大的（这个要注意，和兑换零钱那种不太一样，要区别一下），最后找出其中最大的值即可。"><a href="#解题思路：本题刚开始我就在纠结于，遍历到当前元素时dp-i-的值，但是发现自己想的有点乱，借鉴了别人的思路，发现很不错，dp-i-代表以当前元素为终止元素的子序和（dp的选值就是max-以当前元素为终止结点的序列和，当前节点值-），因为我们要找的子序列一定是以某个元素为终止元素的，所以这么找一定会找到最终的结果，但是要注意的是，虽然当前元素会只用到前一个节点的dp值，但是最终结点的dp值不一定是最大的（这个要注意，和兑换零钱那种不太一样，要区别一下），最后找出其中最大的值即可。" class="headerlink" title="解题思路：本题刚开始我就在纠结于，遍历到当前元素时dp[i]的值，但是发现自己想的有点乱，借鉴了别人的思路，发现很不错，dp[i]代表以当前元素为终止元素的子序和（dp的选值就是max(以当前元素为终止结点的序列和，当前节点值)），因为我们要找的子序列一定是以某个元素为终止元素的，所以这么找一定会找到最终的结果，但是要注意的是，虽然当前元素会只用到前一个节点的dp值，但是最终结点的dp值不一定是最大的（这个要注意，和兑换零钱那种不太一样，要区别一下），最后找出其中最大的值即可。"></a>解题思路：本题刚开始我就在纠结于，遍历到当前元素时dp[i]的值，但是发现自己想的有点乱，借鉴了别人的思路，发现很不错，dp[i]代表以当前元素为终止元素的子序和（dp的选值就是max(以当前元素为终止结点的序列和，当前节点值)），因为我们要找的子序列一定是以某个元素为终止元素的，所以这么找一定会找到最终的结果，但是要注意的是，虽然当前元素会只用到前一个节点的dp值，但是最终结点的dp值不一定是最大的（这个要注意，和兑换零钱那种不太一样，要区别一下），最后找出其中最大的值即可。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size=nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(size);</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> result=dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;dp.size();i++)&#123;</span><br><span class="line">            dp[i]=max(dp[i<span class="number">-1</span>]+nums[i],nums[i]);</span><br><span class="line">            result=max(dp[i],result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt; 给定一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/categories/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>121买卖股票的最佳时机</title>
    <link href="https://cblog.club/ck35tptav0000u8g48yxkbaxe.html"/>
    <id>https://cblog.club/ck35tptav0000u8g48yxkbaxe.html</id>
    <published>2019-11-19T11:49:56.000Z</published>
    <updated>2019-11-19T11:57:46.887Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。</p><a id="more"></a><blockquote><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：可能是刚接触动态规划不久，一开始做这一题的时候，一直找不到状态转移方程（找这个真的不简单）-最终借鉴别人的思想，dp-i-max-前i-1天的最大利润，（当前价格-前i-1天最低的价格-，豁然开朗，找最低的价格，我想到的是使用multiset（因为set插入即有序的，比较方便，但是时间可能会慢一点）。（暴力破解也能过-）"><a href="#解题思路：可能是刚接触动态规划不久，一开始做这一题的时候，一直找不到状态转移方程（找这个真的不简单）-最终借鉴别人的思想，dp-i-max-前i-1天的最大利润，（当前价格-前i-1天最低的价格-，豁然开朗，找最低的价格，我想到的是使用multiset（因为set插入即有序的，比较方便，但是时间可能会慢一点）。（暴力破解也能过-）" class="headerlink" title="解题思路：可能是刚接触动态规划不久，一开始做这一题的时候，一直找不到状态转移方程（找这个真的不简单）,最终借鉴别人的思想，dp[i]=max(前i-1天的最大利润，（当前价格-前i-1天最低的价格))，豁然开朗，找最低的价格，我想到的是使用multiset（因为set插入即有序的，比较方便，但是时间可能会慢一点）。（暴力破解也能过= =）"></a>解题思路：可能是刚接触动态规划不久，一开始做这一题的时候，一直找不到状态转移方程（找这个真的不简单）,最终借鉴别人的思想，dp[i]=max(前i-1天的最大利润，（当前价格-前i-1天最低的价格))，豁然开朗，找最低的价格，我想到的是使用multiset（因为set插入即有序的，比较方便，但是时间可能会慢一点）。（暴力破解也能过= =）</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*class Solution &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span></span><br><span class="line"><span class="comment">        int max=0;</span></span><br><span class="line"><span class="comment">        int cur_sub;</span></span><br><span class="line"><span class="comment">        for(int j=0;j&lt;prices.size();j++)&#123;</span></span><br><span class="line"><span class="comment">            for(int i=j+1;i&lt;prices.size();i++)&#123;</span></span><br><span class="line"><span class="comment">                if(prices[j]&lt;prices[i])&#123;</span></span><br><span class="line"><span class="comment">                    cur_sub=prices[i]-prices[j];</span></span><br><span class="line"><span class="comment">                    if(max&lt;cur_sub)max=cur_sub;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return max;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size=prices.size();</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;mset;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(size);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur_sub_pre;</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;dp.size();i++)&#123;</span><br><span class="line">            mset.insert(prices[i<span class="number">-1</span>]);</span><br><span class="line">            it=mset.begin();</span><br><span class="line">            cur_sub_pre=prices[i]-*(it);</span><br><span class="line">            dp[i]=max(dp[i<span class="number">-1</span>],cur_sub_pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[size<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;给定一个数组，它的第 &lt;em&gt;i&lt;/em&gt; 个元素是一支给定股票第 &lt;em&gt;i&lt;/em&gt; 天的价格。&lt;/p&gt;
&lt;p&gt;如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。&lt;/p&gt;
&lt;p&gt;注意你不能在买入股票前卖出股票。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/categories/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>70爬楼梯</title>
    <link href="https://cblog.club/ck35tptdz0018u8g4f5ep5m1c.html"/>
    <id>https://cblog.club/ck35tptdz0018u8g4f5ep5m1c.html</id>
    <published>2019-11-19T11:42:03.000Z</published>
    <updated>2019-11-19T11:49:30.206Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。</p><p>你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p><a id="more"></a><blockquote><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：这一题刚开始在想，这题和动态规划有关系吗？也没有什么最优子结构什么的啊？细细一想，这不就是斐波那契数吗-（原理很类似），我们这样考虑：假设我们当前处于第四层，那么我们是怎么上来的呢？一共有两种可能，第一：从第三层上来的，第二：从第二层上来的，那么此时我们就会有两种可能，同理，第三层，第二层也都是这么上来的，故我们自底向上（动态规划的思想出现了），第一层只有一种可能，第二层有两种可能，从第三层开始，当前层-n-1-层-n-2-层-（这不就是斐波那契数列的原型吗-，只不过数不一样了）。当然，空间复杂度还可以优化为O-1-，如第二种方法所示。"><a href="#解题思路：这一题刚开始在想，这题和动态规划有关系吗？也没有什么最优子结构什么的啊？细细一想，这不就是斐波那契数吗-（原理很类似），我们这样考虑：假设我们当前处于第四层，那么我们是怎么上来的呢？一共有两种可能，第一：从第三层上来的，第二：从第二层上来的，那么此时我们就会有两种可能，同理，第三层，第二层也都是这么上来的，故我们自底向上（动态规划的思想出现了），第一层只有一种可能，第二层有两种可能，从第三层开始，当前层-n-1-层-n-2-层-（这不就是斐波那契数列的原型吗-，只不过数不一样了）。当然，空间复杂度还可以优化为O-1-，如第二种方法所示。" class="headerlink" title="解题思路：这一题刚开始在想，这题和动态规划有关系吗？也没有什么最优子结构什么的啊？细细一想，这不就是斐波那契数吗= =（原理很类似），我们这样考虑：假设我们当前处于第四层，那么我们是怎么上来的呢？一共有两种可能，第一：从第三层上来的，第二：从第二层上来的，那么此时我们就会有两种可能，同理，第三层，第二层也都是这么上来的，故我们自底向上（动态规划的思想出现了），第一层只有一种可能，第二层有两种可能，从第三层开始，当前层=(n-1)层+(n-2)层,（这不就是斐波那契数列的原型吗= =，只不过数不一样了）。当然，空间复杂度还可以优化为O(1)，如第二种方法所示。"></a>解题思路：这一题刚开始在想，这题和动态规划有关系吗？也没有什么最优子结构什么的啊？细细一想，这不就是斐波那契数吗= =（原理很类似），我们这样考虑：假设我们当前处于第四层，那么我们是怎么上来的呢？一共有两种可能，第一：从第三层上来的，第二：从第二层上来的，那么此时我们就会有两种可能，同理，第三层，第二层也都是这么上来的，故我们自底向上（动态规划的思想出现了），第一层只有一种可能，第二层有两种可能，从第三层开始，当前层=(n-1)层+(n-2)层,（这不就是斐波那契数列的原型吗= =，只不过数不一样了）。当然，空间复杂度还可以优化为O(1)，如第二种方法所示。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int climbStairs(int n) &#123;</span></span><br><span class="line"><span class="comment">        vector&lt;int&gt;dp(n+2);</span></span><br><span class="line"><span class="comment">        dp[1]=1;</span></span><br><span class="line"><span class="comment">        dp[2]=2;</span></span><br><span class="line"><span class="comment">        for(int i=3;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">            dp[i]=dp[i-1]+dp[i-2];</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return dp[n];</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pre=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cur=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-2</span>;i++)&#123;</span><br><span class="line">            sum=cur+pre;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;假设你正在爬楼梯。需要 &lt;em&gt;n&lt;/em&gt; 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。&lt;/p&gt;
&lt;p&gt;你有多少种不同的方法可以爬到楼顶呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;给定 &lt;em&gt;n&lt;/em&gt; 是一个正整数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/categories/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>322零钱兑换</title>
    <link href="https://cblog.club/ck35tptbh0006u8g4b19b5136.html"/>
    <id>https://cblog.club/ck35tptbh0006u8g4b19b5136.html</id>
    <published>2019-11-19T11:33:23.000Z</published>
    <updated>2019-11-19T11:41:57.625Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p> 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code>。 </p><a id="more"></a><blockquote><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: coins = [1, 2, 5], amount = 11</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: coins = [2], amount = 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure><p><strong>说明</strong>:<br>你可以认为每种硬币的数量是无限的。</p></blockquote><h6 id="解题思路：这一题是动态规划的入门题目，可以说是很经典的一道题，对于动态规划，关键在于你是否能够写出状态转移方程（能写出来就已经成功了80-），这一题的状态转移方程主要是dp-i-min-dp-i-1-dp-i-coin-其中coin为零钱的面额，最后返回dp-总金额-即可。"><a href="#解题思路：这一题是动态规划的入门题目，可以说是很经典的一道题，对于动态规划，关键在于你是否能够写出状态转移方程（能写出来就已经成功了80-），这一题的状态转移方程主要是dp-i-min-dp-i-1-dp-i-coin-其中coin为零钱的面额，最后返回dp-总金额-即可。" class="headerlink" title="解题思路：这一题是动态规划的入门题目，可以说是很经典的一道题，对于动态规划，关键在于你是否能够写出状态转移方程（能写出来就已经成功了80%），这一题的状态转移方程主要是dp[i]=min(dp[i],1+dp[i-coin])其中coin为零钱的面额，最后返回dp[总金额]即可。"></a>解题思路：这一题是动态规划的入门题目，可以说是很经典的一道题，对于动态规划，关键在于你是否能够写出状态转移方程（能写出来就已经成功了80%），这一题的状态转移方程主要是dp[i]=min(dp[i],1+dp[i-coin])其中coin为零钱的面额，最后返回dp[总金额]即可。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;</span></span><br><span class="line"><span class="comment">        vector&lt;int&gt;dp(amount+1,amount+1);</span></span><br><span class="line"><span class="comment">        dp[0]=0;</span></span><br><span class="line"><span class="comment">        for(int i=0;i&lt;=amount;i++)&#123;</span></span><br><span class="line"><span class="comment">            for(int coin:coins)&#123;</span></span><br><span class="line"><span class="comment">                if(i&lt;coin)continue;</span></span><br><span class="line"><span class="comment">                dp[i]=min(dp[i],1+dp[i-coin]);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return (dp[amount]==amount+1)?-1:dp[amount];</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;memo(amount+<span class="number">1</span>,<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">return</span> helper(coins,amount,memo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; memo)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(amount==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(memo[amount]!=<span class="number">-2</span>)<span class="keyword">return</span> memo[amount];</span><br><span class="line">        <span class="keyword">int</span> ans=__INT_MAX__;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> coin:coins)&#123;</span><br><span class="line">            <span class="keyword">if</span>(amount&lt;coin)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> sub_curcoin=helper(coins,amount-coin,memo);</span><br><span class="line">            <span class="keyword">if</span>(sub_curcoin==<span class="number">-1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            ans=min(ans,<span class="number">1</span>+sub_curcoin);</span><br><span class="line">        &#125;</span><br><span class="line">        memo[amount]=(ans==__INT_MAX__)?<span class="number">-1</span>:ans;</span><br><span class="line">        <span class="keyword">return</span> memo[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt; 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 &lt;code&gt;-1&lt;/code&gt;。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/categories/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="https://cblog.club/ck35tpte9001pu8g44m3e4vao.html"/>
    <id>https://cblog.club/ck35tpte9001pu8g44m3e4vao.html</id>
    <published>2019-11-19T11:10:56.000Z</published>
    <updated>2019-11-19T11:33:29.566Z</updated>
    
    <content type="html"><![CDATA[<p>最近在知乎上看到了一篇讲动态规划的文章，感觉还可以，比较好理解。</p><p>出于对作者的尊重，特别感谢作者，其知乎： <a href="https://www.zhihu.com/search?type=content&q=动态规划" target="_blank" rel="noopener">https://www.zhihu.com/search?type=content&amp;q=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92</a> </p><p>动态规划算法似乎是一种很高深莫测的算法，你会在一些面试或算法书籍的高级技巧部分看到相关内容，什么状态转移方程，重叠子问题，最优子结构等高大上的词汇也可能让你望而却步。</p><a id="more"></a><p>而且，当你去看用动态规划解决某个问题的代码时，你会觉得这样解决问题竟然如此巧妙，但却难以理解，你可能惊讶于人家是怎么想到这种解法的。</p><p>实际上，动态规划是一种常见的「算法设计技巧」，并没有什么高深莫测，至于各种高大上的术语，那是吓唬别人用的，只要你亲自体验几把，这些名词的含义其实显而易见，再简单不过了。</p><p>至于为什么最终的解法看起来如此精妙，是因为动态规划遵循一套固定的流程：<strong>递归的暴力解法 -&gt; 带备忘录的递归解法 -&gt; 非递归的动态规划解法</strong>。这个过程是层层递进的解决问题的过程，你如果没有前面的铺垫，直接看最终的非递归动态规划解法，当然会觉得牛逼而不可及了。</p><p>当然，见的多了，思考多了，是可以一步写出非递归的动态规划解法的。任何技巧都需要练习，我们先遵循这个流程走，算法设计也就这些套路，除此之外，真的没啥高深的。</p><p>以下，先通过两个个比较简单的例子：斐波那契和凑零钱问题，揭开动态规划的神秘面纱，描述上述三个流程。后续还会写几篇文章探讨如何使用动态规划技巧解决比较复杂的经典问题。</p><p>首先，第一个快被举烂了的例子，斐波那契数列。<strong>请读者不要嫌弃这个例子简单，因为简单的例子才能让你把精力充分集中在算法背后的通用思想和技巧上</strong>，而不会被那些隐晦的细节问题搞的莫名其妙。后续，困难的例子有的是。</p><p> <strong>步骤一、暴力的递归算法</strong> </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">1</span> || N == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fib(N - <span class="number">1</span>) + fib(N - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个不用多说了，学校老师讲递归的时候似乎都是拿这个举例。我们也知道这样写代码虽然简洁易懂，但是十分低效，低效在哪里？假设 n = 20，请画出递归树。</p><p>PS：但凡遇到需要递归的问题，最好都画出递归树，这对你分析算法的复杂度，寻找算法低效的原因都有巨大帮助。</p><img src="/ck35tpte9001pu8g44m3e4vao/1.jpg" class=""><p>这个递归树怎么理解？就是说想要计算原问题 f(20)，我就得先计算出子问题 f(19) 和 f(18)，然后要计算 f(19)，我就要先算出子问题 f(18) 和 f(17)，以此类推。最后遇到 f(1) 或者 f(2) 的时候，结果已知，就能直接返回结果，递归树不再向下生长了。</p><p> <strong>递归算法的时间复杂度怎么计算？子问题个数乘以解决一个子问题需要的时间。</strong> </p><p>子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。</p><p>解决一个子问题的时间，在本算法中，没有循环，只有 f(n - 1) + f(n - 2) 一个加法操作，时间为 O(1)。</p><p>所以，这个算法的时间复杂度为 O(2^n)，指数级别，爆炸。</p><p>观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如 f(18) 被计算了两次，而且你可以看到，以 f(18) 为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 f(18) 这一个节点被重复计算，所以这个算法极其低效。</p><p> 这就是动态规划问题的第一个性质：<strong>重叠子问题</strong>。下面，我们想办法解决这个问题。 </p><p><strong>步骤二、带备忘录的递归解法</strong></p><p>明确了问题，其实就已经把问题解决了一半。即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。</p><p>一般使用一个数组充当这个「备忘录」，当然你也可以使用哈希表（字典），思想都是一样的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 备忘录全初始化为 0</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; memo(N + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 初始化最简情况</span></span><br><span class="line">    memo[<span class="number">1</span>] = memo[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> helper(memo, N);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; memo, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 未被计算过</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span> &amp;&amp; memo[n] == <span class="number">0</span>) </span><br><span class="line">        memo[n] = helper(memo, n - <span class="number">1</span>) + </span><br><span class="line">                  helper(memo, n - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 现在，画出递归树，你就知道「备忘录」到底做了什么。 </p><img src="/ck35tpte9001pu8g44m3e4vao/2.jpg" class=""><p>实际上，带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。</p><p>递归算法的时间复杂度怎么算？子问题个数乘以解决一个子问题需要的时间。</p><p>子问题个数，即图中节点的总数，由于本算法不存在冗余计算，子问题就是 f(1), f(2), f(3) … f(20)，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)。</p><p>解决一个子问题的时间，同上，没有什么循环，时间为 O(1)。</p><p>所以，本算法的时间复杂度是 O(n)。比起暴力算法，是降维打击。</p><p>至此，带备忘录的递归解法的效率已经和动态规划一样了。实际上，这种解法和动态规划的思想已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。</p><p>啥叫「自顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 f(20)，向下逐渐分解规模，直到 f(1) 和 f(2) 触底，然后逐层返回答案，这就叫「自顶向下」。</p><p>啥叫「自底向上」？反过来，我们直接从最底下，最简单，问题规模最小的 f(1) 和 f(2) 开始往上推，直到推到我们想要的答案 f(20)，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。</p><p> <strong>步骤三、动态规划</strong> </p><p> 有了上一步「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一张表，就叫做 DP table 吧，在这张表上完成「自底向上」的推算岂不美哉！ </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(N + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">1</span>] = dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= N; i++)</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/ck35tpte9001pu8g44m3e4vao/3.jpg" class=""><p>画个图就很好理解了，而且你发现这个 DP table 特别像之前那个「剪枝」后的结果，只是反过来算而已。实际上，带备忘录的递归解法中的「备忘录」，最终完成后就是这个 DP table，所以说这两种解法其实是差不多的，大部分情况下，效率也基本相同。</p><p>这里，引出「动态转移方程」这个名词，实际上就是描述问题结构的数学形式：</p><img src="/ck35tpte9001pu8g44m3e4vao/4.jpg" class=""><p>为啥叫「状态转移方程」？为了听起来高端。你把 f(n) 想做一个状态 n，这个状态 n 是由状态 n - 1 和状态 n - 2 相加转移而来，这就叫状态转移，仅此而已。</p><p>你会发现，上面的几种解法中的所有操作，例如 return f(n - 1) + f(n - 2)，dp[i] = dp[i - 1] + dp[i - 2]，以及对备忘录或 DP table 的初始化操作，都是围绕这个方程式的不同表现形式。可见列出「状态转移方程」的重要性，它是解决问题的核心。很容易发现，其实状态转移方程直接代表着暴力解法。</p><p><strong>千万不要看不起暴力解，动态规划问题最困难的就是写出状态转移方程</strong>，即这个暴力解。优化方法无非是用备忘录或者 DP table，再无奥妙可言。</p><p>这个例子的最后，讲一个细节优化。细心的读者会发现，根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 O(1)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span> prev = <span class="number">0</span>, curr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = prev + curr;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有人会问，动态规划的另一个重要特性「最优子结构」，怎么没有涉及？下面会涉及。斐波那契数列的例子严格来说不算动态规划，以上旨在演示算法设计螺旋上升的过程。当问题中要求求一个最优解或在代码中看到循环和 max、min 等函数时，十有八九，需要动态规划大显身手。</p><p>下面，看第二个例子，凑零钱问题，有了上面的详细铺垫，这个问题会很快解决。</p><p>题目：给你 k 种面值的硬币，面值分别为 c1, c2 … ck，再给一个总金额 n，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，则回答 -1 。</p><p>比如说，k = 3，面值分别为 1，2，5，总金额 n = 11，那么最少需要 3 枚硬币，即 11 = 5 + 5 + 1 。下面走流程。</p><p><strong>一、暴力解法</strong></p><p>首先是最困难的一步，写出状态转移方程，这个问题比较好写：</p><img src="/ck35tpte9001pu8g44m3e4vao/5.jpg" class=""><p>其实，这个方程就用到了<strong>「最优子结构」性质：原问题的解由子问题的最优解构成。</strong>即 f(11) 由 f(10), f(9), f(6) 的最优解转移而来。</p><p>记住，<strong>要符合「最优子结构」，子问题间必须互相独立。</strong>啥叫相互独立？你肯定不想看数学证明，我用一个直观的例子来讲解。</p><p>比如说，你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。</p><p>得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。</p><p>但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，此消彼长。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。</p><p>回到凑零钱问题，显然子问题之间没有相互制约，而是互相独立的。所以这个状态转移方程是可以得到正确答案的。</p><p>之后就没啥难点了，按照方程写暴力递归算法即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">        <span class="comment">// 金额不可达</span></span><br><span class="line">        <span class="keyword">if</span> (amount - coin &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> subProb = coinChange(coins, amount - coin);</span><br><span class="line">        <span class="comment">// 子问题无解</span></span><br><span class="line">        <span class="keyword">if</span> (subProb == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        ans = min(ans, subProb + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans == INT_MAX ? <span class="number">-1</span> : ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 画出递归树： </p><img src="/ck35tpte9001pu8g44m3e4vao/6.jpg" class=""><p> 时间复杂度分析：子问题总数 x 每个子问题的时间。子问题总数为递归树节点个数，这个比较难看出来，是 O(n^k)，总之是指数级别的。每个子问题中含有一个 for 循环，复杂度为 O(k)。所以总时间复杂度为 O(k*n^k)，指数级别。 </p><p><strong>二、带备忘录的递归算法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 备忘录初始化为 -2</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; memo(amount + <span class="number">1</span>, <span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">return</span> helper(coins, amount, memo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; memo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (memo[amount] != <span class="number">-2</span>) <span class="keyword">return</span> memo[amount];</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">        <span class="comment">// 金额不可达</span></span><br><span class="line">        <span class="keyword">if</span> (amount - coin &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> subProb = helper(coins, amount - coin, memo);</span><br><span class="line">        <span class="comment">// 子问题无解</span></span><br><span class="line">        <span class="keyword">if</span> (subProb == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        ans = min(ans, subProb + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录本轮答案</span></span><br><span class="line">    memo[amount] = (ans == INT_MAX) ? <span class="number">-1</span> : ans;</span><br><span class="line">    <span class="keyword">return</span> memo[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 不画图了，很显然「备忘录」大大减小了子问题数目，完全消除了子问题的冗余，所以子问题总数不会超过金额数 n，即子问题数目为 O(n)。处理一个子问题的时间不变，仍是 O(k)，所以总的时间复杂度是 O(kn)。 </p><p> <strong>三、动态规划</strong> </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(amount + <span class="number">1</span>, amount + <span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.size(); i++) &#123;</span><br><span class="line">        <span class="comment">// 内层 for 在求所有子问题 + 1 的最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i - coin &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dp[i] = min(dp[i], <span class="number">1</span> + dp[i - coin]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (dp[amount] == amount + <span class="number">1</span>) ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/ck35tpte9001pu8g44m3e4vao/7.jpg" class=""><p><strong>最后总结</strong></p><p>如果你不太了解动态规划，还能看到这里，真得给你鼓掌，相信你已经掌握了这个算法的设计技巧。</p><p>计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举，穷举所有可能性。算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。</p><p>列出动态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。</p><p>备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门，除此之外，试问，还能玩出啥花活？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在知乎上看到了一篇讲动态规划的文章，感觉还可以，比较好理解。&lt;/p&gt;
&lt;p&gt;出于对作者的尊重，特别感谢作者，其知乎： &lt;a href=&quot;https://www.zhihu.com/search?type=content&amp;q=动态规划&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.zhihu.com/search?type=content&amp;amp;q=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;动态规划算法似乎是一种很高深莫测的算法，你会在一些面试或算法书籍的高级技巧部分看到相关内容，什么状态转移方程，重叠子问题，最优子结构等高大上的词汇也可能让你望而却步。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://cblog.club/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://cblog.club/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>PyTorch_Day2</title>
    <link href="https://cblog.club/ck35tpte3001eu8g4ajgx1zbv.html"/>
    <id>https://cblog.club/ck35tpte3001eu8g4ajgx1zbv.html</id>
    <published>2019-11-19T03:26:51.000Z</published>
    <updated>2019-11-19T11:09:04.961Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Autograd-自动求导机制"><a href="#Autograd-自动求导机制" class="headerlink" title="Autograd: 自动求导机制"></a>Autograd: 自动求导机制</h2><p>PyTorch 中所有神经网络的核心是 autograd 包。 我们先简单介绍一下这个包，然后训练第一个简单的神经网络。<br>autograd包为张量上的所有操作提供了自动求导。 它是一个在运行时定义的框架，这意味着反向传播是根据你的代码来确定如何运行，并且每次迭代可以是不同的。</p><a id="more"></a><h3 id="张量Tensor"><a href="#张量Tensor" class="headerlink" title="张量Tensor"></a>张量Tensor</h3><ul><li>torch.Tensor 是包的核心类。如果将其属性 .requires_grad 设置为 True，则会开始跟踪针对 tensor 的所有操作。完成计算后，您可以调用 .backward() 来自动计算所有梯度。该张量的梯度将累积到 .grad 属性中。</li><li>要停止 tensor 历史记录的跟踪，您可以调用 .detach()，它将其与计算历史记录分离，并防止将来的计算被跟踪。</li><li>要停止跟踪历史记录（和使用内存），您还可以将代码块使用 with torch.no_grad(): 包装起来。在评估模型时，这是特别有用，因为模型在训练阶段具有 requires_grad = True 的可训练参数有利于调参，但在评估阶段我们不需要梯度。</li><li>还有一个类对于 autograd 实现非常重要那就是 Function。Tensor 和 Function 互相连接并构建一个非循环图，它保存整个完整的计算过程的历史信息。每个张量都有一个 .grad_fn 属性保存着创建了张量的 Function 的引用，（如果用户自己创建张量，则grad_fn 是 None ）。</li><li>如果你想计算导数，你可以调用 Tensor.backward()。如果 Tensor 是标量（即它包含一个元素数据），则不需要指定任何参数backward()，但是如果它有更多元素，则需要指定一个gradient 参数来指定张量的形状。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br></pre></td></tr></table></figure><h4 id="创建一个tensor张量，并且设置requires-grad-True用来追踪他的计算历史"><a href="#创建一个tensor张量，并且设置requires-grad-True用来追踪他的计算历史" class="headerlink" title="创建一个tensor张量，并且设置requires_grad=True用来追踪他的计算历史"></a>创建一个tensor张量，并且设置requires_grad=True用来追踪他的计算历史</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=torch.ones(<span class="number">2</span>,<span class="number">2</span>,requires_grad=<span class="literal">True</span>)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><pre><code>tensor([[1., 1.],        [1., 1.]], requires_grad=True)</code></pre><h4 id="结果y已经被计算出来了，所以，grad-fn已经被自动生成了"><a href="#结果y已经被计算出来了，所以，grad-fn已经被自动生成了" class="headerlink" title="结果y已经被计算出来了，所以，grad_fn已经被自动生成了"></a>结果y已经被计算出来了，所以，grad_fn已经被自动生成了</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y=x+<span class="number">2</span></span><br><span class="line">print(y)</span><br><span class="line">print(y .grad_fn)</span><br></pre></td></tr></table></figure><pre><code>tensor([[3., 3.],        [3., 3.]], grad_fn=&lt;AddBackward0&gt;)&lt;AddBackward0 object at 0x000001A29043E080&gt;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">z=y*y*<span class="number">3</span></span><br><span class="line"><span class="comment">#mean() 返回数组的算术平均值</span></span><br><span class="line">out=z.mean()</span><br><span class="line">print(z,out)</span><br></pre></td></tr></table></figure><pre><code>tensor([[27., 27.],        [27., 27.]], grad_fn=&lt;MulBackward0&gt;) tensor(27., grad_fn=&lt;MeanBackward0&gt;)</code></pre><h4 id="requires-grad-…-可以改变现有张量的-requires-grad属性。-如果没有指定的话，默认输入的flag是-False"><a href="#requires-grad-…-可以改变现有张量的-requires-grad属性。-如果没有指定的话，默认输入的flag是-False" class="headerlink" title=".requires_grad_( … ) 可以改变现有张量的 requires_grad属性。 如果没有指定的话，默认输入的flag是 False"></a>.requires_grad_( … ) 可以改变现有张量的 requires_grad属性。 如果没有指定的话，默认输入的flag是 False</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a=torch.randn(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">a=(a*<span class="number">3</span>)/(a<span class="number">-1</span>)</span><br><span class="line">print(a.requires_grad)</span><br><span class="line">a.requires_grad_(<span class="literal">True</span>)</span><br><span class="line">print(a.requires_grad)</span><br><span class="line">b=(a*a).sum()</span><br><span class="line">print(b.grad_fn)</span><br></pre></td></tr></table></figure><pre><code>FalseTrue&lt;SumBackward0 object at 0x000001A29097A748&gt;</code></pre><h3 id="梯度Gradient"><a href="#梯度Gradient" class="headerlink" title="梯度Gradient"></a>梯度Gradient</h3><p>反向传播，因为上文中的out是一个纯量(scalar)，out.backward()等于out.backwad(torch.tensor(1))</p><ul><li>x梯度计算不是很理解原理</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#out.backward()       #只能使用一次 </span></span><br><span class="line">print(x.grad)</span><br></pre></td></tr></table></figure><pre><code>tensor([[4.5000, 4.5000],        [4.5000, 4.5000]])</code></pre><h4 id="现在让我们看一个雅可比向量积的例子：-不理解"><a href="#现在让我们看一个雅可比向量积的例子：-不理解" class="headerlink" title="现在让我们看一个雅可比向量积的例子：(不理解= =)"></a>现在让我们看一个雅可比向量积的例子：(不理解= =)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x=torch.randn(<span class="number">3</span>,requires_grad=<span class="literal">True</span>)</span><br><span class="line">y=x*<span class="number">2</span></span><br><span class="line"><span class="comment">#torch.norm是对输入的Tensor求范数</span></span><br><span class="line"><span class="keyword">while</span> y.data.norm()&lt;<span class="number">1000</span>:</span><br><span class="line">    y=y*<span class="number">2</span></span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure><pre><code>tensor([-340.3439, 1044.5084, -227.5869], grad_fn=&lt;MulBackward0&gt;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gradients=torch.tensor([<span class="number">0.1</span>,<span class="number">1.0</span>,<span class="number">0.0001</span>],dtype=torch.float)</span><br><span class="line"><span class="comment">#y.backward(gradients)</span></span><br><span class="line">print(x.grad)</span><br></pre></td></tr></table></figure><pre><code>tensor([5.1200e+01, 5.1200e+02, 5.1200e-02])</code></pre><h4 id="如果-requires-grad-True但是你又不希望进行autograd的计算，-那么可以将变量包裹在-with-torch-no-grad-中"><a href="#如果-requires-grad-True但是你又不希望进行autograd的计算，-那么可以将变量包裹在-with-torch-no-grad-中" class="headerlink" title="如果.requires_grad=True但是你又不希望进行autograd的计算， 那么可以将变量包裹在 with torch.no_grad()中:"></a>如果.requires_grad=True但是你又不希望进行autograd的计算， 那么可以将变量包裹在 with torch.no_grad()中:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(x.requires_grad)</span><br><span class="line">print((x**<span class="number">2</span>).requires_grad)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    print((x**<span class="number">2</span>).requires_grad)</span><br></pre></td></tr></table></figure><pre><code>TrueTrueFalse</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Autograd-自动求导机制&quot;&gt;&lt;a href=&quot;#Autograd-自动求导机制&quot; class=&quot;headerlink&quot; title=&quot;Autograd: 自动求导机制&quot;&gt;&lt;/a&gt;Autograd: 自动求导机制&lt;/h2&gt;&lt;p&gt;PyTorch 中所有神经网络的核心是 autograd 包。 我们先简单介绍一下这个包，然后训练第一个简单的神经网络。&lt;br&gt;autograd包为张量上的所有操作提供了自动求导。 它是一个在运行时定义的框架，这意味着反向传播是根据你的代码来确定如何运行，并且每次迭代可以是不同的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="PyTorch" scheme="https://cblog.club/categories/PyTorch/"/>
    
    
      <category term="PyTorch" scheme="https://cblog.club/tags/PyTorch/"/>
    
  </entry>
  
  <entry>
    <title>PyTorch_Day1</title>
    <link href="https://cblog.club/ck35tpte4001hu8g401if0yip.html"/>
    <id>https://cblog.club/ck35tpte4001hu8g401if0yip.html</id>
    <published>2019-11-18T12:57:55.000Z</published>
    <updated>2019-11-18T14:21:46.550Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直在看keras，但是看了之后，给我一种感觉就是：本来深度学习就已经够黑盒了，你再给我封装的这么死，我不想成为调包侠= =，然后Pytorch最近比较流行，在封装性上也没有keras那么死板，所以尝试学习一下。</p><a id="more"></a><h3 id="PyTorch简介"><a href="#PyTorch简介" class="headerlink" title="PyTorch简介"></a>PyTorch简介</h3><p>PyTorch是一个基于 Python 的科学计算包，主要定位两类人群：</p><ul><li>NumPy的替代品，可以利用GPU的性能进行计算</li><li>深度学习研究平台拥有足够的灵活性和速度</li></ul><p>要介绍PyTorch之前，不得不说一下Torch。Torch是一个有大量机器学习算法支持的科学计算框架，是一个与Numpy类似的张量（Tensor） 操作库，其特点是特别灵活，但因其采用了小众的编程语言是Lua，所以流行度不高，这也就有了PyTorch的出现。所以其实Torch是 PyTorch的前身，它们的底层语言相同，只是使用了不同的上层包装语言。</p><p>PyTorch是一个基于Torch的Python开源机器学习库，用于自然语言处理等应用程序。它主要由Facebookd的人工智能小组开发，不仅能够 实现强大的GPU加速，同时还支持动态神经网络，这一点是现在很多主流框架如TensorFlow都不支持的。 PyTorch提供了两个高级功能： <em>具有强大的GPU加速的张量计算（如Numpy）</em> 包含自动求导系统的深度神经网络。</p><p>TensorFlow和Caffe都是命令式的编程语言，而且是静态的，首先必须构建一个神经网络，然后一次又一次使用相同的结构，如果想要改 变网络的结构，就必须从头开始。但是对于PyTorch，通过反向求导技术，可以让你零延迟地任意改变神经网络的行为，而且其实现速度快。正是这一灵活性是PyTorch对比TensorFlow的最大优势。</p><p>另外，PyTorch的代码对比TensorFlow而言，更加简洁直观，底层代码也更容易看懂，这对于使用它的人来说理解底层肯定是一件令人激动的事。</p><p>所以，总结一下PyTorch的优点： <strong>支持GPU</strong>，灵活，支持动态神经网络 <strong>底层代码易于理解</strong> 命令式体验、 自定义扩展。</p><p>当然，现今任何一个深度学习框架都有其缺点，PyTorch也不例外，对比TensorFlow，其全面性处于劣势，目前PyTorch还不支持快速傅里 叶、沿维翻转张量和检查无穷与非数值张量；针对移动端、嵌入式部署以及高性能服务器端的部署其性能表现有待提升；其次因为这个框 架较新，使得他的社区没有那么强大，在文档方面其C库大多数没有文档。 </p><h3 id="PyTorch安装"><a href="#PyTorch安装" class="headerlink" title="PyTorch安装"></a>PyTorch安装</h3><p>直接官网下载： <a href="https://pytorch.org" target="_blank" rel="noopener">https://pytorch.org</a>，在anaconda中输入以下命令即可（先查看自己的cudatoolkit是什么版本，选择对应版本）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pytorch torchvision cudatoolkit=10.0 -c pytorch</span><br></pre></td></tr></table></figure><p>在下载过程中可能由于是网速不快，pytorch又有点大，所以总是下载失败，可以设置一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --<span class="built_in">set</span> remote_read_timeout_secs 600.0</span><br></pre></td></tr></table></figure><p>最后检查PyTorch是否在用GPU加速：</p><ul><li>方法一：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">a = torch.cuda.is_available()</span><br><span class="line">print(a)</span><br><span class="line">ngpu= <span class="number">1</span></span><br><span class="line"><span class="comment"># Decide which device we want to run on</span></span><br><span class="line">device = torch.device(<span class="string">"cuda:0"</span> <span class="keyword">if</span> (torch.cuda.is_available() <span class="keyword">and</span> ngpu &gt; <span class="number">0</span>) <span class="keyword">else</span> <span class="string">"cpu"</span>)</span><br><span class="line">print(device)</span><br><span class="line">print(torch.cuda.get_device_name(<span class="number">0</span>))</span><br><span class="line">print(torch.rand(<span class="number">3</span>,<span class="number">3</span>).cuda())</span><br></pre></td></tr></table></figure><p>结果如下即可（每个人显卡不一样，这里是自己的电脑配置）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">True</span></span><br><span class="line">cuda:<span class="number">0</span></span><br><span class="line">GeForce GTX <span class="number">950</span>M</span><br><span class="line">tensor([[<span class="number">0.8102</span>, <span class="number">0.1912</span>, <span class="number">0.2961</span>],</span><br><span class="line">        [<span class="number">0.9527</span>, <span class="number">0.1479</span>, <span class="number">0.8146</span>],</span><br><span class="line">        [<span class="number">0.4283</span>, <span class="number">0.3469</span>, <span class="number">0.3501</span>]], device=<span class="string">'cuda:0'</span>)</span><br></pre></td></tr></table></figure><ul><li>方法二</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.cuda.is_available()</span><br></pre></td></tr></table></figure><p>输出为<code>True</code>即可</p><h3 id="开始学习"><a href="#开始学习" class="headerlink" title="开始学习"></a>开始学习</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.cuda.is_available()</span><br></pre></td></tr></table></figure><pre><code>True</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">a = torch.cuda.is_available()</span><br><span class="line">print(a)</span><br><span class="line">ngpu= <span class="number">1</span></span><br><span class="line"><span class="comment"># Decide which device we want to run on</span></span><br><span class="line">device = torch.device(<span class="string">"cuda:0"</span> <span class="keyword">if</span> (torch.cuda.is_available() <span class="keyword">and</span> ngpu &gt; <span class="number">0</span>) <span class="keyword">else</span> <span class="string">"cpu"</span>)</span><br><span class="line">print(device)</span><br><span class="line">print(torch.cuda.get_device_name(<span class="number">0</span>))</span><br><span class="line">print(torch.rand(<span class="number">3</span>,<span class="number">3</span>).cuda())</span><br></pre></td></tr></table></figure><pre><code>Truecuda:0GeForce GTX 950Mtensor([[0.2935, 0.9656, 0.2542],        [0.3013, 0.2124, 0.9071],        [0.5502, 0.8500, 0.2255]], device=&apos;cuda:0&apos;)</code></pre><h4 id="Tensors张量，类似于Numpy里的ndarrays，同时Tensors可以使用GPU进行计算"><a href="#Tensors张量，类似于Numpy里的ndarrays，同时Tensors可以使用GPU进行计算" class="headerlink" title="Tensors张量，类似于Numpy里的ndarrays，同时Tensors可以使用GPU进行计算"></a>Tensors张量，类似于Numpy里的ndarrays，同时Tensors可以使用GPU进行计算</h4><ul><li>在开头加上from _<em>future_</em> import print_function这句之后，即使在python2.X，使用print就得像python3.X那样加括号使用python2.X中print不需要括号，而在python3.X中则需要。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><h4 id="构造一个5x3的矩阵，不初始化"><a href="#构造一个5x3的矩阵，不初始化" class="headerlink" title="构造一个5x3的矩阵，不初始化"></a>构造一个5x3的矩阵，不初始化</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=torch.empty(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><pre><code>tensor([[9.2755e-39, 8.4490e-39, 1.0286e-38],        [1.0102e-38, 1.0837e-38, 1.0286e-38],        [1.0653e-38, 1.0194e-38, 4.1328e-39],        [4.2245e-39, 4.2245e-39, 4.2245e-39],        [4.9592e-39, 9.1836e-39, 1.0561e-38]])</code></pre><h4 id="构造一个随机初始化的矩阵"><a href="#构造一个随机初始化的矩阵" class="headerlink" title="构造一个随机初始化的矩阵"></a>构造一个随机初始化的矩阵</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=torch.rand(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><pre><code>tensor([[0.9536, 0.5859, 0.3502],        [0.2301, 0.2587, 0.7727],        [0.3513, 0.1247, 0.0136],        [0.6168, 0.2126, 0.5314],        [0.8289, 0.0799, 0.9224]])</code></pre><h4 id="构造一个矩阵全为0，且数据类型为long"><a href="#构造一个矩阵全为0，且数据类型为long" class="headerlink" title="构造一个矩阵全为0，且数据类型为long"></a>构造一个矩阵全为0，且数据类型为long</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=torch.zeros(<span class="number">5</span>,<span class="number">3</span>,dtype=torch.long)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><pre><code>tensor([[0, 0, 0],        [0, 0, 0],        [0, 0, 0],        [0, 0, 0],        [0, 0, 0]])</code></pre><h4 id="构造一个张量，直接使用设定的数据"><a href="#构造一个张量，直接使用设定的数据" class="headerlink" title="构造一个张量，直接使用设定的数据"></a>构造一个张量，直接使用设定的数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=torch.tensor([<span class="number">5.5</span>,<span class="number">3</span>])</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><pre><code>tensor([5.5000, 3.0000])</code></pre><h4 id="创建一个张量（Tensor）基于已经存在的张量-这些方法将重用输入张量的属性，例如，-dtype，除非设置新的值进行覆盖"><a href="#创建一个张量（Tensor）基于已经存在的张量-这些方法将重用输入张量的属性，例如，-dtype，除非设置新的值进行覆盖" class="headerlink" title="创建一个张量（Tensor）基于已经存在的张量,这些方法将重用输入张量的属性，例如， dtype，除非设置新的值进行覆盖"></a>创建一个张量（Tensor）基于已经存在的张量,这些方法将重用输入张量的属性，例如， dtype，除非设置新的值进行覆盖</h4><ul><li>new_*方法来创建对象</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=x.new_ones(<span class="number">5</span>,<span class="number">3</span>,dtype=torch.double)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><pre><code>tensor([[1., 1., 1.],        [1., 1., 1.],        [1., 1., 1.],        [1., 1., 1.],        [1., 1., 1.]], dtype=torch.float64)</code></pre><ul><li>覆盖了dtype，但是对象的size还是相同的，只是值和类型发生了变化<ul><li>使用size方法与Numpy的shape属性返回的相同，张量也支持shape属性，后面会详细介绍</li><li>torch.Size 返回值是 tuple类型, 所以它支持tuple类型的所有操作.</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x=torch.randn_like(x,dtype=torch.float)</span><br><span class="line">print(x)</span><br><span class="line">print(x.size())</span><br></pre></td></tr></table></figure><pre><code>tensor([[ 0.3013,  0.9319, -1.0935],        [-1.9418,  0.3797,  1.4079],        [ 0.4928, -0.9644, -0.5722],        [-0.3585,  0.5682, -0.6689],        [-0.5044, -0.4755, -1.2299]])torch.Size([5, 3])</code></pre><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul><li>加法操作</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y=torch.rand(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line">print(x+y)</span><br></pre></td></tr></table></figure><pre><code>tensor([[ 0.7946,  1.0250, -0.8948],        [-1.2244,  0.6311,  1.6266],        [ 0.5959, -0.7320,  0.3882],        [-0.1263,  0.8522,  0.0948],        [-0.4211,  0.1972, -0.4704]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(torch.add(x,y))</span><br></pre></td></tr></table></figure><pre><code>tensor([[ 0.7946,  1.0250, -0.8948],        [-1.2244,  0.6311,  1.6266],        [ 0.5959, -0.7320,  0.3882],        [-0.1263,  0.8522,  0.0948],        [-0.4211,  0.1972, -0.4704]])</code></pre><h4 id="提供输出tensor作为参数"><a href="#提供输出tensor作为参数" class="headerlink" title="提供输出tensor作为参数"></a>提供输出tensor作为参数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result=torch.empty(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line">torch.add(x,y,out=result)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><pre><code>tensor([[ 0.7946,  1.0250, -0.8948],        [-1.2244,  0.6311,  1.6266],        [ 0.5959, -0.7320,  0.3882],        [-0.1263,  0.8522,  0.0948],        [-0.4211,  0.1972, -0.4704]])</code></pre><h4 id="任何-以-结尾的操作都会用结果替换原变量-例如-x-copy-y-x-t-都会改变x"><a href="#任何-以-结尾的操作都会用结果替换原变量-例如-x-copy-y-x-t-都会改变x" class="headerlink" title="任何 以 _ 结尾的操作都会用结果替换原变量. 例如: x.copy_(y), x.t_(), 都会改变x."></a>任何 以 _ 结尾的操作都会用结果替换原变量. 例如: x.copy_(y), x.t_(), 都会改变x.</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y.add_(x)</span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tensor([[ <span class="number">0.7946</span>,  <span class="number">1.0250</span>, <span class="number">-0.8948</span>],</span><br><span class="line">        [<span class="number">-1.2244</span>,  <span class="number">0.6311</span>,  <span class="number">1.6266</span>],</span><br><span class="line">        [ <span class="number">0.5959</span>, <span class="number">-0.7320</span>,  <span class="number">0.3882</span>],</span><br><span class="line">        [<span class="number">-0.1263</span>,  <span class="number">0.8522</span>,  <span class="number">0.0948</span>],</span><br><span class="line">        [<span class="number">-0.4211</span>,  <span class="number">0.1972</span>, <span class="number">-0.4704</span>]])</span><br></pre></td></tr></table></figure><h4 id="你可以使用与NumPy索引方式相同的操作来进行对张量的操作"><a href="#你可以使用与NumPy索引方式相同的操作来进行对张量的操作" class="headerlink" title="你可以使用与NumPy索引方式相同的操作来进行对张量的操作"></a>你可以使用与NumPy索引方式相同的操作来进行对张量的操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(x)</span><br><span class="line">print(x[:,<span class="number">1</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tensor([[ <span class="number">0.3013</span>,  <span class="number">0.9319</span>, <span class="number">-1.0935</span>],</span><br><span class="line">        [<span class="number">-1.9418</span>,  <span class="number">0.3797</span>,  <span class="number">1.4079</span>],</span><br><span class="line">        [ <span class="number">0.4928</span>, <span class="number">-0.9644</span>, <span class="number">-0.5722</span>],</span><br><span class="line">        [<span class="number">-0.3585</span>,  <span class="number">0.5682</span>, <span class="number">-0.6689</span>],</span><br><span class="line">        [<span class="number">-0.5044</span>, <span class="number">-0.4755</span>, <span class="number">-1.2299</span>]])</span><br><span class="line">tensor([ <span class="number">0.9319</span>,  <span class="number">0.3797</span>, <span class="number">-0.9644</span>,  <span class="number">0.5682</span>, <span class="number">-0.4755</span>])</span><br></pre></td></tr></table></figure><h4 id="torch-view-可以改变张量的维度和大小-与Numpy的reshape类似"><a href="#torch-view-可以改变张量的维度和大小-与Numpy的reshape类似" class="headerlink" title="torch.view: 可以改变张量的维度和大小, 与Numpy的reshape类似"></a>torch.view: 可以改变张量的维度和大小, 与Numpy的reshape类似</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x=torch.randn(<span class="number">4</span>,<span class="number">4</span>)</span><br><span class="line">print(x.size())</span><br><span class="line">y=x.view(<span class="number">16</span>)</span><br><span class="line"><span class="comment"># size -1 从其他维度推断</span></span><br><span class="line">z=x.view(<span class="number">-1</span>,<span class="number">8</span>)</span><br><span class="line">print(y.size())</span><br><span class="line">print(z.size())</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">torch.Size([<span class="number">4</span>, <span class="number">4</span>])</span><br><span class="line">torch.Size([<span class="number">16</span>])</span><br><span class="line">torch.Size([<span class="number">2</span>, <span class="number">8</span>])</span><br></pre></td></tr></table></figure><h4 id="如果你有只有一个元素的张量，使用-item-来得到Python数据类型的数值"><a href="#如果你有只有一个元素的张量，使用-item-来得到Python数据类型的数值" class="headerlink" title="如果你有只有一个元素的张量，使用.item()来得到Python数据类型的数值"></a>如果你有只有一个元素的张量，使用.item()来得到Python数据类型的数值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x=torch.randn(<span class="number">1</span>)</span><br><span class="line">print(x)</span><br><span class="line">print(x.item())</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tensor([<span class="number">0.0918</span>])</span><br><span class="line"><span class="number">0.0918206200003624</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前一直在看keras，但是看了之后，给我一种感觉就是：本来深度学习就已经够黑盒了，你再给我封装的这么死，我不想成为调包侠= =，然后Pytorch最近比较流行，在封装性上也没有keras那么死板，所以尝试学习一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="PyTorch" scheme="https://cblog.club/categories/PyTorch/"/>
    
    
      <category term="PyTorch" scheme="https://cblog.club/tags/PyTorch/"/>
    
      <category term="深度学习" scheme="https://cblog.club/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>347前K个高频元素</title>
    <link href="https://cblog.club/ck35tptbu0009u8g41klc2y4y.html"/>
    <id>https://cblog.club/ck35tptbu0009u8g41klc2y4y.html</id>
    <published>2019-11-18T12:06:04.000Z</published>
    <updated>2019-11-18T12:12:17.093Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p> 给定一个非空的整数数组，返回其中出现频率前 <strong>k</strong> 高的元素。 </p><a id="more"></a><blockquote><p><strong>示例 1:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>], k = <span class="number">2</span></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>], k = <span class="number">1</span></span><br><span class="line">输出: [<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>你可以假设给定的 <em>k</em> 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</li><li>你的算法的时间复杂度<strong>必须</strong>优于 O(<em>n</em> log <em>n</em>) , <em>n</em> 是数组的大小。</li></ul></blockquote><h6 id="解题思路：其实本题思路还是比较容易想到的，我们把key设计成数组中出现的元素值，value设置成其出现的次数，然后使用sort函数按照value的值进行降序排列，但是sort只能给顺序类容器排序，而map的元素是pair类型，所以我们将一个pair类型插入到数组中，然后自定义排序规则，最后在使用sort排序即可，这种自定义sort排序，还是要掌握一点，这样遇到和排序相关的题目就可以直接用即可（快排一定手撕一下）。"><a href="#解题思路：其实本题思路还是比较容易想到的，我们把key设计成数组中出现的元素值，value设置成其出现的次数，然后使用sort函数按照value的值进行降序排列，但是sort只能给顺序类容器排序，而map的元素是pair类型，所以我们将一个pair类型插入到数组中，然后自定义排序规则，最后在使用sort排序即可，这种自定义sort排序，还是要掌握一点，这样遇到和排序相关的题目就可以直接用即可（快排一定手撕一下）。" class="headerlink" title="解题思路：其实本题思路还是比较容易想到的，我们把key设计成数组中出现的元素值，value设置成其出现的次数，然后使用sort函数按照value的值进行降序排列，但是sort只能给顺序类容器排序，而map的元素是pair类型，所以我们将一个pair类型插入到数组中，然后自定义排序规则，最后在使用sort排序即可，这种自定义sort排序，还是要掌握一点，这样遇到和排序相关的题目就可以直接用即可（快排一定手撕一下）。"></a>解题思路：其实本题思路还是比较容易想到的，我们把key设计成数组中出现的元素值，value设置成其出现的次数，然后使用sort函数按照value的值进行降序排列，但是sort只能给顺序类容器排序，而map的元素是pair类型，所以我们将一个pair类型插入到数组中，然后自定义排序规则，最后在使用sort排序即可，这种自定义sort排序，还是要掌握一点，这样遇到和排序相关的题目就可以直接用即可（快排一定手撕一下）。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; topKFrequent(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;umap;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            umap[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;vec_umap(umap.begin(), umap.end());</span><br><span class="line">        sort(vec_umap.begin(), vec_umap.end(), </span><br><span class="line">        [](<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;x, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;y) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x.second &gt; y.second;</span><br><span class="line">    &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            result.push_back(vec_umap[i].first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt; 给定一个非空的整数数组，返回其中出现频率前 &lt;strong&gt;k&lt;/strong&gt; 高的元素。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>454四数相加II</title>
    <link href="https://cblog.club/ck35tptde000pu8g41r1kaiqe.html"/>
    <id>https://cblog.club/ck35tptde000pu8g41r1kaiqe.html</id>
    <published>2019-11-18T11:46:04.000Z</published>
    <updated>2019-11-18T12:04:23.762Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 <code>(i, j, k, l)</code> ，使得 <code>A[i] + B[j] + C[k] + D[l] = 0</code>。</p><p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。</p><a id="more"></a><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">A = [ <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">B = [<span class="number">-2</span>,<span class="number">-1</span>]</span><br><span class="line">C = [<span class="number">-1</span>, <span class="number">2</span>]</span><br><span class="line">D = [ <span class="number">0</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">两个元组如下:</span><br><span class="line"><span class="number">1.</span> (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>) -&gt; A[<span class="number">0</span>] + B[<span class="number">0</span>] + C[<span class="number">0</span>] + D[<span class="number">1</span>] = <span class="number">1</span> + (<span class="number">-2</span>) + (<span class="number">-1</span>) + <span class="number">2</span> = <span class="number">0</span></span><br><span class="line"><span class="number">2.</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>) -&gt; A[<span class="number">1</span>] + B[<span class="number">1</span>] + C[<span class="number">0</span>] + D[<span class="number">0</span>] = <span class="number">2</span> + (<span class="number">-1</span>) + (<span class="number">-1</span>) + <span class="number">0</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：本题刚开始就知道暴力破解肯定不对，O-N-4-的时间复杂度太大，所以就一直在找时间复杂度怎么才能够减小，怎么和hash结合，还是没有想到，有了别人的思路，如果分成两个双循环，我用unordered-multiset（元素可以重复出现），将A-B出现的结果存入其中，之后再双循环去找前者里是否有-C-D-的值，但是不幸的是，超时了，最后一组测试数据没有通过，怀疑是其查找的速度要比unordered-map慢，然后借鉴了别人的思路，将A和B加起来的结果放进一个hash-map中key就是A-B的和，value就是这个结果出现的次数，因为要计算最终的组合数，然后再双循环计算C-D，那么只要在之前的hash-map中去找一个数正好等于-（C-D）即可，这样的话，由于unordered-map的查找时间为O（1），那么其实时间就主要来源于两个双循环，那么时间复杂度就是O（n-2）-500x500-250000，还能接受。"><a href="#解题思路：本题刚开始就知道暴力破解肯定不对，O-N-4-的时间复杂度太大，所以就一直在找时间复杂度怎么才能够减小，怎么和hash结合，还是没有想到，有了别人的思路，如果分成两个双循环，我用unordered-multiset（元素可以重复出现），将A-B出现的结果存入其中，之后再双循环去找前者里是否有-C-D-的值，但是不幸的是，超时了，最后一组测试数据没有通过，怀疑是其查找的速度要比unordered-map慢，然后借鉴了别人的思路，将A和B加起来的结果放进一个hash-map中key就是A-B的和，value就是这个结果出现的次数，因为要计算最终的组合数，然后再双循环计算C-D，那么只要在之前的hash-map中去找一个数正好等于-（C-D）即可，这样的话，由于unordered-map的查找时间为O（1），那么其实时间就主要来源于两个双循环，那么时间复杂度就是O（n-2）-500x500-250000，还能接受。" class="headerlink" title="解题思路：本题刚开始就知道暴力破解肯定不对，O(N^4)的时间复杂度太大，所以就一直在找时间复杂度怎么才能够减小，怎么和hash结合，还是没有想到，有了别人的思路，如果分成两个双循环，我用unordered_multiset（元素可以重复出现），将A+B出现的结果存入其中，之后再双循环去找前者里是否有-(C+D)的值，但是不幸的是，超时了，最后一组测试数据没有通过，怀疑是其查找的速度要比unordered_map慢，然后借鉴了别人的思路，将A和B加起来的结果放进一个hash map中key就是A+B的和，value就是这个结果出现的次数，因为要计算最终的组合数，然后再双循环计算C+D，那么只要在之前的hash map中去找一个数正好等于-（C+D）即可，这样的话，由于unordered_map的查找时间为O（1），那么其实时间就主要来源于两个双循环，那么时间复杂度就是O（n^2）,500x500=250000，还能接受。"></a>解题思路：本题刚开始就知道暴力破解肯定不对，O(N^4)的时间复杂度太大，所以就一直在找时间复杂度怎么才能够减小，怎么和hash结合，还是没有想到，有了别人的思路，如果分成两个双循环，我用unordered_multiset（元素可以重复出现），将A+B出现的结果存入其中，之后再双循环去找前者里是否有-(C+D)的值，但是不幸的是，超时了，最后一组测试数据没有通过，怀疑是其查找的速度要比unordered_map慢，然后借鉴了别人的思路，将A和B加起来的结果放进一个hash map中key就是A+B的和，value就是这个结果出现的次数，因为要计算最终的组合数，然后再双循环计算C+D，那么只要在之前的hash map中去找一个数正好等于-（C+D）即可，这样的话，由于unordered_map的查找时间为O（1），那么其实时间就主要来源于两个双循环，那么时间复杂度就是O（n^2）,500x500=250000，还能接受。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; C, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; D)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;umap;</span><br><span class="line">        <span class="keyword">int</span> size=A.size();</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;size;j++)&#123;</span><br><span class="line">                umap[A[i]+B[j]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;size;j++)&#123;</span><br><span class="line">                <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator it=umap.find(-(C[i]+D[j]));</span><br><span class="line">                <span class="keyword">if</span>(it!=umap.end())res+=umap[-(C[i]+D[j])];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 &lt;code&gt;(i, j, k, l)&lt;/code&gt; ，使得 &lt;code&gt;A[i] + B[j] + C[k] + D[l] = 0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>652寻找重复的子树</title>
    <link href="https://cblog.club/ck35tptdy0015u8g47afx5srd.html"/>
    <id>https://cblog.club/ck35tptdy0015u8g47afx5srd.html</id>
    <published>2019-11-18T11:30:05.000Z</published>
    <updated>2019-11-18T11:44:16.095Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意<strong>一棵</strong>的根结点即可。</p><p>两棵树重复是指它们具有相同的结构以及相同的结点值。</p><a id="more"></a><blockquote><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> /   / \</span><br><span class="line">4   2   4</span><br><span class="line">   /</span><br><span class="line">  4</span><br></pre></td></tr></table></figure><p>下面是两个重复的子树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  2</span><br><span class="line"> /</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>因此，你需要以列表的形式返回上述重复子树的根结点。</p></blockquote><h6 id="解题思路：本题刚开始没有解出来，我刚开始的思路就是把键设计成一个数组，然后将其先序序列插入进去，最后再查找键，如果有和它一样的键的话，那么就是相同的子树，但是发现，这么想其实是错的，因为你先序的话，如果采用的不是递归的话，那么默认是不将空指针当作元素的，所以其实序列如果一样，但是树的结构可能是不一样的！然后借鉴了别人的想法，采用string的方法，将遍历序列转换成一个字符串，如果遇到空指针，那么就当作-，这样以来，采用递归遍历，将其遍历序列生成一个字符串，当作其键，然后value值设置成0，1，0代表没出现这个序列，1代表出现了这个序列。遍历到当前结点，只需要判断其遍历序列是否存在即可。"><a href="#解题思路：本题刚开始没有解出来，我刚开始的思路就是把键设计成一个数组，然后将其先序序列插入进去，最后再查找键，如果有和它一样的键的话，那么就是相同的子树，但是发现，这么想其实是错的，因为你先序的话，如果采用的不是递归的话，那么默认是不将空指针当作元素的，所以其实序列如果一样，但是树的结构可能是不一样的！然后借鉴了别人的想法，采用string的方法，将遍历序列转换成一个字符串，如果遇到空指针，那么就当作-，这样以来，采用递归遍历，将其遍历序列生成一个字符串，当作其键，然后value值设置成0，1，0代表没出现这个序列，1代表出现了这个序列。遍历到当前结点，只需要判断其遍历序列是否存在即可。" class="headerlink" title="解题思路：本题刚开始没有解出来，我刚开始的思路就是把键设计成一个数组，然后将其先序序列插入进去，最后再查找键，如果有和它一样的键的话，那么就是相同的子树，但是发现，这么想其实是错的，因为你先序的话，如果采用的不是递归的话，那么默认是不将空指针当作元素的，所以其实序列如果一样，但是树的结构可能是不一样的！然后借鉴了别人的想法，采用string的方法，将遍历序列转换成一个字符串，如果遇到空指针，那么就当作#，这样以来，采用递归遍历，将其遍历序列生成一个字符串，当作其键，然后value值设置成0，1，0代表没出现这个序列，1代表出现了这个序列。遍历到当前结点，只需要判断其遍历序列是否存在即可。"></a>解题思路：本题刚开始没有解出来，我刚开始的思路就是把键设计成一个数组，然后将其先序序列插入进去，最后再查找键，如果有和它一样的键的话，那么就是相同的子树，但是发现，这么想其实是错的，因为你先序的话，如果采用的不是递归的话，那么默认是不将空指针当作元素的，所以其实序列如果一样，但是树的结构可能是不一样的！然后借鉴了别人的想法，采用string的方法，将遍历序列转换成一个字符串，如果遇到空指针，那么就当作#，这样以来，采用递归遍历，将其遍历序列生成一个字符串，当作其键，然后value值设置成0，1，0代表没出现这个序列，1代表出现了这个序列。遍历到当前结点，只需要判断其遍历序列是否存在即可。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; findDuplicateSubtrees(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt;result;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;node_seq;</span><br><span class="line">        node_sequences(root,result,node_seq);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">node_sequences</span><span class="params">(TreeNode* root,<span class="built_in">vector</span>&lt;TreeNode*&gt;&amp;result,<span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&amp;node_seq)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="string">"#"</span>;</span><br><span class="line">        <span class="built_in">string</span> str=to_string(root-&gt;val)+node_sequences(root-&gt;left,result,node_seq)+node_sequences(root-&gt;right,result,node_seq);</span><br><span class="line">        <span class="keyword">if</span>(node_seq[str]==<span class="number">1</span>)result.push_back(root);</span><br><span class="line">        node_seq[str]++;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意&lt;strong&gt;一棵&lt;/strong&gt;的根结点即可。&lt;/p&gt;
&lt;p&gt;两棵树重复是指它们具有相同的结构以及相同的结点值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>理解LSTM</title>
    <link href="https://cblog.club/ck35tpteh001xu8g4b3sp2vol.html"/>
    <id>https://cblog.club/ck35tpteh001xu8g4b3sp2vol.html</id>
    <published>2019-11-17T01:38:27.000Z</published>
    <updated>2019-11-17T15:43:35.337Z</updated>
    
    <content type="html"><![CDATA[<p>SimpleRNN并不是keras中唯一的循环层，另外还有两个：LSTM和GRU。SimpleRNN最大的问题就是：在t时刻，理论上讲它能记住许多时间步之前见过的信息，但是实际上他是不可能学到这种长期依赖的。其原因就在于梯度消失问题，这一问题有点类似于在层数比较多的非循环网络（前馈网络）中观察到的效应：随着层数的增加，网络最终无法训练（具体原因没有深究，以后一定要看看论文），而LSTM和GRU就是为了解决SimpleRNN梯度消失这个问题设计的。<a id="more"></a></p><h4 id="LSTM-长短期记忆-算法的提出，是研究梯度消失的重要成果，-解决长依赖问题-。"><a href="#LSTM-长短期记忆-算法的提出，是研究梯度消失的重要成果，-解决长依赖问题-。" class="headerlink" title="LSTM(长短期记忆)算法的提出，是研究梯度消失的重要成果， 解决长依赖问题 。"></a>LSTM(长短期记忆)算法的提出，是研究梯度消失的重要成果， 解决长依赖问题 。</h4><p>所有循环神经网络都具有神经网络的重复模块链的形式。 在标准的RNN中，该重复模块将具有非常简单的结构，例如单个tanh层。标准的RNN网络如下图所示：</p><img src="/ck35tpteh001xu8g4b3sp2vol/1.png" class=""><p> LSTM也具有这种链式结构，但是它的重复单元不同于标准RNN网络里的单元只有一个网络层，它的内部有四个网络层。LSTMs的结构如下图所示：</p><img src="/ck35tpteh001xu8g4b3sp2vol/2.png" class=""><p> 在解释LSTMs的详细结构时先定义一下图中各个符号的含义，符号包括下面几种 </p><img src="/ck35tpteh001xu8g4b3sp2vol/3.jpg" class=""><p>图中黄色类似于CNN里的激活函数操作，粉色圆圈表示点操作，单箭头表示数据流向，箭头合并表示向量的合并（concat）操作，箭头分叉表示向量的拷贝操作 </p><h4 id="LSTM核心思想"><a href="#LSTM核心思想" class="headerlink" title="LSTM核心思想"></a>LSTM核心思想</h4><p>LSTM的关键在于细胞的状态(整个绿色的图表示的是一个cell)，和穿过细胞的那条水平线。</p><p>细胞状态类似于传送带。直接在整个链上运行，只有一些少量的线性交互。信息在上面流传保持不变会很容易。</p><img src="/ck35tpteh001xu8g4b3sp2vol/4.png" class=""><p>若只有上面的那条水平线是没办法实现添加或者删除信息的。而是通过一种叫做 门（gates） 的结构来实现的。</p><p>门 可以实现选择性地让信息通过，主要是通过一个 sigmoid 的神经层 和一个逐点相乘的操作来实现的。</p><img src="/ck35tpteh001xu8g4b3sp2vol/5.png" class=""><p>sigmoid 层输出（是一个向量）的每个元素都是一个在 0 和 1 之间的实数，表示让对应信息通过的权重（或者占比）。比如， 0 表示“不让任何信息通过”， 1 表示“让所有信息通过”。</p><p>LSTM通过三个这样的结构来实现信息的保护和控制。这三个门分别输入门、遗忘门和输出门。</p><h4 id="逐步理解LSTM"><a href="#逐步理解LSTM" class="headerlink" title="逐步理解LSTM"></a>逐步理解LSTM</h4><p>接下来通过三个门来逐步理解LSTM的原理</p><h5 id="遗忘门"><a href="#遗忘门" class="headerlink" title="遗忘门"></a>遗忘门</h5><p>在我们 LSTM 中的第一步是决定我们会从细胞状态中丢弃什么信息。这个决定通过一个称为忘记门层完成。该门会读取 h(t-1)和x(t)， 输出一个在 0到 1之间的数值即每个在细胞状态C(t-1)中的数字， 1 表示“完全保留”，0 表示“完全舍弃” 。</p><p>举个例子，在语言中我们基于已经看到的词来预测下一个词。在这个问题中，细胞状态可能包含当前主语的性别，因此正确的代词可以被选择出来。当我们看到新的主语，我们希望忘记旧的主语。 </p><img src="/ck35tpteh001xu8g4b3sp2vol/6.png" class=""><p> 其中h(t-1)表示的是上一个cell的输出，x(t)表示的是当前细胞的输入。σ表示sigmod函数。 </p><h5 id="输入门"><a href="#输入门" class="headerlink" title="输入门"></a>输入门</h5><p>下一步是决定给细胞状态添加哪些新的信息。这一步又分为两个步骤，首先，利用h(t-1)和x(t)通过一个称为输入门的操作来决定更新哪些信息。然后利用h(t-1)和x(t)通过一个tanh层得到新的候选细胞信息~Ct，这些信息可能会被更新到细胞信息中。这两步描述如下图所示：</p><img src="/ck35tpteh001xu8g4b3sp2vol/7.png" class=""><p> 下面将更新旧的细胞信息C(t-1)，变为新的细胞信息Ct。更新的规则就是通过忘记门选择忘记旧细胞信息的一部分，通过输入门选择添加候选细胞信息~Ct的一部分得到新的细胞信息Ct。更新操作如下图所示:</p><img src="/ck35tpteh001xu8g4b3sp2vol/8.png" class=""><h5 id="输出门"><a href="#输出门" class="headerlink" title="输出门"></a>输出门</h5><p>最终，我们需要确定输出什么值。这个输出将会基于我们的细胞状态，但是也是一个过滤后的版本。首先，我们运行一个 sigmoid 层来确定细胞状态的哪个部分将输出出去。接着，我们把细胞状态通过 tanh 进行处理（得到一个在 -1 到 1 之间的值）并将它和 sigmoid 门的输出相乘，最终我们仅仅会输出我们确定输出的那部分。</p><p> 还是拿语言模型来举例说明，在预测动词形式的时候，我们需要通过输入的主语是单数还是复数来推断输出门输出的预测动词是单数形式还是复数形式。 </p><img src="/ck35tpteh001xu8g4b3sp2vol/9.png" class=""><h4 id="LSTM变体"><a href="#LSTM变体" class="headerlink" title="LSTM变体"></a>LSTM变体</h4><p>下面主要讲一下其中比较著名的变种 GRU（Gated Recurrent Unit ），这是由 Cho, et al. (2014) 提出。在 GRU 中，如下图所示，只有两个门：重置门（reset gate）和更新门（update gate）。同时在这个结构中，把细胞状态和隐藏状态进行了合并。最后模型比标准的 LSTM 结构要简单，而且这个结构后来也非常流行。</p><img src="/ck35tpteh001xu8g4b3sp2vol/10.png" class=""><p> 其中，<strong>r</strong>表示重置门，<strong>t</strong>表示更新门。重置门决定是否将之前的状态忘记。(作用相当于合并了 LSTM 中的遗忘门和传入门）当<strong>r</strong>趋于0的时候，前一个时刻的状态信息 h(t-1)会被忘掉，隐藏状态^ht 会被重置为当前输入的信息。更新门决定是否要将隐藏状态更新为新的状态 ht(作用相当于 LSTM 中的输出门)</p><p>其中重置门为上图中前面那个门，决定了如何将新的输入信息与前面的记忆相结合。更新门为上图中后面那个门，定义了前面记忆保存到当前时间步的量。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SimpleRNN并不是keras中唯一的循环层，另外还有两个：LSTM和GRU。SimpleRNN最大的问题就是：在t时刻，理论上讲它能记住许多时间步之前见过的信息，但是实际上他是不可能学到这种长期依赖的。其原因就在于梯度消失问题，这一问题有点类似于在层数比较多的非循环网络（前馈网络）中观察到的效应：随着层数的增加，网络最终无法训练（具体原因没有深究，以后一定要看看论文），而LSTM和GRU就是为了解决SimpleRNN梯度消失这个问题设计的。
    
    </summary>
    
    
      <category term="深度学习" scheme="https://cblog.club/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="https://cblog.club/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>3无重复字符的最长子串</title>
    <link href="https://cblog.club/ck35tptdk000uu8g40zyk4p6t.html"/>
    <id>https://cblog.club/ck35tptdk000uu8g40zyk4p6t.html</id>
    <published>2019-11-16T15:17:37.000Z</published>
    <updated>2019-11-16T15:22:48.290Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><a id="more"></a><blockquote><p><strong>示例 1:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"abcabcbb"</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"abc"</span>，所以其长度为 <span class="number">3</span>。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"bbbbb"</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"b"</span>，所以其长度为 <span class="number">1</span>。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"pwwkew"</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"wke"</span>，所以其长度为 <span class="number">3</span>。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">"pwke"</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：本题一开始的思路就是循环当前元素，（但是没考虑到双循环，慢慢做，才发现需要-，因为我们只能确定以当前为首字母的字串的长度），然后就是使用哈希set，从当前元素向后循环，只要没出现在set中的，就插入到set中，并且使用count计数，如果见到了，就代表有重复，令count和max比较，确定是否更新，count置0，以此类推即可，但是要注意的是如果都没有见到重复元素，也要更新max值（这点忽视了，导致数据点没全部通过-）"><a href="#解题思路：本题一开始的思路就是循环当前元素，（但是没考虑到双循环，慢慢做，才发现需要-，因为我们只能确定以当前为首字母的字串的长度），然后就是使用哈希set，从当前元素向后循环，只要没出现在set中的，就插入到set中，并且使用count计数，如果见到了，就代表有重复，令count和max比较，确定是否更新，count置0，以此类推即可，但是要注意的是如果都没有见到重复元素，也要更新max值（这点忽视了，导致数据点没全部通过-）" class="headerlink" title="解题思路：本题一开始的思路就是循环当前元素，（但是没考虑到双循环，慢慢做，才发现需要= =，因为我们只能确定以当前为首字母的字串的长度），然后就是使用哈希set，从当前元素向后循环，只要没出现在set中的，就插入到set中，并且使用count计数，如果见到了，就代表有重复，令count和max比较，确定是否更新，count置0，以此类推即可，但是要注意的是如果都没有见到重复元素，也要更新max值（这点忽视了，导致数据点没全部通过~）"></a>解题思路：本题一开始的思路就是循环当前元素，（但是没考虑到双循环，慢慢做，才发现需要= =，因为我们只能确定以当前为首字母的字串的长度），然后就是使用哈希set，从当前元素向后循环，只要没出现在set中的，就插入到set中，并且使用count计数，如果见到了，就代表有重复，令count和max比较，确定是否更新，count置0，以此类推即可，但是要注意的是如果都没有见到重复元素，也要更新max值（这点忽视了，导致数据点没全部通过~）</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt;S_set;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=i;j&lt;s.size();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(S_set.count(s[j])==<span class="number">0</span>)count++; </span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(max&lt;count)max=count;</span><br><span class="line">                    count=<span class="number">0</span>;</span><br><span class="line">                    S_set.clear();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                S_set.insert(s[j]);</span><br><span class="line">                <span class="keyword">if</span>(j==s.size()<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(max&lt;count)max=count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的 &lt;strong&gt;最长子串&lt;/strong&gt; 的长度。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>771宝石与石头</title>
    <link href="https://cblog.club/ck35tpte1001bu8g4365k27a7.html"/>
    <id>https://cblog.club/ck35tpte1001bu8g4365k27a7.html</id>
    <published>2019-11-16T15:13:32.000Z</published>
    <updated>2019-11-17T01:32:43.727Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定字符串<code>J</code> 代表石头中宝石的类型，和字符串 <code>S</code>代表你拥有的石头。 <code>S</code> 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。</p><p><code>J</code> 中的字母不重复，<code>J</code> 和 <code>S</code>中的所有字符都是字母。字母区分大小写，因此<code>&quot;a&quot;</code>和<code>&quot;A&quot;</code>是不同类型的石头。</p><a id="more"></a><blockquote><p><strong>示例 1:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: J = <span class="string">"aA"</span>, S = <span class="string">"aAAbbbb"</span></span><br><span class="line">输出: <span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: J = <span class="string">"z"</span>, S = <span class="string">"ZZ"</span></span><br><span class="line">输出: <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><code>S</code> 和 <code>J</code> 最多含有50个字母。</li><li><code>J</code> 中的字符不重复。</li></ul></blockquote><h6 id="解题思路：本题是最基础的哈希集合的题目，一眼就可以看出来要使用哈希set，将J的插入到set中，然后循环S，再判断当前元素是否在J中即可，比较水。"><a href="#解题思路：本题是最基础的哈希集合的题目，一眼就可以看出来要使用哈希set，将J的插入到set中，然后循环S，再判断当前元素是否在J中即可，比较水。" class="headerlink" title="解题思路：本题是最基础的哈希集合的题目，一眼就可以看出来要使用哈希set，将J的插入到set中，然后循环S，再判断当前元素是否在J中即可，比较水。"></a>解题思路：本题是最基础的哈希集合的题目，一眼就可以看出来要使用哈希set，将J的插入到set中，然后循环S，再判断当前元素是否在J中即可，比较水。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(<span class="built_in">string</span> J, <span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt;J_set;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;J.size();i++)&#123;</span><br><span class="line">            J_set.insert(J[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(J_set.count(S[i])&gt;<span class="number">0</span>)count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;给定字符串&lt;code&gt;J&lt;/code&gt; 代表石头中宝石的类型，和字符串 &lt;code&gt;S&lt;/code&gt;代表你拥有的石头。 &lt;code&gt;S&lt;/code&gt; 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;J&lt;/code&gt; 中的字母不重复，&lt;code&gt;J&lt;/code&gt; 和 &lt;code&gt;S&lt;/code&gt;中的所有字符都是字母。字母区分大小写，因此&lt;code&gt;&amp;quot;a&amp;quot;&lt;/code&gt;和&lt;code&gt;&amp;quot;A&amp;quot;&lt;/code&gt;是不同类型的石头。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>36有效的数独</title>
    <link href="https://cblog.club/ck35tptcv000hu8g4at5o4ifl.html"/>
    <id>https://cblog.club/ck35tptcv000hu8g4at5o4ifl.html</id>
    <published>2019-11-15T13:37:43.000Z</published>
    <updated>2019-11-15T13:49:04.784Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>判断一个 9x9 的数独是否有效。只需要<strong>根据以下规则</strong>，验证已经填入的数字是否有效即可。</p><a id="more"></a><ol><li>数字 <code>1-9</code> 在每一行只能出现一次。</li><li>数字 <code>1-9</code> 在每一列只能出现一次。</li><li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。</li></ol><img src="/ck35tptcv000hu8g4at5o4ifl/1.jpg" class=""><p>上图是一个部分填充的有效的数独。</p><p>数独部分空格内已填入了数字，空白格用 <code>&#39;.&#39;</code> 表示。</p><blockquote><p><strong>示例 1:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [<span class="string">"5"</span>,<span class="string">"3"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"7"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],</span><br><span class="line">  [<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"1"</span>,<span class="string">"9"</span>,<span class="string">"5"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],</span><br><span class="line">  [<span class="string">"."</span>,<span class="string">"9"</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>],</span><br><span class="line">  [<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"3"</span>],</span><br><span class="line">  [<span class="string">"4"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"3"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"1"</span>],</span><br><span class="line">  [<span class="string">"7"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"2"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>],</span><br><span class="line">  [<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"2"</span>,<span class="string">"8"</span>,<span class="string">"."</span>],</span><br><span class="line">  [<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"4"</span>,<span class="string">"1"</span>,<span class="string">"9"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"5"</span>],</span><br><span class="line">  [<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"7"</span>,<span class="string">"9"</span>]</span><br><span class="line">]</span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [<span class="string">"8"</span>,<span class="string">"3"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"7"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],</span><br><span class="line">  [<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"1"</span>,<span class="string">"9"</span>,<span class="string">"5"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],</span><br><span class="line">  [<span class="string">"."</span>,<span class="string">"9"</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>],</span><br><span class="line">  [<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"3"</span>],</span><br><span class="line">  [<span class="string">"4"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"3"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"1"</span>],</span><br><span class="line">  [<span class="string">"7"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"2"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>],</span><br><span class="line">  [<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"2"</span>,<span class="string">"8"</span>,<span class="string">"."</span>],</span><br><span class="line">  [<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"4"</span>,<span class="string">"1"</span>,<span class="string">"9"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"5"</span>],</span><br><span class="line">  [<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"7"</span>,<span class="string">"9"</span>]</span><br><span class="line">]</span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">解释: 除了第一行的第一个数字从 <span class="number">5</span> 改为 <span class="number">8</span> 以外，空格内其他数字均与 示例<span class="number">1</span> 相同。</span><br><span class="line">     但由于位于左上角的 <span class="number">3</span>x3 宫内有两个 <span class="number">8</span> 存在, 因此这个数独是无效的。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>一个有效的数独（部分已被填充）不一定是可解的</li><li>只需要根据以上规则，验证已经填入的数字是否有效即可</li><li>给定数独序列只包含数字 <code>1-9</code> 和字符 <code>&#39;.&#39;</code> </li><li>给定数独永远是 <code>9x9</code> 形式的</li></ul></blockquote><h6 id="解题思路：本题刚开始，在思考怎么设计哈希映射中的键时，还是没有想好，但是总的思想就是判断三个，行，列，3x3的矩阵中不能有重复元素，将行号，列号，块号-通过行列求得，这个需要再思考-设计为键，只需要判断当前元素是否在判断的相应区域出现过，出现过就设置为1，如果判断其他的元素时，value为1，那么就代表当前区域出现过当前元素，不符合题目要求。"><a href="#解题思路：本题刚开始，在思考怎么设计哈希映射中的键时，还是没有想好，但是总的思想就是判断三个，行，列，3x3的矩阵中不能有重复元素，将行号，列号，块号-通过行列求得，这个需要再思考-设计为键，只需要判断当前元素是否在判断的相应区域出现过，出现过就设置为1，如果判断其他的元素时，value为1，那么就代表当前区域出现过当前元素，不符合题目要求。" class="headerlink" title="解题思路：本题刚开始，在思考怎么设计哈希映射中的键时，还是没有想好，但是总的思想就是判断三个，行，列，3x3的矩阵中不能有重复元素，将行号，列号，块号(通过行列求得，这个需要再思考= =)设计为键，只需要判断当前元素是否在判断的相应区域出现过，出现过就设置为1，如果判断其他的元素时，value为1，那么就代表当前区域出现过当前元素，不符合题目要求。"></a>解题思路：本题刚开始，在思考怎么设计哈希映射中的键时，还是没有想好，但是总的思想就是判断三个，行，列，3x3的矩阵中不能有重复元素，将行号，列号，块号(通过行列求得，这个需要再思考= =)设计为键，只需要判断当前元素是否在判断的相应区域出现过，出现过就设置为1，如果判断其他的元素时，value为1，那么就代表当前区域出现过当前元素，不符合题目要求。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;row(<span class="number">9</span>),col(<span class="number">9</span>),block(<span class="number">9</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">9</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">char</span> cur=board[i][j];</span><br><span class="line">                <span class="keyword">if</span>(cur==<span class="string">'.'</span>)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> block_index=(i/<span class="number">3</span>)*<span class="number">3</span>+(j/<span class="number">3</span>);</span><br><span class="line">                <span class="keyword">if</span>(row[i][cur]||col[j][cur]||block[block_index][cur])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                row[i][cur]=<span class="number">1</span>;</span><br><span class="line">                col[j][cur]=<span class="number">1</span>;</span><br><span class="line">                block[block_index][cur]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;判断一个 9x9 的数独是否有效。只需要&lt;strong&gt;根据以下规则&lt;/strong&gt;，验证已经填入的数字是否有效即可。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>49字母异位词分组</title>
    <link href="https://cblog.club/ck35tptdm000xu8g46a0deqrp.html"/>
    <id>https://cblog.club/ck35tptdm000xu8g46a0deqrp.html</id>
    <published>2019-11-15T13:28:41.000Z</published>
    <updated>2019-11-15T13:38:28.556Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p> 给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 </p><a id="more"></a><blockquote><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="string">"eat"</span>, <span class="string">"tea"</span>, <span class="string">"tan"</span>, <span class="string">"ate"</span>, <span class="string">"nat"</span>, <span class="string">"bat"</span>],</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="string">"ate"</span>,<span class="string">"eat"</span>,<span class="string">"tea"</span>],</span><br><span class="line">  [<span class="string">"nat"</span>,<span class="string">"tan"</span>],</span><br><span class="line">  [<span class="string">"bat"</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>所有输入均为小写字母。</li><li>不考虑答案输出的顺序。</li></ul></blockquote><h6 id="解题思路：本题得益于之前的设计键的思想（将不同字符串的映射转换成按照字母大小排序后的字符串，这样符合题目要求的字符串就会被分到同一组），得以有思路，第一次做的思路是，循环字符串，然后存到哈希映射中，同步存到哈希集合set中，这样便于循环将他们分组，刚开始看错了，以为是一个完整的字符串，还考虑用逗号分成一个个字符串，后来发现已经分好了-，第二个思路比较好，借鉴别人的，就是key是排序好的，value是一个字符数组，然后将整个字符数组直接插入到二维数组中即可，不再需要第一次的循环插入。"><a href="#解题思路：本题得益于之前的设计键的思想（将不同字符串的映射转换成按照字母大小排序后的字符串，这样符合题目要求的字符串就会被分到同一组），得以有思路，第一次做的思路是，循环字符串，然后存到哈希映射中，同步存到哈希集合set中，这样便于循环将他们分组，刚开始看错了，以为是一个完整的字符串，还考虑用逗号分成一个个字符串，后来发现已经分好了-，第二个思路比较好，借鉴别人的，就是key是排序好的，value是一个字符数组，然后将整个字符数组直接插入到二维数组中即可，不再需要第一次的循环插入。" class="headerlink" title="解题思路：本题得益于之前的设计键的思想（将不同字符串的映射转换成按照字母大小排序后的字符串，这样符合题目要求的字符串就会被分到同一组），得以有思路，第一次做的思路是，循环字符串，然后存到哈希映射中，同步存到哈希集合set中，这样便于循环将他们分组，刚开始看错了，以为是一个完整的字符串，还考虑用逗号分成一个个字符串，后来发现已经分好了= =，第二个思路比较好，借鉴别人的，就是key是排序好的，value是一个字符数组，然后将整个字符数组直接插入到二维数组中即可，不再需要第一次的循环插入。"></a>解题思路：本题得益于之前的设计键的思想（将不同字符串的映射转换成按照字母大小排序后的字符串，这样符合题目要求的字符串就会被分到同一组），得以有思路，第一次做的思路是，循环字符串，然后存到哈希映射中，同步存到哈希集合set中，这样便于循环将他们分组，刚开始看错了，以为是一个完整的字符串，还考虑用逗号分成一个个字符串，后来发现已经分好了= =，第二个思路比较好，借鉴别人的，就是key是排序好的，value是一个字符数组，然后将整个字符数组直接插入到二维数组中即可，不再需要第一次的循环插入。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;</span></span><br><span class="line"><span class="comment">        unordered_set&lt;string&gt;uset;</span></span><br><span class="line"><span class="comment">        unordered_multimap&lt;string,string&gt;umap;</span></span><br><span class="line"><span class="comment">        vector&lt;vector&lt;string&gt;&gt;result;</span></span><br><span class="line"><span class="comment">        vector&lt;string&gt;cur_str;</span></span><br><span class="line"><span class="comment">        for(auto str:strs)&#123;</span></span><br><span class="line"><span class="comment">            string temp=str;</span></span><br><span class="line"><span class="comment">            sort(temp.begin(),temp.end());</span></span><br><span class="line"><span class="comment">            umap.insert(&#123;str,temp&#125;);</span></span><br><span class="line"><span class="comment">            uset.insert(temp);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        for(auto it=uset.begin();it!=uset.end();it++)&#123;</span></span><br><span class="line"><span class="comment">            for(auto it_map=umap.begin();it_map!=umap.end();it_map++)&#123;</span></span><br><span class="line"><span class="comment">                if(*it==it_map-&gt;second)cur_str.push_back(it_map-&gt;first);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            result.push_back(cur_str);</span></span><br><span class="line"><span class="comment">            cur_str.clear();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return result;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupAnagrams(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;umap;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str:strs)&#123;</span><br><span class="line">            <span class="built_in">string</span> temp=str;</span><br><span class="line">            sort(temp.begin(),temp.end());</span><br><span class="line">            umap[temp].push_back(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> um:umap)&#123;</span><br><span class="line">            result.push_back(um.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt; 给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>RNN循环神经网络</title>
    <link href="https://cblog.club/ck35tpte7001mu8g4dax52lpw.html"/>
    <id>https://cblog.club/ck35tpte7001mu8g4dax52lpw.html</id>
    <published>2019-11-15T13:04:38.000Z</published>
    <updated>2019-11-15T13:25:36.771Z</updated>
    
    <content type="html"><![CDATA[<h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><ul><li>之前见过的神经网络都有一个特点，就是没有记忆，只能单独处理每个输入，在输入与输入之间没有保存任何状态，对于这种网络，要想处理数据点的序列或时间序列，需要向网络同时展示整个序列，即将序列转换成单个数据点，然后一次性处理，这种网络叫做前馈网络。</li></ul><a id="more"></a><ul><li>细想BP算法,CNN(卷积神经网络)我们会发现, 他们的输出都是只考虑前一个输入的影响而不考虑其它时刻输入的影响, 比如简单的猫,狗,手写数字等单个物体的识别具有较好的效果. 但是, 对于一些与时间先后有关的, 比如视频的下一时刻的预测,文档前后文内容的预测等, 这些算法的表现就不尽如人意了。因此, RNN就应运而生了。</li></ul><h5 id="循环神经网络"><a href="#循环神经网络" class="headerlink" title="循环神经网络"></a>循环神经网络</h5><ul><li><p>RNN是一种特殊的神经网络结构, 它是根据”人的认知是基于过往的经验和记忆”这一观点提出的. 它与DNN,CNN不同的是: 它不仅考虑前一时刻的输入,而且赋予了网络对前面的内容的一种’记忆’功能.</p></li><li><p>RNN之所以称为循环神经网路，即一个序列当前的输出与前面的输出也有关。具体的表现形式为网络会对前面的信息进行记忆并应用于当前输出的计算中，即隐藏层之间的节点不再无连接而是有连接的，并且隐藏层的输入不仅包括输入层的输出还包括上一时刻隐藏层的输出。</p></li><li><img src="/ck35tpte7001mu8g4dax52lpw/1.png" class=""></li></ul><h5 id="RNN前向传播"><a href="#RNN前向传播" class="headerlink" title="RNN前向传播"></a>RNN前向传播</h5><img src="/ck35tpte7001mu8g4dax52lpw/2.png" class=""><p>我们可以看到RNN层级结构较之于CNN来说比较简单, 它主要有<strong>输入层</strong>,<strong>Hidden Layer</strong>, <strong>输出层</strong>组成。</p><p>并且会发现在<strong>Hidden Layer</strong> 有一个箭头表示数据的循环更新, 这个就是实现时间记忆功能的方法。</p><img src="/ck35tpte7001mu8g4dax52lpw/3.png" class=""><p>所示为Hidden Layer的层级展开图. t-1, t, t+1表示时间序列. X表示输入的样本. St表示样本在时间t处的的记忆,<strong>St = f(W*St-1 +U*Xt)</strong>. W表示输入的权重, U表示此刻输入的样本的权重, V表示输出的样本权重。</p><p> 在t =1时刻, 一般初始化输入S0=0, 随机初始化W,U,V, 进行下面的公式计算:</p><img src="/ck35tpte7001mu8g4dax52lpw/4.png" class=""><p>其中,f和g均为激活函数. 其中f可以是tanh,relu,sigmoid等激活函数，g通常是softmax也可以是其他。</p><p>时间就向前推进，此时的状态s1作为时刻1的记忆状态将参与下一个时刻的预测活动，也就是:</p><img src="/ck35tpte7001mu8g4dax52lpw/5.png" class=""><p>以此类推, 可以得到最终的输出值为:</p><img src="/ck35tpte7001mu8g4dax52lpw/6.png" class=""><p><strong>注意</strong>: </p><ul><li><p>这里的<strong>W,U,V</strong>在每个时刻都是相等的(<strong>权重共享</strong>).</p></li><li><p>隐藏状态可以理解为: S=f(现有的输入+过去记忆总结) </p></li></ul><h5 id="RNN反向传播"><a href="#RNN反向传播" class="headerlink" title="RNN反向传播"></a>RNN反向传播</h5><p>我们介绍了RNN的前向传播的方式, 那么RNN的权重参数W,U,V都是怎么更新的呢?</p><p>每一次的输出值Ot都会产生一个误差值Et, 则总的误差可以表示为:<img src="/ck35tpte7001mu8g4dax52lpw/7.png" class=""></p><p>则损失函数可以使用交叉熵损失函数也可以使用平方误差损失函数。</p><p>由于每一步的输出不仅仅依赖当前步的网络，并且还需要前若干步网络的状态，那么这种BP改版的算法叫做Backpropagation Through Time(BPTT) , 也就是将输出端的误差值反向传递,运用梯度下降法进行更新。</p><p>也就是要求参数的梯度：</p><img src="/ck35tpte7001mu8g4dax52lpw/8.png" class=""><p>首先我们求解<strong>W的更新方法</strong>, 由前面的W的更新可以看出它是每个时刻的偏差的偏导数之和. </p><p> 在这里我们以 t = 3时刻为例, 根据链式求导法则可以得到t = 3时刻的偏导数为:</p><img src="/ck35tpte7001mu8g4dax52lpw/9.png" class=""><p>此时, 根据公式<img src="/ck35tpte7001mu8g4dax52lpw/10.png" class="">我们会发现, S3除了和W有关之外, 还和前一时刻S2有关。</p><p>对于S3直接展开得到下面的式子:</p><img src="/ck35tpte7001mu8g4dax52lpw/11.png" class=""><p>对于S2直接展开得到下面的式子:</p><img src="/ck35tpte7001mu8g4dax52lpw/12.png" class=""><p>对于S1直接展开得到下面的式子:</p><img src="/ck35tpte7001mu8g4dax52lpw/13.png" class=""><p>将上述三个式子合并得到:</p><img src="/ck35tpte7001mu8g4dax52lpw/14.png" class=""><p>这样就得到了公式:</p><img src="/ck35tpte7001mu8g4dax52lpw/15.png" class=""><p>这里要说明的是:<img src="/ck35tpte7001mu8g4dax52lpw/18.png" class="">表示的是S3对W直接求导, 不考虑S2的影响.(也就是例如y = f(x)*g(x)对x求导一样)</p><p>其次是对<strong>U的更新方法</strong>. 由于参数U求解和W求解类似,这里就不在赘述了,最终得到的具体的公式如下:</p><img src="/ck35tpte7001mu8g4dax52lpw/16.png" class=""><p>最后,给出<strong>V的更新公式</strong>(V只和输出O有关):</p><img src="/ck35tpte7001mu8g4dax52lpw/17.png" class="">]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;之前见过的神经网络都有一个特点，就是没有记忆，只能单独处理每个输入，在输入与输入之间没有保存任何状态，对于这种网络，要想处理数据点的序列或时间序列，需要向网络同时展示整个序列，即将序列转换成单个数据点，然后一次性处理，这种网络叫做前馈网络。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="深度学习" scheme="https://cblog.club/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="https://cblog.club/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>深度学习应用于文本和序列</title>
    <link href="https://cblog.club/ck35tpteb001su8g46kmr4dx0.html"/>
    <id>https://cblog.club/ck35tpteb001su8g46kmr4dx0.html</id>
    <published>2019-11-15T12:23:48.000Z</published>
    <updated>2019-11-15T13:25:52.960Z</updated>
    
    <content type="html"><![CDATA[<p>文本可以理解成单词序列、字符序列，序列又有时间序列和其他的一般序列。<a id="more"></a></p><p>处理序列的两种基本的深度学习模型</p><ul><li>循环神经网络（RNN）</li><li>一维卷积神经网络</li></ul><p>模型的输入不能是原始文本，他只能处理数值张量，所以要先将文本向量化</p><ul><li>文本向量化：将文本转换为数值张量的过程</li></ul><p>文本向量化的方法：</p><ul><li>将文本分割成单词，将每个单词转换为一个向量</li><li>将文本分割成字符，将每个字符转换为一个向量</li><li>提取单词或字符的n-gram，并将每个n-gram转换为一个向量。n-gram是多个连续单词或字符的集合（n-gram之间可重叠）</li></ul><p>将文本分解而成的单元（单词、字符、n-gram）叫做标记</p><p>将文本分解成标记的过程叫做分词</p> <img src="/ck35tpteb001su8g46kmr4dx0/fenci.png" class="" title="分词的过程"><p>将向量与标记关联的方法：</p><ul><li>对标记做one-hot编码</li><li>标记嵌入（token embedding），该方法通常只用于单词，叫做词嵌入（word embedding）<ul><li>one-hot得到的向量是二进制的、稀疏的（绝大部分元素都是0）、维数很高的（维数等于词表中单词个数）</li><li>词嵌入是低维的浮点数向量（密集向量），并且是从数据中学习得到的，常见的维度是256、512、1024（处理非常大的词表），而one-hot编码维度很高（20000或更高）</li><li><img src="/ck35tpteb001su8g46kmr4dx0/bianma.png" class="" title="不同方法编码对比"></li></ul></li></ul><p>获取词嵌入的方法：</p><ul><li>在完成主任务（比如情感预测、文档分类）的同时学习词嵌入，在这种情况下，一开始是随机的词向量，然后对这些词向量进行学习，其学习方式和学习神经网络权重相同</li><li>在不同与待解决的机器学习任务上预计算好词嵌入，然后将其加载到模型中，这些词嵌入叫做预训练词嵌入</li></ul><p>利用embedding层学习词嵌入（对应方法一）</p><ul><li><p>词嵌入的作用就是将人类语言映射到几何空间，词向量之间的几何关系表示这些词之间的语义关系。但由于语言是特定文化和特定环境的反射，所以要根据实际情况，不同问题不同分析。所以一个合理的做法就是对每个新任务都学习一个新的词嵌入空间，在keras框架中，我么只需要学习一个层的权重即可，即embedding层。</p><ul><li>embedding层：可以理解成一个字典，将整数序列（二维整数张量）（表示特定单词）映射为密集向量</li></ul><img src="/ck35tpteb001su8g46kmr4dx0/embedding.png" class="" title="embedding层作用过程"><ul><li>接收整数序列作为输入，然后在字典中查找整数，最后返回相关联的向量（返回的是一个三维浮点数张量）</li><li>将一个embedding层实例化时，他的权重（即标记向量的内部字典）初始时是随机的，在训练过程中利用反向传播来逐渐调节这些词向量，改变空间结构以便下游模型可以使用。</li></ul></li></ul><p>利用预训练的词嵌入</p><ul><li>背景：可用的训练数据很少，无法学习适合特定任务的词嵌入</li><li>从预计算的嵌入空间中加载嵌入张量，其原理与在图像分类中使用预训练的卷积神经网络是一样的<ul><li>原理：没有足够的数据来自己学习真正的特征，但是你需要的特征是非常通用的，很常见，那么就可以重复使用在其他问题上学到的特征</li></ul></li></ul><p>预计算的词嵌入数据库：</p><ul><li>word2vec</li><li>GloVe</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文本可以理解成单词序列、字符序列，序列又有时间序列和其他的一般序列。
    
    </summary>
    
    
      <category term="深度学习" scheme="https://cblog.club/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="https://cblog.club/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>219存在重复元素II</title>
    <link href="https://cblog.club/ck35tptbe0005u8g4c4ko7zeh.html"/>
    <id>https://cblog.club/ck35tptbe0005u8g4c4ko7zeh.html</id>
    <published>2019-11-14T14:30:04.000Z</published>
    <updated>2019-11-15T07:02:42.555Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p> 给定一个整数数组和一个整数 <em>k</em>，判断数组中是否存在两个不同的索引 <em>i</em> 和 <em>j</em>，使得 <strong>nums [i] = nums [j]</strong>，并且 <em>i</em> 和 <em>j</em> 的差的绝对值最大为 <em>k</em>。 </p><a id="more"></a><blockquote><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3,1], k = 3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,0,1,1], k = 1</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3,1,2,3], k = 2</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：本题思路比较清楚，就是使用哈希映射，当前元素值-gt-数组索引，循环当前数组，如果在哈希表中找到与当前元素相同的数，那么就计算他们之间的索引距离，如果小于等于给定K即可。"><a href="#解题思路：本题思路比较清楚，就是使用哈希映射，当前元素值-gt-数组索引，循环当前数组，如果在哈希表中找到与当前元素相同的数，那么就计算他们之间的索引距离，如果小于等于给定K即可。" class="headerlink" title="解题思路：本题思路比较清楚，就是使用哈希映射，当前元素值-&gt;数组索引，循环当前数组，如果在哈希表中找到与当前元素相同的数，那么就计算他们之间的索引距离，如果小于等于给定K即可。"></a>解题思路：本题思路比较清楚，就是使用哈希映射，当前元素值-&gt;数组索引，循环当前数组，如果在哈希表中找到与当前元素相同的数，那么就计算他们之间的索引距离，如果小于等于给定K即可。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_multimap</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;umap;</span><br><span class="line">        <span class="built_in">unordered_multimap</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">        <span class="keyword">int</span> cur_distance;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            it=umap.find(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(it!=umap.end())&#123;</span><br><span class="line">                cur_distance=i-(it-&gt;second);</span><br><span class="line">                <span class="keyword">if</span>(cur_distance&lt;=k)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            umap.insert(&#123;nums[i],i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt; 给定一个整数数组和一个整数 &lt;em&gt;k&lt;/em&gt;，判断数组中是否存在两个不同的索引 &lt;em&gt;i&lt;/em&gt; 和 &lt;em&gt;j&lt;/em&gt;，使得 &lt;strong&gt;nums [i] = nums [j]&lt;/strong&gt;，并且 &lt;em&gt;i&lt;/em&gt; 和 &lt;em&gt;j&lt;/em&gt; 的差的绝对值最大为 &lt;em&gt;k&lt;/em&gt;。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>350两个数组的交集II</title>
    <link href="https://cblog.club/ck35tptcq000fu8g44y2fdois.html"/>
    <id>https://cblog.club/ck35tptcq000fu8g44y2fdois.html</id>
    <published>2019-11-14T14:23:29.000Z</published>
    <updated>2019-11-14T14:35:03.314Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p> 给定两个数组，编写一个函数来计算它们的交集。<a id="more"></a> </p><blockquote><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">输出: [2,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">输出: [4,9]</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。</li><li>我们可以不考虑输出结果的顺序。</li></ul><p><strong><em>\</em>进阶:**</strong></p><ul><li>如果给定的数组已经排好序呢？你将如何优化你的算法？</li><li>如果 <em>nums1</em> 的大小比 <em>nums2</em> 小很多，哪种方法更优？</li><li>如果 <em>nums2</em> 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</li></ul></blockquote><h6 id="解题思路：本题和之前的求两个数组的交集不同，不同之处就在于，示例1，交集元素如果出现多次，那么结果中应该也是多次，处理操作就是使用unordered-multiset（允许重复元素出现）-那么就是如果当前元素在另一个哈希集合中找到，那么就将其插入到数组中，但是还要有一个操作，就是将另一个集合-中的当前元素删掉，因为有可能后边还会出现，造成结果错误。"><a href="#解题思路：本题和之前的求两个数组的交集不同，不同之处就在于，示例1，交集元素如果出现多次，那么结果中应该也是多次，处理操作就是使用unordered-multiset（允许重复元素出现）-那么就是如果当前元素在另一个哈希集合中找到，那么就将其插入到数组中，但是还要有一个操作，就是将另一个集合-中的当前元素删掉，因为有可能后边还会出现，造成结果错误。" class="headerlink" title="解题思路：本题和之前的求两个数组的交集不同，不同之处就在于，示例1，交集元素如果出现多次，那么结果中应该也是多次，处理操作就是使用unordered_multiset（允许重复元素出现）,那么就是如果当前元素在另一个哈希集合中找到，那么就将其插入到数组中，但是还要有一个操作，就是将另一个集合 中的当前元素删掉，因为有可能后边还会出现，造成结果错误。"></a>解题思路：本题和之前的求两个数组的交集不同，不同之处就在于，示例1，交集元素如果出现多次，那么结果中应该也是多次，处理操作就是使用unordered_multiset（允许重复元素出现）,那么就是如果当前元素在另一个哈希集合中找到，那么就将其插入到数组中，但是还要有一个操作，就是将另一个集合 中的当前元素删掉，因为有可能后边还会出现，造成结果错误。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersect(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        <span class="built_in">unordered_multiset</span>&lt;<span class="keyword">int</span>&gt;unums1;</span><br><span class="line">        <span class="built_in">unordered_multiset</span>&lt;<span class="keyword">int</span>&gt;unums2;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums1.size();i++)&#123;</span><br><span class="line">            unums1.insert(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums2.size();i++)&#123;</span><br><span class="line">            unums2.insert(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unordered_multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums1.size();i++)&#123;</span><br><span class="line">            it=unums2.find(nums1[i]);</span><br><span class="line">            <span class="keyword">if</span>(it!=unums2.end())&#123;</span><br><span class="line">                result.push_back(nums1[i]);</span><br><span class="line">                unums2.erase(it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt; 给定两个数组，编写一个函数来计算它们的交集。
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>lemon</title>
  
  <subtitle>一直在路上</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cblog.club/"/>
  <updated>2019-12-02T15:13:21.946Z</updated>
  <id>https://cblog.club/</id>
  
  <author>
    <name>lemon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>54螺旋矩阵</title>
    <link href="https://cblog.club/ck3okpvnb002nnsg4da1k92fy.html"/>
    <id>https://cblog.club/ck3okpvnb002nnsg4da1k92fy.html</id>
    <published>2019-12-02T15:11:45.000Z</published>
    <updated>2019-12-02T15:13:21.946Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定一个包含 <em>m</em> x <em>n</em> 个元素的矩阵（<em>m</em> 行, <em>n</em> 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。</p><a id="more"></a><blockquote><p><strong>示例 1:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line"> [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ],</span><br><span class="line"> [ <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ],</span><br><span class="line"> [ <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> ]</span><br><span class="line">]</span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">  [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]</span><br><span class="line">]</span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：本题算是面试中经常遇到的题目，所以再来做一遍，但是还是找BUG找了半天，所以说代码能力还是不过关，得加强。"><a href="#解题思路：本题算是面试中经常遇到的题目，所以再来做一遍，但是还是找BUG找了半天，所以说代码能力还是不过关，得加强。" class="headerlink" title="解题思路：本题算是面试中经常遇到的题目，所以再来做一遍，但是还是找BUG找了半天，所以说代码能力还是不过关，得加强。"></a>解题思路：本题算是面试中经常遇到的题目，所以再来做一遍，但是还是找BUG找了半天，所以说代码能力还是不过关，得加强。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; spiralOrder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line">        <span class="keyword">int</span> row=matrix.size();</span><br><span class="line">        <span class="comment">//矩阵为空</span></span><br><span class="line">        <span class="keyword">if</span>(row==<span class="number">0</span>)<span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">int</span> col=matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="comment">//获取最终数组要填充的个数</span></span><br><span class="line">        <span class="keyword">int</span> size=row*col;</span><br><span class="line">        <span class="comment">//定义四个方向</span></span><br><span class="line">        <span class="keyword">int</span> direct[<span class="number">2</span>][<span class="number">4</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> nextx,nexty,der,curx,cury;</span><br><span class="line">        <span class="comment">//定义当前位置和方向</span></span><br><span class="line">        curx=cury=der=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//直到填充完数组结束</span></span><br><span class="line">        <span class="keyword">while</span>(result.size()&lt;size)&#123;</span><br><span class="line">            <span class="comment">//如果当前元素没有访问过</span></span><br><span class="line">            <span class="keyword">if</span>(matrix[curx][cury]!=INT_MAX)&#123;</span><br><span class="line">                result.push_back(matrix[curx][cury]);</span><br><span class="line">                <span class="comment">//设置当前元素访问过</span></span><br><span class="line">                matrix[curx][cury]=INT_MAX;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取下一个元素</span></span><br><span class="line">            nextx=curx+direct[<span class="number">0</span>][der];</span><br><span class="line">            nexty=cury+direct[<span class="number">1</span>][der];</span><br><span class="line">            <span class="comment">//判断下一个元素是否符合要求（不越界，也没访问过）</span></span><br><span class="line">            <span class="keyword">if</span>(nextx&gt;=<span class="number">0</span>&amp;&amp;nextx&lt;row&amp;&amp;nexty&gt;=<span class="number">0</span>&amp;&amp;nexty&lt;col&amp;&amp;matrix[nextx][nexty]!=INT_MAX)&#123;</span><br><span class="line">                curx=nextx;</span><br><span class="line">                cury=nexty;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不符合要求，转向</span></span><br><span class="line">            <span class="keyword">else</span> der=(der+<span class="number">1</span>)%<span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;给定一个包含 &lt;em&gt;m&lt;/em&gt; x &lt;em&gt;n&lt;/em&gt; 个元素的矩阵（&lt;em&gt;m&lt;/em&gt; 行, &lt;em&gt;n&lt;/em&gt; 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>127单词接龙</title>
    <link href="https://cblog.club/ck3okpvkr0001nsg481no5bj8.html"/>
    <id>https://cblog.club/ck3okpvkr0001nsg481no5bj8.html</id>
    <published>2019-12-02T15:08:31.000Z</published>
    <updated>2019-12-02T15:10:58.383Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定两个单词（<em>beginWord</em> 和 <em>endWord*）和一个字典，找到从 *beginWord</em> 到 <em>endWord</em> 的最短转换序列的长度。转换需遵循如下规则：</p><ol><li>每次转换只能改变一个字母。</li><li>转换过程中的中间单词必须是字典中的单词。</li></ol><a id="more"></a><blockquote><p><strong>说明:</strong></p><ul><li>如果不存在这样的转换序列，返回 0。</li><li>所有单词具有相同的长度。</li><li>所有单词只由小写字母组成。</li><li>字典中不存在重复的单词。</li><li>你可以假设 <em>beginWord</em> 和 <em>endWord</em> 是非空的，且二者不相同。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord = <span class="string">"hit"</span>,</span><br><span class="line">endWord = <span class="string">"cog"</span>,</span><br><span class="line">wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>,<span class="string">"cog"</span>]</span><br><span class="line"></span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line"></span><br><span class="line">解释: 一个最短转换序列是 <span class="string">"hit"</span> -&gt; <span class="string">"hot"</span> -&gt; <span class="string">"dot"</span> -&gt; <span class="string">"dog"</span> -&gt; <span class="string">"cog"</span>,</span><br><span class="line">     返回它的长度 <span class="number">5</span>。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord = <span class="string">"hit"</span></span><br><span class="line">endWord = <span class="string">"cog"</span></span><br><span class="line">wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>]</span><br><span class="line"></span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">解释: endWord <span class="string">"cog"</span> 不在字典中，所以无法进行转换。</span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：本题和打开转盘锁一个套路，都是用BFS，但是本题花费了很长时间才做对，哎-，一言难尽"><a href="#解题思路：本题和打开转盘锁一个套路，都是用BFS，但是本题花费了很长时间才做对，哎-，一言难尽" class="headerlink" title="解题思路：本题和打开转盘锁一个套路，都是用BFS，但是本题花费了很长时间才做对，哎= =，一言难尽"></a>解题思路：本题和打开转盘锁一个套路，都是用BFS，但是本题花费了很长时间才做对，哎= =，一言难尽</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;wl;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;visited;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;wordList.size();i++)&#123;</span><br><span class="line">            wl.insert(wordList[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt;q;</span><br><span class="line">        q.push(beginWord);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size=q.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;size;k++)&#123;</span><br><span class="line">                <span class="built_in">string</span> cur=q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                visited.insert(cur);</span><br><span class="line">                <span class="keyword">if</span>(cur==endWord)<span class="keyword">return</span> result+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//每个字母有26个选择</span></span><br><span class="line">                <span class="built_in">string</span> alphbet=<span class="string">"abcdefghijklmnopqrstuvwxyz"</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;beginWord.size();i++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">char</span> c:alphbet)&#123;</span><br><span class="line">                        <span class="built_in">string</span> str=cur;</span><br><span class="line">                        str[i]=c;</span><br><span class="line">                        <span class="comment">//在字典中，并且还没有被访问过</span></span><br><span class="line">                        <span class="keyword">if</span>(wl.find(str)!=wl.end()&amp;&amp;visited.find(str)==visited.end())&#123;</span><br><span class="line">                            q.push(str);</span><br><span class="line">                            visited.insert(str);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;给定两个单词（&lt;em&gt;beginWord&lt;/em&gt; 和 &lt;em&gt;endWord*）和一个字典，找到从 *beginWord&lt;/em&gt; 到 &lt;em&gt;endWord&lt;/em&gt; 的最短转换序列的长度。转换需遵循如下规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每次转换只能改变一个字母。&lt;/li&gt;
&lt;li&gt;转换过程中的中间单词必须是字典中的单词。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="广度搜索" scheme="https://cblog.club/categories/leetcode/%E5%B9%BF%E5%BA%A6%E6%90%9C%E7%B4%A2/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="广度搜索" scheme="https://cblog.club/tags/%E5%B9%BF%E5%BA%A6%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>120三角形最小路径和</title>
    <link href="https://cblog.club/ck3okpvkw0004nsg4h8cseief.html"/>
    <id>https://cblog.club/ck3okpvkw0004nsg4h8cseief.html</id>
    <published>2019-12-01T14:25:48.000Z</published>
    <updated>2019-12-01T14:29:43.802Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p><a id="more"></a><blockquote><p>例如，给定三角形：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [<span class="number">2</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">   [<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>自顶向下的最小路径和为 <code>11</code>（即，<strong>2</strong> + <strong>3</strong> + <strong>5</strong> + <strong>1</strong> = 11）。</p><p><strong>说明：</strong></p><p>如果你可以只使用 <em>O</em>(<em>n</em>) 的额外空间（<em>n</em> 为三角形的总行数）来解决这个问题，那么你的算法会很加分</p></blockquote><h6 id="解题思路：本题一开始觉得很是简单，直接DP就行了，当前值由上一层的两个待选元素确定，但是访问越界问题，我找BUG找了好久-，所以在确定上一层的元素的时候，边界情况一定要搞清楚-（这一题O1的额外空间就可以了），还有就是像这种越界之后所用的值的方式，还是挺好的，值得借鉴。"><a href="#解题思路：本题一开始觉得很是简单，直接DP就行了，当前值由上一层的两个待选元素确定，但是访问越界问题，我找BUG找了好久-，所以在确定上一层的元素的时候，边界情况一定要搞清楚-（这一题O1的额外空间就可以了），还有就是像这种越界之后所用的值的方式，还是挺好的，值得借鉴。" class="headerlink" title="解题思路：本题一开始觉得很是简单，直接DP就行了，当前值由上一层的两个待选元素确定，但是访问越界问题，我找BUG找了好久= =，所以在确定上一层的元素的时候，边界情况一定要搞清楚= =（这一题O1的额外空间就可以了），还有就是像这种越界之后所用的值的方式，还是挺好的，值得借鉴。"></a>解题思路：本题一开始觉得很是简单，直接DP就行了，当前值由上一层的两个待选元素确定，但是访问越界问题，我找BUG找了好久= =，所以在确定上一层的元素的时候，边界情况一定要搞清楚= =（这一题O1的额外空间就可以了），还有就是像这种越界之后所用的值的方式，还是挺好的，值得借鉴。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row=triangle.size();</span><br><span class="line">        <span class="keyword">if</span>(row==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(row==<span class="number">1</span>)<span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> min_path=INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                <span class="comment">//上层相邻的，有两个待选</span></span><br><span class="line">                <span class="keyword">int</span> left,right;</span><br><span class="line">                left=(j&gt;<span class="number">0</span>)?triangle[i<span class="number">-1</span>][j<span class="number">-1</span>]:INT_MAX;</span><br><span class="line">                right=(i&gt;j)?triangle[i<span class="number">-1</span>][j]:INT_MAX;</span><br><span class="line">                triangle[i][j]+=min(left,right);</span><br><span class="line">                <span class="keyword">if</span>(i==row<span class="number">-1</span>&amp;&amp;min_path&gt;triangle[i][j])min_path=triangle[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min_path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/categories/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>221最大正方形</title>
    <link href="https://cblog.club/ck3okpvm4000qnsg44yx4es57.html"/>
    <id>https://cblog.club/ck3okpvm4000qnsg44yx4es57.html</id>
    <published>2019-12-01T14:19:38.000Z</published>
    <updated>2019-12-01T14:25:01.584Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p><a id="more"></a><blockquote><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：本题因为是求最优值问题，所以一般还是往动态规划上想，这一题dp-i-j-代表以-i-j-这个点为正方形的右下角坐标的正方形最大边长，这就要考虑三个位置，上方，左方，左上方，当前位置的dp值等于这三个中的最小值-1（其实这个原理，画图的话还是很牵强，并没有真正理解-），最后返回这些位置中最大的一个，注意只有一个元素的情况。"><a href="#解题思路：本题因为是求最优值问题，所以一般还是往动态规划上想，这一题dp-i-j-代表以-i-j-这个点为正方形的右下角坐标的正方形最大边长，这就要考虑三个位置，上方，左方，左上方，当前位置的dp值等于这三个中的最小值-1（其实这个原理，画图的话还是很牵强，并没有真正理解-），最后返回这些位置中最大的一个，注意只有一个元素的情况。" class="headerlink" title="解题思路：本题因为是求最优值问题，所以一般还是往动态规划上想，这一题dp[i] [j]代表以(i,j)这个点为正方形的右下角坐标的正方形最大边长，这就要考虑三个位置，上方，左方，左上方，当前位置的dp值等于这三个中的最小值+1（其实这个原理，画图的话还是很牵强，并没有真正理解= =），最后返回这些位置中最大的一个，注意只有一个元素的情况。"></a>解题思路：本题因为是求最优值问题，所以一般还是往动态规划上想，这一题dp[i] [j]代表以(i,j)这个点为正方形的右下角坐标的正方形最大边长，这就要考虑三个位置，上方，左方，左上方，当前位置的dp值等于这三个中的最小值+1（其实这个原理，画图的话还是很牵强，并没有真正理解= =），最后返回这些位置中最大的一个，注意只有一个元素的情况。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row=matrix.size();</span><br><span class="line">        <span class="keyword">if</span>(row==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col=matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;dp(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">if</span>(matrix[<span class="number">0</span>][<span class="number">0</span>]==<span class="string">'1'</span>)dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_res=dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                    <span class="comment">//三个位置 上  左  左上</span></span><br><span class="line">                    <span class="keyword">int</span> up,left,left_up;</span><br><span class="line">                    up=(i&gt;<span class="number">0</span>)?dp[i<span class="number">-1</span>][j]:<span class="number">0</span>;</span><br><span class="line">                    left=(j&gt;<span class="number">0</span>)?dp[i][j<span class="number">-1</span>]:<span class="number">0</span>;</span><br><span class="line">                    left_up=(i&gt;<span class="number">0</span>&amp;&amp;j&gt;<span class="number">0</span>)?dp[i<span class="number">-1</span>][j<span class="number">-1</span>]:<span class="number">0</span>;</span><br><span class="line">                    dp[i][j]=min(min(up,left),left_up)+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(max_res&lt;dp[i][j])max_res=dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_res*max_res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/categories/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>752打开转盘锁</title>
    <link href="https://cblog.club/ck3okpvo1003jnsg48inz0fow.html"/>
    <id>https://cblog.club/ck3okpvo1003jnsg48inz0fow.html</id>
    <published>2019-11-30T09:38:47.000Z</published>
    <updated>2019-11-30T09:45:19.642Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： <code>&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;</code> 。每个拨轮可以自由旋转：例如把 <code>&#39;9&#39;</code> 变为 <code>&#39;0&#39;</code>，<code>&#39;0&#39;</code> 变为 <code>&#39;9&#39;</code> 。每次旋转都只能旋转一个拨轮的一位数字。</p><p>锁的初始数字为 <code>&#39;0000&#39;</code> ，一个代表四个拨轮的数字的字符串。</p><p>列表 <code>deadends</code> 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p><p>字符串 <code>target</code> 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。</p><a id="more"></a><blockquote><p><strong>示例 1:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：deadends = [<span class="string">"0201"</span>,<span class="string">"0101"</span>,<span class="string">"0102"</span>,<span class="string">"1212"</span>,<span class="string">"2002"</span>], target = <span class="string">"0202"</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：</span><br><span class="line">可能的移动序列为 <span class="string">"0000"</span> -&gt; <span class="string">"1000"</span> -&gt; <span class="string">"1100"</span> -&gt; <span class="string">"1200"</span> -&gt; <span class="string">"1201"</span> -&gt; <span class="string">"1202"</span> -&gt; <span class="string">"0202"</span>。</span><br><span class="line">注意 <span class="string">"0000"</span> -&gt; <span class="string">"0001"</span> -&gt; <span class="string">"0002"</span> -&gt; <span class="string">"0102"</span> -&gt; <span class="string">"0202"</span> 这样的序列是不能解锁的，</span><br><span class="line">因为当拨动到 <span class="string">"0102"</span> 时这个锁就会被锁定。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: deadends = [<span class="string">"8888"</span>], target = <span class="string">"0009"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：</span><br><span class="line">把最后一位反向旋转一次即可 <span class="string">"0000"</span> -&gt; <span class="string">"0009"</span>。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: deadends = [<span class="string">"8887"</span>,<span class="string">"8889"</span>,<span class="string">"8878"</span>,<span class="string">"8898"</span>,<span class="string">"8788"</span>,<span class="string">"8988"</span>,<span class="string">"7888"</span>,<span class="string">"9888"</span>], target = <span class="string">"8888"</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：</span><br><span class="line">无法旋转到目标数字且不被锁定。</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: deadends = [<span class="string">"0000"</span>], target = <span class="string">"8888"</span></span><br><span class="line">输出：<span class="number">-1</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>死亡列表 <code>deadends</code> 的长度范围为 <code>[1, 500]</code>。</li><li>目标数字 <code>target</code> 不会在 <code>deadends</code> 之中。</li><li>每个 <code>deadends</code> 和 <code>target</code> 中的字符串的数字会在 10,000 个可能的情况 <code>&#39;0000&#39;</code> 到 <code>&#39;9999&#39;</code> 中产生。</li></ol></blockquote><h6 id="解题思路：这一题采用广度搜索（BFS），每一次的选择有八个，四个位置可以-1，也可以-1，但是要注意0和9之间的转换（这一点由于是借鉴别人的思路，所以没有被坑到，自己写的话极有可能会掉坑），然后每走完一层（这个走完一层，遍历的范围是0-当前队列的长度（不得不说巧妙，之前层次遍历就领略过，十分巧妙）），就要判断一下当前的值中有没有和target相等的（并且还不能在锁里边（锁在之前，先插入到unordered-set里，因为它实现使用的哈希表，所以时间很快（O1））），如果有，直接返回即可，没有的话，再次往下一层走，类似于层次遍历，每一层都是每一步的八个选择（当然，我们还需要使用一个unordered-set来去掉访问过的，这样剪枝，可以省掉一些时间）。"><a href="#解题思路：这一题采用广度搜索（BFS），每一次的选择有八个，四个位置可以-1，也可以-1，但是要注意0和9之间的转换（这一点由于是借鉴别人的思路，所以没有被坑到，自己写的话极有可能会掉坑），然后每走完一层（这个走完一层，遍历的范围是0-当前队列的长度（不得不说巧妙，之前层次遍历就领略过，十分巧妙）），就要判断一下当前的值中有没有和target相等的（并且还不能在锁里边（锁在之前，先插入到unordered-set里，因为它实现使用的哈希表，所以时间很快（O1））），如果有，直接返回即可，没有的话，再次往下一层走，类似于层次遍历，每一层都是每一步的八个选择（当然，我们还需要使用一个unordered-set来去掉访问过的，这样剪枝，可以省掉一些时间）。" class="headerlink" title="解题思路：这一题采用广度搜索（BFS），每一次的选择有八个，四个位置可以+1，也可以-1，但是要注意0和9之间的转换（这一点由于是借鉴别人的思路，所以没有被坑到，自己写的话极有可能会掉坑），然后每走完一层（这个走完一层，遍历的范围是0-当前队列的长度（不得不说巧妙，之前层次遍历就领略过，十分巧妙）），就要判断一下当前的值中有没有和target相等的（并且还不能在锁里边（锁在之前，先插入到unordered_set里，因为它实现使用的哈希表，所以时间很快（O1））），如果有，直接返回即可，没有的话，再次往下一层走，类似于层次遍历，每一层都是每一步的八个选择（当然，我们还需要使用一个unordered_set来去掉访问过的，这样剪枝，可以省掉一些时间）。"></a>解题思路：这一题采用广度搜索（BFS），每一次的选择有八个，四个位置可以+1，也可以-1，但是要注意0和9之间的转换（这一点由于是借鉴别人的思路，所以没有被坑到，自己写的话极有可能会掉坑），然后每走完一层（这个走完一层，遍历的范围是0-当前队列的长度（不得不说巧妙，之前层次遍历就领略过，十分巧妙）），就要判断一下当前的值中有没有和target相等的（并且还不能在锁里边（锁在之前，先插入到unordered_set里，因为它实现使用的哈希表，所以时间很快（O1））），如果有，直接返回即可，没有的话，再次往下一层走，类似于层次遍历，每一层都是每一步的八个选择（当然，我们还需要使用一个unordered_set来去掉访问过的，这样剪枝，可以省掉一些时间）。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">openLock</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; deadends, <span class="built_in">string</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;dead;</span><br><span class="line">        <span class="comment">//将锁的字符串插入到无序集合中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> d:deadends)&#123;</span><br><span class="line">            dead.insert(d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//"0000"是锁，目标值是锁，都不能解锁</span></span><br><span class="line">        <span class="keyword">if</span>(dead.find(target)!=dead.end()||dead.find(<span class="string">"0000"</span>)!=dead.end())<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;visited;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt;q;</span><br><span class="line">        <span class="keyword">int</span> layer=<span class="number">0</span>;</span><br><span class="line">        q.push(<span class="string">"0000"</span>);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size=q.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                <span class="built_in">string</span> cur_string=q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span>(cur_string==target)<span class="keyword">return</span> layer;</span><br><span class="line">                <span class="comment">//定义他的八个相邻的值(分别是四个位置+1和-1)</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)&#123;</span><br><span class="line">                    <span class="built_in">string</span> s1,s2;</span><br><span class="line">                    s1=s2=cur_string;</span><br><span class="line">                    s1[k]=(s1[k]==<span class="string">'9'</span>)?<span class="string">'0'</span>:s1[k]+<span class="number">1</span>;</span><br><span class="line">                    s2[k]=(s2[k]==<span class="string">'0'</span>)?<span class="string">'9'</span>:s2[k]<span class="number">-1</span>;</span><br><span class="line">                    <span class="comment">//接下来就是检查这两个字符串是否是目标字符串</span></span><br><span class="line">                    <span class="keyword">if</span>(dead.find(s1)==dead.end()&amp;&amp;visited.find(s1)==visited.end())&#123;</span><br><span class="line">                        q.push(s1);</span><br><span class="line">                        visited.insert(s1);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(dead.find(s2)==dead.end()&amp;&amp;visited.find(s2)==visited.end())&#123;</span><br><span class="line">                        q.push(s2);</span><br><span class="line">                        visited.insert(s2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            layer++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： &lt;code&gt;&amp;#39;0&amp;#39;, &amp;#39;1&amp;#39;, &amp;#39;2&amp;#39;, &amp;#39;3&amp;#39;, &amp;#39;4&amp;#39;, &amp;#39;5&amp;#39;, &amp;#39;6&amp;#39;, &amp;#39;7&amp;#39;, &amp;#39;8&amp;#39;, &amp;#39;9&amp;#39;&lt;/code&gt; 。每个拨轮可以自由旋转：例如把 &lt;code&gt;&amp;#39;9&amp;#39;&lt;/code&gt; 变为 &lt;code&gt;&amp;#39;0&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;0&amp;#39;&lt;/code&gt; 变为 &lt;code&gt;&amp;#39;9&amp;#39;&lt;/code&gt; 。每次旋转都只能旋转一个拨轮的一位数字。&lt;/p&gt;
&lt;p&gt;锁的初始数字为 &lt;code&gt;&amp;#39;0000&amp;#39;&lt;/code&gt; ，一个代表四个拨轮的数字的字符串。&lt;/p&gt;
&lt;p&gt;列表 &lt;code&gt;deadends&lt;/code&gt; 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。&lt;/p&gt;
&lt;p&gt;字符串 &lt;code&gt;target&lt;/code&gt; 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="广度搜索" scheme="https://cblog.club/categories/leetcode/%E5%B9%BF%E5%BA%A6%E6%90%9C%E7%B4%A2/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="广度搜索" scheme="https://cblog.club/tags/%E5%B9%BF%E5%BA%A6%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>133克隆图</title>
    <link href="https://cblog.club/ck3okpvkz0005nsg48ec0filr.html"/>
    <id>https://cblog.club/ck3okpvkz0005nsg48ec0filr.html</id>
    <published>2019-11-30T09:31:47.000Z</published>
    <updated>2019-11-30T09:38:26.855Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定无向<a href="https://baike.baidu.com/item/连通图/6460995?fr=aladdin" target="_blank" rel="noopener"><strong>连通</strong></a>图中一个节点的引用，返回该图的<a href="https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin" target="_blank" rel="noopener"><strong>深拷贝</strong></a>（克隆）。图中的每个节点都包含它的值 <code>val</code>（<code>Int</code>） 和其邻居的列表（<code>list[Node]</code>）。</p><a id="more"></a><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">&#123;<span class="string">"$id"</span>:<span class="string">"1"</span>,<span class="string">"neighbors"</span>:[&#123;<span class="string">"$id"</span>:<span class="string">"2"</span>,<span class="string">"neighbors"</span>:[&#123;<span class="string">"$ref"</span>:<span class="string">"1"</span>&#125;,&#123;<span class="string">"$id"</span>:<span class="string">"3"</span>,<span class="string">"neighbors"</span>:[&#123;<span class="string">"$ref"</span>:<span class="string">"2"</span>&#125;,&#123;<span class="string">"$id"</span>:<span class="string">"4"</span>,<span class="string">"neighbors"</span>:[&#123;<span class="string">"$ref"</span>:<span class="string">"3"</span>&#125;,&#123;<span class="string">"$ref"</span>:<span class="string">"1"</span>&#125;],<span class="string">"val"</span>:<span class="number">4</span>&#125;],<span class="string">"val"</span>:<span class="number">3</span>&#125;],<span class="string">"val"</span>:<span class="number">2</span>&#125;,&#123;<span class="string">"$ref"</span>:<span class="string">"4"</span>&#125;],<span class="string">"val"</span>:<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">节点 <span class="number">1</span> 的值是 <span class="number">1</span>，它有两个邻居：节点 <span class="number">2</span> 和 <span class="number">4</span> 。</span><br><span class="line">节点 <span class="number">2</span> 的值是 <span class="number">2</span>，它有两个邻居：节点 <span class="number">1</span> 和 <span class="number">3</span> 。</span><br><span class="line">节点 <span class="number">3</span> 的值是 <span class="number">3</span>，它有两个邻居：节点 <span class="number">2</span> 和 <span class="number">4</span> 。</span><br><span class="line">节点 <span class="number">4</span> 的值是 <span class="number">4</span>，它有两个邻居：节点 <span class="number">1</span> 和 <span class="number">3</span> 。</span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">节点数介于 <span class="number">1</span> 到 <span class="number">100</span> 之间。</span><br><span class="line">无向图是一个简单图，这意味着图中没有重复的边，也没有自环。</span><br><span class="line">由于图是无向的，如果节点 p 是节点 q 的邻居，那么节点 q 也必须是节点 p 的邻居。</span><br><span class="line">必须将给定节点的拷贝作为对克隆图的引用返回。</span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：本题一开始就想用BFS，但是不行，因为我们返回的是一个深拷贝，也就是说，改变这个拷贝的元素，原来的图是不会改变的！那这样，我使用普通的BFS，就会导致，我能把第一个结点搞定，但是他的邻居结点怎么搞定呢（没有存啊，可能这里描述的不清楚，还是亲身做一下才会有体会），所以为了解决这个问题，我们还要再使用hash-map来解决，主要思想就是，生成一个原来结点和新生成的节点的映射关系，那这样我在遍历的时候，就能将深拷贝的结点之间也建立相邻关系，这题的思路还是比较好的，借鉴别人的思想，所以自己一定要多体会，不然还是不会成为自己的东西。"><a href="#解题思路：本题一开始就想用BFS，但是不行，因为我们返回的是一个深拷贝，也就是说，改变这个拷贝的元素，原来的图是不会改变的！那这样，我使用普通的BFS，就会导致，我能把第一个结点搞定，但是他的邻居结点怎么搞定呢（没有存啊，可能这里描述的不清楚，还是亲身做一下才会有体会），所以为了解决这个问题，我们还要再使用hash-map来解决，主要思想就是，生成一个原来结点和新生成的节点的映射关系，那这样我在遍历的时候，就能将深拷贝的结点之间也建立相邻关系，这题的思路还是比较好的，借鉴别人的思想，所以自己一定要多体会，不然还是不会成为自己的东西。" class="headerlink" title="解题思路：本题一开始就想用BFS，但是不行，因为我们返回的是一个深拷贝，也就是说，改变这个拷贝的元素，原来的图是不会改变的！那这样，我使用普通的BFS，就会导致，我能把第一个结点搞定，但是他的邻居结点怎么搞定呢（没有存啊，可能这里描述的不清楚，还是亲身做一下才会有体会），所以为了解决这个问题，我们还要再使用hash map来解决，主要思想就是，生成一个原来结点和新生成的节点的映射关系，那这样我在遍历的时候，就能将深拷贝的结点之间也建立相邻关系，这题的思路还是比较好的，借鉴别人的思想，所以自己一定要多体会，不然还是不会成为自己的东西。"></a>解题思路：本题一开始就想用BFS，但是不行，因为我们返回的是一个深拷贝，也就是说，改变这个拷贝的元素，原来的图是不会改变的！那这样，我使用普通的BFS，就会导致，我能把第一个结点搞定，但是他的邻居结点怎么搞定呢（没有存啊，可能这里描述的不清楚，还是亲身做一下才会有体会），所以为了解决这个问题，我们还要再使用hash map来解决，主要思想就是，生成一个原来结点和新生成的节点的映射关系，那这样我在遍历的时候，就能将深拷贝的结点之间也建立相邻关系，这题的思路还是比较好的，借鉴别人的思想，所以自己一定要多体会，不然还是不会成为自己的东西。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node)<span class="keyword">return</span> node;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;Node*,Node*&gt;node_map;</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node*&gt;q;</span><br><span class="line">        q.push(node);</span><br><span class="line">        <span class="comment">//BFS遍历，生成一对一映射关系</span></span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            Node* cur_node=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="comment">//生成对应的新节点</span></span><br><span class="line">            Node* newnode=<span class="keyword">new</span> Node(cur_node-&gt;val,&#123;&#125;);</span><br><span class="line">            node_map.insert(&#123;cur_node,newnode&#125;);</span><br><span class="line">            <span class="comment">//遍历邻居</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cur_node-&gt;neighbors.size();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(node_map.find(cur_node-&gt;neighbors[i])==node_map.end())q.push(cur_node-&gt;neighbors[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将深拷贝的结点之间也建立相邻关系</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it=node_map.begin();it!=node_map.end();it++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;it-&gt;first-&gt;neighbors.size();i++)&#123;</span><br><span class="line">                it-&gt;second-&gt;neighbors.push_back(node_map.find(it-&gt;first-&gt;neighbors[i])-&gt;second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node_map.find(node)-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;给定无向&lt;a href=&quot;https://baike.baidu.com/item/连通图/6460995?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;连通&lt;/strong&gt;&lt;/a&gt;图中一个节点的引用，返回该图的&lt;a href=&quot;https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;深拷贝&lt;/strong&gt;&lt;/a&gt;（克隆）。图中的每个节点都包含它的值 &lt;code&gt;val&lt;/code&gt;（&lt;code&gt;Int&lt;/code&gt;） 和其邻居的列表（&lt;code&gt;list[Node]&lt;/code&gt;）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="广度搜索" scheme="https://cblog.club/categories/leetcode/%E5%B9%BF%E5%BA%A6%E6%90%9C%E7%B4%A2/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="广度搜索" scheme="https://cblog.club/tags/%E5%B9%BF%E5%BA%A6%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>494目标和</title>
    <link href="https://cblog.club/ck3okpvn00024nsg44sd0ecis.html"/>
    <id>https://cblog.club/ck3okpvn00024nsg44sd0ecis.html</id>
    <published>2019-11-30T09:26:47.000Z</published>
    <updated>2019-11-30T09:31:20.593Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 <code>+</code> 和 <code>-</code>。对于数组中的任意一个整数，你都可以从 <code>+</code> 或 <code>-</code>中选择一个符号添加在前面。</p><p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p><a id="more"></a><blockquote><p><strong>示例 1:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入: nums: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], S: <span class="number">3</span></span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line"><span class="number">-1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span> = <span class="number">3</span></span><br><span class="line">+<span class="number">1</span><span class="number">-1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span> = <span class="number">3</span></span><br><span class="line">+<span class="number">1</span>+<span class="number">1</span><span class="number">-1</span>+<span class="number">1</span>+<span class="number">1</span> = <span class="number">3</span></span><br><span class="line">+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span><span class="number">-1</span>+<span class="number">1</span> = <span class="number">3</span></span><br><span class="line">+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span><span class="number">-1</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">一共有<span class="number">5</span>种方法让最终目标和为<span class="number">3</span>。</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li>数组非空，且长度不会超过20。</li><li>初始的数组的和不会超过1000。</li><li>保证返回的最终结果能被32位整数存下。</li></ol></blockquote><h6 id="解题思路：本题算是比较简单的一题，主要思想就是DFS（说白了也就是递归），每次只有两个选择（当前数字是本身呢还是他的相反数），然后一直递归，直到长度和数组长度一致，在和S比较，如何条件就返回，然后DFS会遍历所有的结果，那么符合一个条件，result（返回值）就-1。"><a href="#解题思路：本题算是比较简单的一题，主要思想就是DFS（说白了也就是递归），每次只有两个选择（当前数字是本身呢还是他的相反数），然后一直递归，直到长度和数组长度一致，在和S比较，如何条件就返回，然后DFS会遍历所有的结果，那么符合一个条件，result（返回值）就-1。" class="headerlink" title="解题思路：本题算是比较简单的一题，主要思想就是DFS（说白了也就是递归），每次只有两个选择（当前数字是本身呢还是他的相反数），然后一直递归，直到长度和数组长度一致，在和S比较，如何条件就返回，然后DFS会遍历所有的结果，那么符合一个条件，result（返回值）就+1。"></a>解题思路：本题算是比较简单的一题，主要思想就是DFS（说白了也就是递归），每次只有两个选择（当前数字是本身呢还是他的相反数），然后一直递归，直到长度和数组长度一致，在和S比较，如何条件就返回，然后DFS会遍历所有的结果，那么符合一个条件，result（返回值）就+1。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        getResult(nums,<span class="number">0</span>,S);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getResult</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> count,<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> need_value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count==nums.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(need_value==<span class="number">0</span>)result++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//两种选择，+  -</span></span><br><span class="line">        <span class="comment">//第一种，选择本身</span></span><br><span class="line">        getResult(nums,count+<span class="number">1</span>,need_value-nums[count]);</span><br><span class="line">        <span class="comment">//第二种，选择相反数</span></span><br><span class="line">        getResult(nums,count+<span class="number">1</span>,need_value+nums[count]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 &lt;code&gt;+&lt;/code&gt; 和 &lt;code&gt;-&lt;/code&gt;。对于数组中的任意一个整数，你都可以从 &lt;code&gt;+&lt;/code&gt; 或 &lt;code&gt;-&lt;/code&gt;中选择一个符号添加在前面。&lt;/p&gt;
&lt;p&gt;返回可以使最终数组和为目标数 S 的所有添加符号的方法数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="深度搜索" scheme="https://cblog.club/categories/leetcode/%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="深度搜索" scheme="https://cblog.club/tags/%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>200岛屿数量</title>
    <link href="https://cblog.club/ck3okpvlz000mnsg49kix2wrg.html"/>
    <id>https://cblog.club/ck3okpvlz000mnsg49kix2wrg.html</id>
    <published>2019-11-30T01:58:53.000Z</published>
    <updated>2019-11-30T02:01:50.837Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p><a id="more"></a><blockquote><p>示例 1:</p><p>输入:<br>11110<br>11010<br>11000<br>00000</p><p>输出: 1<br>示例 2:</p><p>输入:<br>11000<br>11000<br>00100<br>00011</p><p>输出: 3</p></blockquote><h6 id="解题思路：本题主要思路就是两个，一个是DFS一个是BFS，两个都可以。但是一定要记录下走过的位置，这里可以不用再声明一个数组用于记录走过的位置，可以将走过的置为’2’，然后遍历，统计1的个就行。"><a href="#解题思路：本题主要思路就是两个，一个是DFS一个是BFS，两个都可以。但是一定要记录下走过的位置，这里可以不用再声明一个数组用于记录走过的位置，可以将走过的置为’2’，然后遍历，统计1的个就行。" class="headerlink" title="解题思路：本题主要思路就是两个，一个是DFS一个是BFS，两个都可以。但是一定要记录下走过的位置，这里可以不用再声明一个数组用于记录走过的位置，可以将走过的置为’2’，然后遍历，统计1的个就行。"></a>解题思路：本题主要思路就是两个，一个是DFS一个是BFS，两个都可以。但是一定要记录下走过的位置，这里可以不用再声明一个数组用于记录走过的位置，可以将走过的置为’2’，然后遍历，统计1的个就行。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;</span></span><br><span class="line"><span class="comment">        int result=0;</span></span><br><span class="line"><span class="comment">        int row=grid.size();</span></span><br><span class="line"><span class="comment">        if(row==0)return result;</span></span><br><span class="line"><span class="comment">        int col=grid[0].size();</span></span><br><span class="line"><span class="comment">        for(int i=0;i&lt;row;i++)&#123;</span></span><br><span class="line"><span class="comment">            for(int j=0;j&lt;col;j++)&#123;</span></span><br><span class="line"><span class="comment">                if(grid[i][j]=='1')&#123;</span></span><br><span class="line"><span class="comment">                    dfs(grid,i,j);</span></span><br><span class="line"><span class="comment">                    result++;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return result;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid,int i,int j)&#123;</span></span><br><span class="line"><span class="comment">        //越界</span></span><br><span class="line"><span class="comment">        if(i&lt;0||i&gt;=grid.size()||j&lt;0||j&gt;=grid[0].size())return;</span></span><br><span class="line"><span class="comment">        //走到水或者是走过的</span></span><br><span class="line"><span class="comment">        if(grid[i][j]=='0'||grid[i][j]=='2')return;</span></span><br><span class="line"><span class="comment">        //代表走过了</span></span><br><span class="line"><span class="comment">        grid[i][j]='2';</span></span><br><span class="line"><span class="comment">        //定义四个方向</span></span><br><span class="line"><span class="comment">        int nexti,nextj;</span></span><br><span class="line"><span class="comment">        int direct[2][4]=&#123;&#123;-1,0,1,0&#125;,&#123;0,1,0,-1&#125;&#125;;</span></span><br><span class="line"><span class="comment">        for(int k=0;k&lt;4;k++)&#123;</span></span><br><span class="line"><span class="comment">            nexti=i+direct[0][k];</span></span><br><span class="line"><span class="comment">            nextj=j+direct[1][k];</span></span><br><span class="line"><span class="comment">            dfs(grid,nexti,nextj);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row=grid.size();</span><br><span class="line">        <span class="keyword">if</span>(row==<span class="number">0</span>)<span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">int</span> col=grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                    bfs(grid,i,j);</span><br><span class="line">                    result++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;q;</span><br><span class="line">        q.push(&#123;i,j&#125;);</span><br><span class="line">        grid[i][j]=<span class="string">'2'</span>;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;pos;</span><br><span class="line">        <span class="keyword">int</span> nexti,nextj;</span><br><span class="line">        <span class="keyword">int</span> direct[<span class="number">2</span>][<span class="number">4</span>]=&#123;&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            pos=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="comment">//定义四个方向</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)&#123;</span><br><span class="line">                nexti=pos.first+direct[<span class="number">0</span>][k];</span><br><span class="line">                nextj=pos.second+direct[<span class="number">1</span>][k];</span><br><span class="line">                <span class="keyword">if</span>(nexti&gt;=<span class="number">0</span>&amp;&amp;nexti&lt;grid.size()&amp;&amp;nextj&gt;=<span class="number">0</span>&amp;&amp;nextj&lt;grid[<span class="number">0</span>].size()&amp;&amp;grid[nexti][nextj]!=<span class="string">'2'</span>&amp;&amp;grid[nexti][nextj]!=<span class="string">'0'</span>)&#123;</span><br><span class="line">                    q.push(&#123;nexti,nextj&#125;);</span><br><span class="line">                    grid[nexti][nextj]=<span class="string">'2'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="深度搜索" scheme="https://cblog.club/categories/leetcode/%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2/"/>
    
      <category term="广度搜索" scheme="https://cblog.club/categories/leetcode/%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2/%E5%B9%BF%E5%BA%A6%E6%90%9C%E7%B4%A2/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="广度搜索" scheme="https://cblog.club/tags/%E5%B9%BF%E5%BA%A6%E6%90%9C%E7%B4%A2/"/>
    
      <category term="深度搜索" scheme="https://cblog.club/tags/%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>542之01矩阵</title>
    <link href="https://cblog.club/ck3okpvnn002vnsg4790kfsn3.html"/>
    <id>https://cblog.club/ck3okpvnn002vnsg4790kfsn3.html</id>
    <published>2019-11-30T01:50:31.000Z</published>
    <updated>2019-11-30T01:58:28.972Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。两个相邻元素间的距离为 1 。</p><a id="more"></a><blockquote><p>示例 1:<br>输入:</p><p>0 0 0<br>0 1 0<br>0 0 0<br>输出:</p><p>0 0 0<br>0 1 0<br>0 0 0<br>示例 2:<br>输入:</p><p>0 0 0<br>0 1 0<br>1 1 1<br>输出:</p><p>0 0 0<br>0 1 0<br>1 2 1<br>注意:</p><p>给定矩阵的元素个数不超过 10000。<br>给定矩阵中至少有一个元素是 0。<br>矩阵中的元素只在四个方向上相邻: 上、下、左、右。</p></blockquote><h6 id="解题思路：本题算是比较好的题目了，刚开始使用深度搜索-DFS-，发现超时了-（还没想出优化的方法），然后借鉴了一些想法，发现其实还有DP这一条路走，但是这题的DP还是比较特别的，要循环两次，因为dp-i-j-需要上下左右四个方向的值，但是一次循环只能获取两个方向，比如先从上到下，再从左到右，这样就可以用左边元素和上边元素（因为这两个已经有值了），然后后再从下到上，从右到左，这样右边和下边也有值（这样四个方向都兼顾到了），左后遍历完，输出数组即可。考虑完DP，又看到有BFS可以用，但是需要优化，他是先将所有的0元素入队列，然后从这些0元素向外扩展（很棒，不需要对于所有的元素都使用BFS），然后再将相邻位置-1和当前位置值比较，选择小的即可。"><a href="#解题思路：本题算是比较好的题目了，刚开始使用深度搜索-DFS-，发现超时了-（还没想出优化的方法），然后借鉴了一些想法，发现其实还有DP这一条路走，但是这题的DP还是比较特别的，要循环两次，因为dp-i-j-需要上下左右四个方向的值，但是一次循环只能获取两个方向，比如先从上到下，再从左到右，这样就可以用左边元素和上边元素（因为这两个已经有值了），然后后再从下到上，从右到左，这样右边和下边也有值（这样四个方向都兼顾到了），左后遍历完，输出数组即可。考虑完DP，又看到有BFS可以用，但是需要优化，他是先将所有的0元素入队列，然后从这些0元素向外扩展（很棒，不需要对于所有的元素都使用BFS），然后再将相邻位置-1和当前位置值比较，选择小的即可。" class="headerlink" title="解题思路：本题算是比较好的题目了，刚开始使用深度搜索(DFS)，发现超时了= =（还没想出优化的方法），然后借鉴了一些想法，发现其实还有DP这一条路走，但是这题的DP还是比较特别的，要循环两次，因为dp[i] [j]需要上下左右四个方向的值，但是一次循环只能获取两个方向，比如先从上到下，再从左到右，这样就可以用左边元素和上边元素（因为这两个已经有值了），然后后再从下到上，从右到左，这样右边和下边也有值（这样四个方向都兼顾到了），左后遍历完，输出数组即可。考虑完DP，又看到有BFS可以用，但是需要优化，他是先将所有的0元素入队列，然后从这些0元素向外扩展（很棒，不需要对于所有的元素都使用BFS），然后再将相邻位置+1和当前位置值比较，选择小的即可。"></a>解题思路：本题算是比较好的题目了，刚开始使用深度搜索(DFS)，发现超时了= =（还没想出优化的方法），然后借鉴了一些想法，发现其实还有DP这一条路走，但是这题的DP还是比较特别的，要循环两次，因为dp[i] [j]需要上下左右四个方向的值，但是一次循环只能获取两个方向，比如先从上到下，再从左到右，这样就可以用左边元素和上边元素（因为这两个已经有值了），然后后再从下到上，从右到左，这样右边和下边也有值（这样四个方向都兼顾到了），左后遍历完，输出数组即可。考虑完DP，又看到有BFS可以用，但是需要优化，他是先将所有的0元素入队列，然后从这些0元素向外扩展（很棒，不需要对于所有的元素都使用BFS），然后再将相邻位置+1和当前位置值比较，选择小的即可。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">DFS超时~~~~~~= =！</span></span><br><span class="line"><span class="comment">#define MAX 100000;</span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span></span><br><span class="line"><span class="comment">        vector&lt;vector&lt;int&gt;&gt;result(matrix.size(),vector&lt;int&gt;(matrix[0].size()));</span></span><br><span class="line"><span class="comment">        if(matrix.size()==0||matrix[0].size()==0)return result;</span></span><br><span class="line"><span class="comment">        for(int i=0;i&lt;matrix.size();i++)&#123;</span></span><br><span class="line"><span class="comment">            for(int j=0;j&lt;matrix[0].size();j++)&#123;</span></span><br><span class="line"><span class="comment">                result[i][j]=getMin(matrix,result,i,j,0);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return result;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    int getMin(vector&lt;vector&lt;int&gt;&gt;&amp; matrix,vector&lt;vector&lt;int&gt;&gt;&amp;result,int i,int j,int count)&#123;</span></span><br><span class="line"><span class="comment">        int row,col;</span></span><br><span class="line"><span class="comment">        row=matrix.size();</span></span><br><span class="line"><span class="comment">        col=matrix[0].size();</span></span><br><span class="line"><span class="comment">        //当前位置越界</span></span><br><span class="line"><span class="comment">        if(i&lt;0||i&gt;=row||j&lt;0||j&gt;=col||matrix[i][j]==99999)return MAX;</span></span><br><span class="line"><span class="comment">        if(matrix[i][j]==0)return count;</span></span><br><span class="line"><span class="comment">        matrix[i][j]=99999;</span></span><br><span class="line"><span class="comment">        int up=getMin(matrix,result,i-1,j,count+1);</span></span><br><span class="line"><span class="comment">        int down=getMin(matrix,result,i+1,j,count+1);</span></span><br><span class="line"><span class="comment">        int left=getMin(matrix,result,i,j-1,count+1);</span></span><br><span class="line"><span class="comment">        int right=getMin(matrix,result,i,j+1,count+1);</span></span><br><span class="line"><span class="comment">        matrix[i][j]=1;</span></span><br><span class="line"><span class="comment">        int min_value=min(up,down);</span></span><br><span class="line"><span class="comment">        min_value=min(min_value,left);</span></span><br><span class="line"><span class="comment">        min_value=min(min_value,right);</span></span><br><span class="line"><span class="comment">        return min_value;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span></span><br><span class="line"><span class="comment">        vector&lt;vector&lt;int&gt;&gt;dp(matrix.size(),vector&lt;int&gt;(matrix[0].size(),999999));</span></span><br><span class="line"><span class="comment">        int row=matrix.size();</span></span><br><span class="line"><span class="comment">        int col=matrix[0].size();</span></span><br><span class="line"><span class="comment">        if(row==0||col==0)return dp;</span></span><br><span class="line"><span class="comment">        //从上到下 从左到右遍历，这样就可以根据左边和上边 更新值</span></span><br><span class="line"><span class="comment">        for(int i=0;i&lt;row;i++)&#123;</span></span><br><span class="line"><span class="comment">            for(int j=0;j&lt;col;j++)&#123;</span></span><br><span class="line"><span class="comment">                if(matrix[i][j]==0)dp[i][j]=0;</span></span><br><span class="line"><span class="comment">                else&#123;</span></span><br><span class="line"><span class="comment">                    if(i&gt;0)dp[i][j]=min(dp[i][j],dp[i-1][j]+1);</span></span><br><span class="line"><span class="comment">                    if(j&gt;0)dp[i][j]=min(dp[i][j],dp[i][j-1]+1);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        //从下到上 从右到左遍历，这样就可以根据右边和下边 更新值，这样就满足了四个方向</span></span><br><span class="line"><span class="comment">        for(int i=row-1;i&gt;=0;i--)&#123;</span></span><br><span class="line"><span class="comment">            for(int j=col-1;j&gt;=0;j--)&#123;</span></span><br><span class="line"><span class="comment">                if(i&lt;row-1)dp[i][j]=min(dp[i][j],dp[i+1][j]+1);</span></span><br><span class="line"><span class="comment">                if(j&lt;col-1)dp[i][j]=min(dp[i][j],dp[i][j+1]+1);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return dp;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//其实感觉这一题还是用动态规划做比较好，并不是很经典的广度和深度搜索题目</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; updateMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span>)<span class="keyword">return</span> matrix;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;result(matrix.size(),<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(matrix[<span class="number">0</span>].size(),INT_MAX));</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix.size();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;matrix[<span class="number">0</span>].size();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                    result[i][j]=<span class="number">0</span>;</span><br><span class="line">                    q.push(&#123;i,j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nexti,nextj;</span><br><span class="line">        <span class="keyword">int</span> direct[<span class="number">2</span>][<span class="number">4</span>]=&#123;&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;cur;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            cur=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="comment">//定义四个方向</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)&#123;</span><br><span class="line">                nexti=cur.first+direct[<span class="number">0</span>][k];</span><br><span class="line">                nextj=cur.second+direct[<span class="number">1</span>][k];</span><br><span class="line">                <span class="keyword">if</span>(nexti&gt;=<span class="number">0</span>&amp;&amp;nexti&lt;matrix.size()&amp;&amp;nextj&gt;=<span class="number">0</span>&amp;&amp;nextj&lt;matrix[<span class="number">0</span>].size())&#123;</span><br><span class="line">                    <span class="keyword">if</span>(result[nexti][nextj]&gt;result[cur.first][cur.second]+<span class="number">1</span>)&#123;</span><br><span class="line">                        result[nexti][nextj]=result[cur.first][cur.second]+<span class="number">1</span>;</span><br><span class="line">                        q.push(&#123;nexti,nextj&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。两个相邻元素间的距离为 1 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/categories/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="广度搜索" scheme="https://cblog.club/categories/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%B9%BF%E5%BA%A6%E6%90%9C%E7%B4%A2/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="广度搜索" scheme="https://cblog.club/tags/%E5%B9%BF%E5%BA%A6%E6%90%9C%E7%B4%A2/"/>
    
      <category term="动态规划" scheme="https://cblog.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>动态规划之团灭股票买卖</title>
    <link href="https://cblog.club/ck3okpvph005tnsg4beb15guo.html"/>
    <id>https://cblog.club/ck3okpvph005tnsg4beb15guo.html</id>
    <published>2019-11-28T11:53:17.000Z</published>
    <updated>2019-11-28T12:55:43.913Z</updated>
    
    <content type="html"><![CDATA[<p>今天看了一篇讲解动态规划关于leetcode上的所有股票买卖相关的文章，感觉受益挺多，其实做这种题目真的是需要套路，最好能总结出适应这类题目的套路，省时省力。</p><a id="more"></a><h3 id="团灭-LeetCode-股票买卖问题"><a href="#团灭-LeetCode-股票买卖问题" class="headerlink" title="团灭 LeetCode 股票买卖问题"></a>团灭 LeetCode 股票买卖问题</h3><p>leetcode上有很多的关于这种股票买卖的问题，主要解法就是动态规划，所以还是有必要整理一下，看的别人的文章，觉得不过，特此记录，分享一下。大佬的公众号是 labuladong ~，感谢！</p><!--more--><p>为什么别人能写出这么诡异却又高效的解法呢？因为这类问题是有框架的，但是人家不会告诉你的，因为一旦告诉你，你十分钟就学会了，该算法题就不再神秘，变得不堪一击了。</p><p>本文就来告诉你处理这类问题的框架，拒绝奇技淫巧，稳扎稳打，以不变应万变。</p><p>这 6 道题目是有共性的，本文通过对第四道题的分析，逐步解决所有问题。因为第四题是一个最泛化的形式，其他的问题都是这个形式的简化。看下题目：</p><img src="/ck3okpvph005tnsg4beb15guo/image-20191128143819251.png" class=""><p>第一题是只进行一次交易，相当于 k = 1；第二题是不限交易次数，相当于 k = +infinity（正无穷）；第三题是只进行 2 次交易，相当于 k = 2；剩下两道也是不限交易次数，但是加了交易「冷冻期」和「手续费」的额外条件，其实就是第二题的变种，都很容易处理。</p><h4 id="穷举框架"><a href="#穷举框架" class="headerlink" title="穷举框架"></a>穷举框架</h4><p>看看总共有几种「状态」，再找出每个「状态」对应的「选择」。我们要穷举所有「状态」，穷举的目的是根据对应的「选择」更新状态。看图，就是这个意思。</p><img src="/ck3okpvph005tnsg4beb15guo/image-20191128144537139.png" class=""><p>具体到当前问题，每天都有三种「选择」：买入、卖出、无操作，我们用 buy, sell, rest 表示这三种选择。</p><p>但问题是，并不是每天都可以任意选择这三种选择的，因为 sell 必须在 buy 之后，buy 必须在 sell 之后（第一次除外）。那么 rest 操作还应该分两种状态，一种是 buy 之后的 rest（持有了股票），一种是 sell 之后的 rest（没有持有股票）。而且别忘了，我们还有交易次数 k 的限制，就是说你 buy 还只能在 k &gt; 0 的前提下操作。</p><p>很复杂对吧，不要怕，我们现在的目的只是穷举，你有再多的状态，老夫要做的就是一把梭全部列举出来。这个问题的「状态」有三个，第一个是天数，第二个是当天允许交易的最大次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨用 1 表示持有，0 表示没有持有）。</p><p>我们用一个三维数组 dp 就可以装下这几种状态的全部组合，用 for 循环就能完成穷举：</p><img src="/ck3okpvph005tnsg4beb15guo/image-20191128144806036.png" class=""><p>而且我们可以用自然语言描述出每一个状态的含义，比如说 dp[3] [2] [1] 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 dp[2] [3] [0] 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。很容易理解，对吧？</p><p>我们想求的最终答案是 dp[n - 1] [K] [0]，即最后一天，最多允许 K 次交易，所能获取的最大利润。读者可能问为什么不是 dp[n - 1] [K] [1]？因为 [1] 代表手上还持有股票，[0] 表示手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。</p><p>记住如何解释「状态」，一旦你觉得哪里不好理解，把它翻译成自然语言就容易理解了。</p><h4 id="状态转转移框架"><a href="#状态转转移框架" class="headerlink" title="状态转转移框架"></a>状态转转移框架</h4><p>现在，我们完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。</p><p>因为我们的选择是 buy, sell, rest，而这些选择是和「持有状态」相关的，所以只看「持有状态」，可以画个状态转移图。</p><img src="/ck3okpvph005tnsg4beb15guo/image-20191128145559395.png" class=""><p>通过这个图可以很清楚地看到，每种状态（0 和 1）是如何转移而来的。根据这个图，我们来写一下状态转移方程：</p><img src="/ck3okpvph005tnsg4beb15guo/image-20191128150207736.png" class=""><p>这个解释应该很清楚了，如果 buy，就要从利润中减去 prices[i]，如果 sell，就要给利润增加 prices[i]。今天的最大利润就是这两种可能选择中较大的那个。而且注意 k 的限制，我们在选择 buy 的时候，把最大交易数 k 减小了 1，很好理解吧，当然你也可以在 sell 的时候减 1，一样的。</p><p>现在，我们已经完成了动态规划中最困难的一步：状态转移方程。如果之前的内容你都可以理解，那么你已经可以秒杀所有问题了，只要套这个框架就行了。不过还差最后一点点，就是定义 base case，即最简单的情况。</p><ul><li>这四种基础的状态一定要书记</li></ul><img src="/ck3okpvph005tnsg4beb15guo/image-20191128150439641.png" class=""><p>把上面的状态转移方程总结一下：</p><ul><li>尤其注意这里的K-1，理解的话，可以这么理解，我前一天的最多允许买卖次数一定比今天的要少一，不然不允许买了。（你得允许买啊，卖是肯定允许卖的，因为你买了，才算一次交易，买了就算是这次交易的结束）</li><li><img src="/ck3okpvph005tnsg4beb15guo/image-20191128150453711.png" class=""></li></ul><p>读者可能会问，这个数组索引是 -1 怎么编程表示出来呢，负无穷怎么表示呢？这都是细节问题，有很多方法实现。现在整体框架已经完成，下面开始具体化。</p><h4 id="秒杀题目"><a href="#秒杀题目" class="headerlink" title="秒杀题目"></a>秒杀题目</h4><h6 id="第一题（也是最简单的问题）K-1（只允许买卖一次）"><a href="#第一题（也是最简单的问题）K-1（只允许买卖一次）" class="headerlink" title="第一题（也是最简单的问题）K=1（只允许买卖一次）"></a>第一题（也是最简单的问题）K=1（只允许买卖一次）</h6><p>直接套状态转移方程，根据 base case，可以做一些化简：</p><img src="/ck3okpvph005tnsg4beb15guo/image-20191128151020149.png" class=""><p> 直接翻译成代码： 注意，这里的dp[i-1] [0] [0]始终都是0，所以对base case条件一定要熟悉</p><img src="/ck3okpvph005tnsg4beb15guo/image-20191128151034429.png" class=""><p>显然 i = 0 时 dp[i-1] 是不合法的。这是因为我们没有对 i 的 base case 进行处理。那就简单粗暴地处理一下：</p><img src="/ck3okpvph005tnsg4beb15guo/image-20191128151049279.png" class=""><p>第一题就解决了，但是这样处理 base case 很麻烦，而且注意一下状态转移方程，新状态只和相邻的一个状态有关，其实不用整个 dp 数组，只需要两个变量储存所需的状态就足够了，这样可以把空间复杂度降到 O(1):</p><img src="/ck3okpvph005tnsg4beb15guo/image-20191128155307100.png" class=""><p>两种方式都是一样的，不过这种编程方法简洁很多。但是如果没有前面状态转移方程的引导，是肯定看不懂的。后续的题目，我主要写这种空间复杂度 O(1) 的解法。</p><h6 id="第二题，k-infinity"><a href="#第二题，k-infinity" class="headerlink" title="第二题，k+infinity"></a>第二题，k+infinity</h6><p>如果 k 为正无穷，那么就可以认为 k 和 k - 1 是一样的。可以这样改写框架：</p><img src="/ck3okpvph005tnsg4beb15guo/image-20191128155423626.png" class=""><p>直接改写代码即可</p><img src="/ck3okpvph005tnsg4beb15guo/image-20191128155439697.png" class=""><h6 id="第三题-，K-2"><a href="#第三题-，K-2" class="headerlink" title="第三题 ，K=2"></a>第三题 ，K=2</h6><p>k = 2 和前面题目的情况稍微不同，因为上面的情况都和 k 的关系不太大。要么 k 是正无穷，状态转移和 k 没关系了；要么 k = 1，跟 k = 0 这个 base case 挨得近，最后也被消掉了。</p><p>这道题 k = 2 和后面要讲的 k 是任意正整数的情况中，对 k 的处理就凸显出来了。我们直接写代码，边写边分析原因。</p><img src="/ck3okpvph005tnsg4beb15guo/image-20191128161938577.png" class=""><p>为什么错误？我这不是照着状态转移方程写的吗？</p><p>还记得前面总结的「穷举框架」吗？就在强调必须穷举所有状态。其实我们之前的解法，都在穷举所有状态，只是之前的题目中 k 都被化简掉了，所以没有对 k 的穷举。比如说第一题，k = 1：</p><img src="/ck3okpvph005tnsg4beb15guo/image-20191128162117417.png" class=""><p>这道题由于没有消掉 k 的影响，所以必须要用 for 循环对 k 进行穷举才是正确的：</p><img src="/ck3okpvph005tnsg4beb15guo/image-20191128162145459.png" class=""><p>如果你不理解，可以返回第一点「穷举框架」重新阅读体会一下。</p><p>第二种解法：因为这里 k 取值范围比较小，所以也可以不用 for 循环，直接把 k = 1 和 2 的情况手动列举出来也是一样的：</p><img src="/ck3okpvph005tnsg4beb15guo/image-20191128162159691.png" class=""><h6 id="第四题，K-any-integer-（这一题刚开始觉得很简单，但是不然！-）"><a href="#第四题，K-any-integer-（这一题刚开始觉得很简单，但是不然！-）" class="headerlink" title="第四题，K=any integer （这一题刚开始觉得很简单，但是不然！= =）"></a>第四题，K=any integer （这一题刚开始觉得很简单，但是不然！= =）</h6><p>这题和 k = 2 没啥区别，可以直接套上一题的第一个解法。但是提交之后会出现一个超内存的错误，原来是传入的 k 值可以任意大，导致 dp 数组太大了。现在想想，交易次数 k 最多能有多大呢？</p><p>一次交易由买入和卖出构成，至少需要两天。所以说有效的限制次数 k 应该不超过 n/2，如果超过，就没有约束作用了，相当于 k = +infinity（巧妙之处啊）。这种情况是之前解决过的。</p><p>直接把之前的代码重用：</p><img src="/ck3okpvph005tnsg4beb15guo/image-20191128143819251.png" class=""><h6 id="第五题-k-infinity-cooldown-冷冻期"><a href="#第五题-k-infinity-cooldown-冷冻期" class="headerlink" title="第五题 k=infinity+cooldown(冷冻期)"></a>第五题 k=infinity+cooldown(冷冻期)</h6><p>每次 sell 之后要等一天才能继续交易。只要把这个特点融入上一题的状态转移方程即可：</p><img src="/ck3okpvph005tnsg4beb15guo/image-20191128172040462.png" class=""> <p>直接翻译成代码即可：</p><img src="/ck3okpvph005tnsg4beb15guo/image-20191128172102201.png" class=""><p>但是我还是不习惯用这种形式，用常规DP数组，会比较清晰一点，要注意，碰到边界，我就带进去比较就行了</p><img src="/ck3okpvph005tnsg4beb15guo/image-20191128172151101.png" class=""><h6 id="第六题-k-infinity-and-with-feee"><a href="#第六题-k-infinity-and-with-feee" class="headerlink" title="第六题 k=infinity and with feee"></a>第六题 k=infinity and with feee</h6><p>每次交易要支付手续费，只要把手续费从利润中减去即可：</p><img src="/ck3okpvph005tnsg4beb15guo/image-20191128172829422.png" class=""><p>直接翻译成代码即可：</p><img src="/ck3okpvph005tnsg4beb15guo/image-20191128172847687.png" class=""><h4 id="哇咔咔，至此，所有股票买卖问题都解决了，虽然说这是针对这一类问题，但是还是可以引发一些思考，就是状态是怎么转移的，也可以在其他题目上进行套用，试试看。"><a href="#哇咔咔，至此，所有股票买卖问题都解决了，虽然说这是针对这一类问题，但是还是可以引发一些思考，就是状态是怎么转移的，也可以在其他题目上进行套用，试试看。" class="headerlink" title="哇咔咔，至此，所有股票买卖问题都解决了，虽然说这是针对这一类问题，但是还是可以引发一些思考，就是状态是怎么转移的，也可以在其他题目上进行套用，试试看。"></a>哇咔咔，至此，所有股票买卖问题都解决了，虽然说这是针对这一类问题，但是还是可以引发一些思考，就是状态是怎么转移的，也可以在其他题目上进行套用，试试看。</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天看了一篇讲解动态规划关于leetcode上的所有股票买卖相关的文章，感觉受益挺多，其实做这种题目真的是需要套路，最好能总结出适应这类题目的套路，省时省力。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/categories/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>103二叉树的锯齿形层次遍历</title>
    <link href="https://cblog.club/ck3okpvkl0000nsg4f7foavn1.html"/>
    <id>https://cblog.club/ck3okpvkl0000nsg4f7foavn1.html</id>
    <published>2019-11-27T14:54:36.000Z</published>
    <updated>2019-11-27T14:57:58.825Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p> 给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 </p><a id="more"></a><blockquote><p> 例如：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>, </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line">  / \</span><br><span class="line"> <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">   /  \</span><br><span class="line">  <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><p>返回锯齿形层次遍历如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">20</span>,<span class="number">9</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：本题其实还是很简单的，只要做过层次遍历那一题，这一题很快就能写出来，只不过多了一次反转而已，而且使用一个标志位就能控制次序，这种层次遍历，主要的精彩之处，就是在于循环到当前队列的大小（很巧妙），就可以实现插入每层的结点，还有这一题返回的是int型数组，并不是结点型数组。"><a href="#解题思路：本题其实还是很简单的，只要做过层次遍历那一题，这一题很快就能写出来，只不过多了一次反转而已，而且使用一个标志位就能控制次序，这种层次遍历，主要的精彩之处，就是在于循环到当前队列的大小（很巧妙），就可以实现插入每层的结点，还有这一题返回的是int型数组，并不是结点型数组。" class="headerlink" title="解题思路：本题其实还是很简单的，只要做过层次遍历那一题，这一题很快就能写出来，只不过多了一次反转而已，而且使用一个标志位就能控制次序，这种层次遍历，主要的精彩之处，就是在于循环到当前队列的大小（很巧妙），就可以实现插入每层的结点，还有这一题返回的是int型数组，并不是结点型数组。"></a>解题思路：本题其实还是很简单的，只要做过层次遍历那一题，这一题很快就能写出来，只不过多了一次反转而已，而且使用一个标志位就能控制次序，这种层次遍历，主要的精彩之处，就是在于循环到当前队列的大小（很巧妙），就可以实现插入每层的结点，还有这一题返回的是int型数组，并不是结点型数组。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt;node;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;result;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> result;</span><br><span class="line">        node.push(root);</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">        TreeNode* p;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;cur_layers;</span><br><span class="line">        <span class="keyword">while</span>(!node.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size=node.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                p=node.front();</span><br><span class="line">                node.pop();</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;left)node.push(p-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;right)node.push(p-&gt;right);</span><br><span class="line">                cur_layers.push_back(p-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag%<span class="number">2</span>!=<span class="number">0</span>)result.push_back(cur_layers);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                reverse(cur_layers.begin(),cur_layers.end());</span><br><span class="line">                result.push_back(cur_layers);</span><br><span class="line">            &#125;</span><br><span class="line">            cur_layers.clear();</span><br><span class="line">            flag++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt; 给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="回溯" scheme="https://cblog.club/categories/leetcode/%E5%9B%9E%E6%BA%AF/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="回溯" scheme="https://cblog.club/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>79单词搜索</title>
    <link href="https://cblog.club/ck3okpvob003vnsg429uyd90z.html"/>
    <id>https://cblog.club/ck3okpvob003vnsg429uyd90z.html</id>
    <published>2019-11-27T14:48:17.000Z</published>
    <updated>2019-11-27T14:54:00.182Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><a id="more"></a><blockquote><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">board =</span><br><span class="line">[</span><br><span class="line">  [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'E'</span>],</span><br><span class="line">  [<span class="string">'S'</span>,<span class="string">'F'</span>,<span class="string">'C'</span>,<span class="string">'S'</span>],</span><br><span class="line">  [<span class="string">'A'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">给定 word = <span class="string">"ABCCED"</span>, 返回 <span class="literal">true</span>.</span><br><span class="line">给定 word = <span class="string">"SEE"</span>, 返回 <span class="literal">true</span>.</span><br><span class="line">给定 word = <span class="string">"ABCB"</span>, 返回 <span class="literal">false</span>.</span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：本题主要是借鉴了一些别人的想法，主要就是主函数循环二维数组（也就是字母表，只要找到一个能够走通的就返回true），然后回溯主要的递归函数里，主要手动模拟四个方向的选择，这一题我按照四个方向走循环，发现有问题，这一题还是需要多看看，感觉还是没彻底搞懂，主要是递归怎么返回，返回时状态不是很清楚，而且自己写递归，也是有问题，这里标记走过的点的方法可以借鉴，走过的就标记为’-’字符，那么下次如果遇到他，就代表走过了。其实像这类题目，已经类似DFS了。"><a href="#解题思路：本题主要是借鉴了一些别人的想法，主要就是主函数循环二维数组（也就是字母表，只要找到一个能够走通的就返回true），然后回溯主要的递归函数里，主要手动模拟四个方向的选择，这一题我按照四个方向走循环，发现有问题，这一题还是需要多看看，感觉还是没彻底搞懂，主要是递归怎么返回，返回时状态不是很清楚，而且自己写递归，也是有问题，这里标记走过的点的方法可以借鉴，走过的就标记为’-’字符，那么下次如果遇到他，就代表走过了。其实像这类题目，已经类似DFS了。" class="headerlink" title="解题思路：本题主要是借鉴了一些别人的想法，主要就是主函数循环二维数组（也就是字母表，只要找到一个能够走通的就返回true），然后回溯主要的递归函数里，主要手动模拟四个方向的选择，这一题我按照四个方向走循环，发现有问题，这一题还是需要多看看，感觉还是没彻底搞懂，主要是递归怎么返回，返回时状态不是很清楚，而且自己写递归，也是有问题，这里标记走过的点的方法可以借鉴，走过的就标记为’#’字符，那么下次如果遇到他，就代表走过了。其实像这类题目，已经类似DFS了。"></a>解题思路：本题主要是借鉴了一些别人的想法，主要就是主函数循环二维数组（也就是字母表，只要找到一个能够走通的就返回true），然后回溯主要的递归函数里，主要手动模拟四个方向的选择，这一题我按照四个方向走循环，发现有问题，这一题还是需要多看看，感觉还是没彻底搞懂，主要是递归怎么返回，返回时状态不是很清楚，而且自己写递归，也是有问题，这里标记走过的点的方法可以借鉴，走过的就标记为’#’字符，那么下次如果遇到他，就代表走过了。其实像这类题目，已经类似DFS了。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row=board.size();</span><br><span class="line">        <span class="keyword">int</span> col=board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(backTrack(board,word,i,j,<span class="number">0</span>))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backTrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board,<span class="built_in">string</span> word,<span class="keyword">int</span> startx,<span class="keyword">int</span> starty,<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        <span class="comment">//越界</span></span><br><span class="line">        <span class="keyword">if</span>(startx&lt;<span class="number">0</span>||startx&gt;=board.size()||starty&lt;<span class="number">0</span>||starty&gt;=board[<span class="number">0</span>].size())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//走过了，或者元素不匹配</span></span><br><span class="line">        <span class="keyword">if</span>(board[startx][starty]!=word[count]||board[startx][starty]==<span class="string">'#'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//走到最后</span></span><br><span class="line">        <span class="keyword">if</span>(count==word.size()<span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">char</span> temp=board[startx][starty];</span><br><span class="line">        <span class="comment">//代表这个点走过了</span></span><br><span class="line">        board[startx][starty]=<span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag=backTrack(board,word,startx,starty<span class="number">-1</span>,count+<span class="number">1</span>)||backTrack(board,word,startx+<span class="number">1</span>,starty,count+<span class="number">1</span>)||backTrack(board,word,startx,starty+<span class="number">1</span>,count+<span class="number">1</span>)||backTrack(board,word,startx<span class="number">-1</span>,starty,count+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//回溯，四个方向都不能走，取消走这个点</span></span><br><span class="line">        board[startx][starty]=temp;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;给定一个二维网格和一个单词，找出该单词是否存在于网格中。&lt;/p&gt;
&lt;p&gt;单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="回溯" scheme="https://cblog.club/categories/leetcode/%E5%9B%9E%E6%BA%AF/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="回溯" scheme="https://cblog.club/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>22括号生成</title>
    <link href="https://cblog.club/ck3okpvm8000xnsg4etm52y4m.html"/>
    <id>https://cblog.club/ck3okpvm8000xnsg4etm52y4m.html</id>
    <published>2019-11-27T14:38:50.000Z</published>
    <updated>2019-11-27T14:47:23.037Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给出 <em>n</em> 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且<strong>有效的</strong>括号组合。</p><a id="more"></a><blockquote><p>例如，给出 <em>n</em> = 3，生成结果为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">"((()))"</span>,</span><br><span class="line">  <span class="string">"(()())"</span>,</span><br><span class="line">  <span class="string">"(())()"</span>,</span><br><span class="line">  <span class="string">"()(())"</span>,</span><br><span class="line">  <span class="string">"()()()"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：本题和全排列的思维像，但是他是有规定的，比如出现）那么前边一定有一个多余的左括号。刚开始使用全排列的思想，然后去重，规定右括号出现，左边一定有一个多余的左括号，但是失败告终-，借鉴了一些，发现主要还是递归，其实回溯就是递归，个人理解只不过回溯多了一步修改的过程。那么这一题用递归的话，主要思想就是’-‘先放，并且它可以最多放三个，然后再放’-’，放右括号的前提是左边有多余的左括号。可以利用open，close参数来控制，open记录当前的’-‘的位置，close记录当前的’-’的位置，那么放有括号的条件就是open要大于close，这样代表左边有多余的（。"><a href="#解题思路：本题和全排列的思维像，但是他是有规定的，比如出现）那么前边一定有一个多余的左括号。刚开始使用全排列的思想，然后去重，规定右括号出现，左边一定有一个多余的左括号，但是失败告终-，借鉴了一些，发现主要还是递归，其实回溯就是递归，个人理解只不过回溯多了一步修改的过程。那么这一题用递归的话，主要思想就是’-‘先放，并且它可以最多放三个，然后再放’-’，放右括号的前提是左边有多余的左括号。可以利用open，close参数来控制，open记录当前的’-‘的位置，close记录当前的’-’的位置，那么放有括号的条件就是open要大于close，这样代表左边有多余的（。" class="headerlink" title="解题思路：本题和全排列的思维像，但是他是有规定的，比如出现）那么前边一定有一个多余的左括号。刚开始使用全排列的思想，然后去重，规定右括号出现，左边一定有一个多余的左括号，但是失败告终- -，借鉴了一些，发现主要还是递归，其实回溯就是递归，个人理解只不过回溯多了一步修改的过程。那么这一题用递归的话，主要思想就是’(‘先放，并且它可以最多放三个，然后再放’)’，放右括号的前提是左边有多余的左括号。可以利用open，close参数来控制，open记录当前的’(‘的位置，close记录当前的’)’的位置，那么放有括号的条件就是open要大于close，这样代表左边有多余的（。"></a>解题思路：本题和全排列的思维像，但是他是有规定的，比如出现）那么前边一定有一个多余的左括号。刚开始使用全排列的思想，然后去重，规定右括号出现，左边一定有一个多余的左括号，但是失败告终- -，借鉴了一些，发现主要还是递归，其实回溯就是递归，个人理解只不过回溯多了一步修改的过程。那么这一题用递归的话，主要思想就是’(‘先放，并且它可以最多放三个，然后再放’)’，放右括号的前提是左边有多余的左括号。可以利用open，close参数来控制，open记录当前的’(‘的位置，close记录当前的’)’的位置，那么放有括号的条件就是open要大于close，这样代表左边有多余的（。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;result;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">string</span> cur_str=<span class="string">""</span>;</span><br><span class="line">        putParenthesis(cur_str,<span class="number">0</span>,<span class="number">0</span>,n);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">putParenthesis</span><span class="params">(<span class="built_in">string</span> cur_str,<span class="keyword">int</span> open,<span class="keyword">int</span> close,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur_str.size()==<span class="number">2</span>*n)&#123;</span><br><span class="line">            result.push_back(cur_str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(open&lt;n)putParenthesis(cur_str+<span class="string">'('</span>,open+<span class="number">1</span>,close,n);</span><br><span class="line">        <span class="keyword">if</span>(open&gt;close)putParenthesis(cur_str+<span class="string">')'</span>,open,close+<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;给出 &lt;em&gt;n&lt;/em&gt; 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且&lt;strong&gt;有效的&lt;/strong&gt;括号组合。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="回溯" scheme="https://cblog.club/categories/leetcode/%E5%9B%9E%E6%BA%AF/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="回溯" scheme="https://cblog.club/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>17电话号码的字母组合</title>
    <link href="https://cblog.club/ck3okpvlv000jnsg4fyz6efks.html"/>
    <id>https://cblog.club/ck3okpvlv000jnsg4fyz6efks.html</id>
    <published>2019-11-27T14:32:53.000Z</published>
    <updated>2019-11-27T14:38:18.052Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><a id="more"></a><img src="/ck3okpvlv000jnsg4fyz6efks/1.jpg" class=""><blockquote><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="string">"23"</span></span><br><span class="line">输出：[<span class="string">"ad"</span>, <span class="string">"ae"</span>, <span class="string">"af"</span>, <span class="string">"bd"</span>, <span class="string">"be"</span>, <span class="string">"bf"</span>, <span class="string">"cd"</span>, <span class="string">"ce"</span>, <span class="string">"cf"</span>].</span><br></pre></td></tr></table></figure><p><strong>说明:</strong><br>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p></blockquote><h6 id="解题思路：本题倒不是很难，还是在于理解回溯，以及在递归传参的一些细节，我们可以依靠传参来判断我们是应该在第几个找，比如穿的是3，就应该string的序号为3的字符串里找相应的字符。还有要注意的就是string字符串有-连接字符串，但是他没有-这个操作，如果想要使用删除末尾元素的字符，可以使用cur-str-erase-cur-str-end-1-语句，其实做这种排列问题，首先要想到回溯法，就要想到回溯的框架（当然回溯的框架，不适应一些题目）。"><a href="#解题思路：本题倒不是很难，还是在于理解回溯，以及在递归传参的一些细节，我们可以依靠传参来判断我们是应该在第几个找，比如穿的是3，就应该string的序号为3的字符串里找相应的字符。还有要注意的就是string字符串有-连接字符串，但是他没有-这个操作，如果想要使用删除末尾元素的字符，可以使用cur-str-erase-cur-str-end-1-语句，其实做这种排列问题，首先要想到回溯法，就要想到回溯的框架（当然回溯的框架，不适应一些题目）。" class="headerlink" title="解题思路：本题倒不是很难，还是在于理解回溯，以及在递归传参的一些细节，我们可以依靠传参来判断我们是应该在第几个找，比如穿的是3，就应该string的序号为3的字符串里找相应的字符。还有要注意的就是string字符串有+=连接字符串，但是他没有-=这个操作，如果想要使用删除末尾元素的字符，可以使用cur_str.erase(cur_str.end() - 1);语句，其实做这种排列问题，首先要想到回溯法，就要想到回溯的框架（当然回溯的框架，不适应一些题目）。"></a>解题思路：本题倒不是很难，还是在于理解回溯，以及在递归传参的一些细节，我们可以依靠传参来判断我们是应该在第几个找，比如穿的是3，就应该string的序号为3的字符串里找相应的字符。还有要注意的就是string字符串有+=连接字符串，但是他没有-=这个操作，如果想要使用删除末尾元素的字符，可以使用<code>cur_str.erase(cur_str.end() - 1);</code>语句，其实做这种排列问题，首先要想到回溯法，就要想到回溯的框架（当然回溯的框架，不适应一些题目）。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;result;</span><br><span class="line">        <span class="keyword">if</span>(digits.size()==<span class="number">0</span>)<span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">string</span> cur_str=<span class="string">""</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;number&#123;<span class="string">""</span>,<span class="string">""</span>,<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,<span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span>&#125;;</span><br><span class="line">        getResult(digits,number,<span class="number">0</span>,result,cur_str);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getResult</span><span class="params">(<span class="built_in">string</span> digits,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp;number,<span class="keyword">int</span> count,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp;result,<span class="built_in">string</span> cur_str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur_num;</span><br><span class="line">        <span class="keyword">int</span> size=digits.size();</span><br><span class="line">        <span class="keyword">if</span>(count==size)&#123;</span><br><span class="line">            result.push_back(cur_str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur_num=digits[count]-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;number[cur_num].size();j++)&#123;</span><br><span class="line">            cur_str+=number[cur_num][j];</span><br><span class="line">            getResult(digits,number,count+<span class="number">1</span>,result,cur_str);</span><br><span class="line">            cur_str.erase(cur_str.end() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;给定一个仅包含数字 &lt;code&gt;2-9&lt;/code&gt; 的字符串，返回所有它能表示的字母组合。&lt;/p&gt;
&lt;p&gt;给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="回溯" scheme="https://cblog.club/categories/leetcode/%E5%9B%9E%E6%BA%AF/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="回溯" scheme="https://cblog.club/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>78子集</title>
    <link href="https://cblog.club/ck3okpvo7003pnsg488nh00fh.html"/>
    <id>https://cblog.club/ck3okpvo7003pnsg488nh00fh.html</id>
    <published>2019-11-27T14:27:59.000Z</published>
    <updated>2019-11-27T14:32:19.368Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定一组<strong>不含重复元素</strong>的整数数组 <em>nums</em>，返回该数组所有可能的子集（幂集）。</p><p><strong>说明：</strong>解集不能包含重复的子集。</p><a id="more"></a><blockquote><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：这一题也是折腾了不少时间，主要是回溯框架思维，以及之前做过的全排列，对我影响太深，有点固化了，所以思考问题还是不行，这一题主要不同在于他是长度是可变的，一开始想的有点麻烦想要传参进行长度的影响，但是稍微转变一点，利用这个长度，进行循环的条件判断，在插入结果数组的时候，我们不加判断，直接插入即可，因为没有长度限制，注意循环可以控制数字的方向从左到右。"><a href="#解题思路：这一题也是折腾了不少时间，主要是回溯框架思维，以及之前做过的全排列，对我影响太深，有点固化了，所以思考问题还是不行，这一题主要不同在于他是长度是可变的，一开始想的有点麻烦想要传参进行长度的影响，但是稍微转变一点，利用这个长度，进行循环的条件判断，在插入结果数组的时候，我们不加判断，直接插入即可，因为没有长度限制，注意循环可以控制数字的方向从左到右。" class="headerlink" title="解题思路：这一题也是折腾了不少时间，主要是回溯框架思维，以及之前做过的全排列，对我影响太深，有点固化了，所以思考问题还是不行，这一题主要不同在于他是长度是可变的，一开始想的有点麻烦想要传参进行长度的影响，但是稍微转变一点，利用这个长度，进行循环的条件判断，在插入结果数组的时候，我们不加判断，直接插入即可，因为没有长度限制，注意循环可以控制数字的方向从左到右。"></a>解题思路：这一题也是折腾了不少时间，主要是回溯框架思维，以及之前做过的全排列，对我影响太深，有点固化了，所以思考问题还是不行，这一题主要不同在于他是长度是可变的，一开始想的有点麻烦想要传参进行长度的影响，但是稍微转变一点，利用这个长度，进行循环的条件判断，在插入结果数组的时候，我们不加判断，直接插入即可，因为没有长度限制，注意循环可以控制数字的方向从左到右。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;select;</span><br><span class="line">        insertSubsets(nums,select,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertSubsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; select,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        result.push_back(select);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=length;i&lt;nums.size();i++)&#123;</span><br><span class="line">            select.push_back(nums[i]);</span><br><span class="line">            insertSubsets(nums,select,i+<span class="number">1</span>);</span><br><span class="line">            select.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;给定一组&lt;strong&gt;不含重复元素&lt;/strong&gt;的整数数组 &lt;em&gt;nums&lt;/em&gt;，返回该数组所有可能的子集（幂集）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;解集不能包含重复的子集。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="回溯" scheme="https://cblog.club/categories/leetcode/%E5%9B%9E%E6%BA%AF/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="回溯" scheme="https://cblog.club/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>51N皇后</title>
    <link href="https://cblog.club/ck3okpvn7002gnsg4d7xe42zy.html"/>
    <id>https://cblog.club/ck3okpvn7002gnsg4d7xe42zy.html</id>
    <published>2019-11-27T14:23:10.000Z</published>
    <updated>2019-11-27T14:26:54.634Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p> <em>n</em> 皇后问题研究的是如何将 <em>n</em> 个皇后放置在 <em>n</em>×<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击。 </p><a id="more"></a><blockquote><p>给定一个整数 <em>n</em>，返回所有不同的 <em>n</em> 皇后问题的解决方案。</p><p>每一种解法包含一个明确的 <em>n</em> 皇后问题的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">4</span></span><br><span class="line">输出: [</span><br><span class="line"> [<span class="string">".Q.."</span>,  <span class="comment">// 解法 1</span></span><br><span class="line">  <span class="string">"...Q"</span>,</span><br><span class="line">  <span class="string">"Q..."</span>,</span><br><span class="line">  <span class="string">"..Q."</span>],</span><br><span class="line"></span><br><span class="line"> [<span class="string">"..Q."</span>,  <span class="comment">// 解法 2</span></span><br><span class="line">  <span class="string">"Q..."</span>,</span><br><span class="line">  <span class="string">"...Q"</span>,</span><br><span class="line">  <span class="string">".Q.."</span>]</span><br><span class="line">]</span><br><span class="line">解释: <span class="number">4</span> 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：N皇后问题为经典的回溯算法，回溯算法中，也已经详细的介绍了解法，这里不再赘述，回溯算法的框架，自己一定要想清楚，但是题目还是很灵活的，并不是都是千篇一律，，直接用来套公式就能解决的，所以还是要理解，然后发现递归的模拟，真的是能玩一天-！"><a href="#解题思路：N皇后问题为经典的回溯算法，回溯算法中，也已经详细的介绍了解法，这里不再赘述，回溯算法的框架，自己一定要想清楚，但是题目还是很灵活的，并不是都是千篇一律，，直接用来套公式就能解决的，所以还是要理解，然后发现递归的模拟，真的是能玩一天-！" class="headerlink" title="解题思路：N皇后问题为经典的回溯算法，回溯算法中，也已经详细的介绍了解法，这里不再赘述，回溯算法的框架，自己一定要想清楚，但是题目还是很灵活的，并不是都是千篇一律，，直接用来套公式就能解决的，所以还是要理解，然后发现递归的模拟，真的是能玩一天= =！"></a>解题思路：N皇后问题为经典的回溯算法，回溯算法中，也已经详细的介绍了解法，这里不再赘述，回溯算法的框架，自己一定要想清楚，但是题目还是很灵活的，并不是都是千篇一律，，直接用来套公式就能解决的，所以还是要理解，然后发现递归的模拟，真的是能玩一天= =！</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; result;</span><br><span class="line">        <span class="comment">//初始化一个空的棋盘</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;board(n,<span class="built_in">string</span>(n,<span class="string">'.'</span>));</span><br><span class="line">        putNQueens(board,<span class="number">0</span>,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">putNQueens</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp;board,<span class="keyword">int</span> row,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp;result)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row==board.size())&#123;</span><br><span class="line">            result.push_back(board);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始放置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;board.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!isValid(board,row,i))<span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//做出选择</span></span><br><span class="line">            board[row][i]=<span class="string">'Q'</span>;</span><br><span class="line">            putNQueens(board,row+<span class="number">1</span>,result);</span><br><span class="line">            <span class="comment">//撤销选择</span></span><br><span class="line">            board[row][i]=<span class="string">'.'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp;board,<span class="keyword">int</span> row,<span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">        <span class="comment">//先检查该列上有没有皇后</span></span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][col]==<span class="string">'Q'</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查看左上方有没有皇后</span></span><br><span class="line">        <span class="keyword">for</span>(i=row<span class="number">-1</span>,j=col<span class="number">-1</span>;i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>;i--,j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==<span class="string">'Q'</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查看右上方有没有皇后</span></span><br><span class="line">        <span class="keyword">for</span>(i=row<span class="number">-1</span>,j=col+<span class="number">1</span>;i&gt;=<span class="number">0</span>&amp;&amp;j&lt;board.size();i--,j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==<span class="string">'Q'</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt; &lt;em&gt;n&lt;/em&gt; 皇后问题研究的是如何将 &lt;em&gt;n&lt;/em&gt; 个皇后放置在 &lt;em&gt;n&lt;/em&gt;×&lt;em&gt;n&lt;/em&gt; 的棋盘上，并且使皇后彼此之间不能相互攻击。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="回溯" scheme="https://cblog.club/categories/leetcode/%E5%9B%9E%E6%BA%AF/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="回溯" scheme="https://cblog.club/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>回溯算法</title>
    <link href="https://cblog.club/ck3okpvpk005ynsg4dpn2ftwk.html"/>
    <id>https://cblog.club/ck3okpvpk005ynsg4dpn2ftwk.html</id>
    <published>2019-11-25T13:31:14.000Z</published>
    <updated>2019-11-26T06:06:12.996Z</updated>
    
    <content type="html"><![CDATA[<p>这两天在研究回溯算法，所以特此记录一下，这一片文章是看的一个知乎上的人的总结，感觉非常不错，很容易理解。</p><h4 id="解决一个回溯问题，实际上就是一个决策树的遍历过程。"><a href="#解决一个回溯问题，实际上就是一个决策树的遍历过程。" class="headerlink" title="解决一个回溯问题，实际上就是一个决策树的遍历过程。"></a>解决一个回溯问题，实际上就是一个决策树的遍历过程。</h4><p>你只需要思考 3 个问题：</p><a id="more"></a><ul><li><p>路径：也就是已经做出的选择。</p></li><li><p>选择列表：也就是你当前可以做的选择。</p></li><li><p>结束条件：也就是到达决策树底层，无法再做选择的条件。</p></li></ul><p>如果你不理解这三个词语的解释，没关系，我们后面会用「全排列」和「N 皇后问题」这两个经典的回溯算法问题来帮你理解这些词语是什么意思，现在你先留着印象。</p><p>代码方面，回溯算法的框架：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">def backtrack(路径, 选择列表):</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> 选择 in 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure><p><strong>其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」</strong>，特别简单。</p><p>什么叫做选择和撤销选择呢，这个框架的底层原理是什么呢？下面我们就通过「全排列」这个问题来解开之前的疑惑，详细探究一下其中的奥妙！</p><h4 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h4><h4 id="我们在高中的时候就做过排列组合的数学题，我们也知道n个不重复的数，全排列共有-n-个。"><a href="#我们在高中的时候就做过排列组合的数学题，我们也知道n个不重复的数，全排列共有-n-个。" class="headerlink" title="我们在高中的时候就做过排列组合的数学题，我们也知道n个不重复的数，全排列共有 n! 个。"></a>我们在高中的时候就做过排列组合的数学题，我们也知道<code>n</code>个不重复的数，全排列共有 n! 个。</h4><p>PS：<strong>为了简单清晰起见，我们这次讨论的全排列问题不包含重复的数字</strong>。</p><p>那么我们当时是怎么穷举全排列的呢？比方说给三个数<code>[1,2,3]</code>，你肯定不会无规律地乱穷举，一般是这样：</p><p>先固定第一位为 1，然后第二位可以是 2，那么第三位只能是 3；然后可以把第二位变成 3，第三位就只能是 2 了；然后就只能变化第一位，变成 2，然后再穷举后两位……</p><p>其实这就是回溯算法，我们高中无师自通就会用，或者有的同学直接画出如下这棵回溯树：</p><img src="/ck3okpvpk005ynsg4dpn2ftwk/image-20191125213617585.png" class=""><p>只要从根遍历这棵树，记录路径上的数字，其实就是所有的全排列。<strong>我们不妨把这棵树称为回溯算法的「决策树」</strong>。</p><p><strong>为啥说这是决策树呢，因为你在每个节点上其实都在做决策</strong>。比如说你站在下图的红色节点上：</p><img src="/ck3okpvpk005ynsg4dpn2ftwk/image-20191125213806909.png" class=""><p>你现在就在做决策，可以选择 1 那条树枝，也可以选择 3 那条树枝。为啥只能在 1 和 3 之中选择呢？因为 2 这个树枝在你身后，这个选择你之前做过了，而全排列是不允许重复使用数字的。 </p><p><strong>现在可以解答开头的几个名词：<code>[2]</code>就是「路径」，记录你已经做过的选择；<code>[1,3]</code>就是「选择列表」，表示你当前可以做出的选择；「结束条件」就是遍历到树的底层，在这里就是选择列表为空的时候</strong>。</p><p>如果明白了这几个名词，<strong>可以把「路径」和「选择列表」作为决策树上每个节点的属性</strong>，比如下图列出了几个节点的属性：</p><img src="/ck3okpvpk005ynsg4dpn2ftwk/image-20191125213946062.png" class=""><p><strong>我们定义的<code>backtrack</code>函数其实就像一个指针，在这棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层，其「路径」就是一个全排列</strong>。</p><p>再进一步，如何遍历一棵树？这个应该不难吧。回忆一下之前 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484520&idx=1&sn=2c6507c7f25c0fd29fd1d146ee3b067c&chksm=9bd7fa60aca073763785418d15ed03c9debdd93ca36f4828fa809990116b1e7536c3f68a7b71&scene=21#wechat_redirect" target="_blank" rel="noopener">学习数据结构的框架思维</a> 写过，各种搜索问题其实都是树的遍历问题，而多叉树的遍历框架就是这样：</p><p> 而所谓的前序遍历和后序遍历，他们只是两个很有用的时间点，我给你画张图你就明白了： </p><img src="/ck3okpvpk005ynsg4dpn2ftwk/image-20191125214040894.png" class=""><p><strong>前序遍历的代码在进入某一个节点之前的那个时间点执行，后序遍历代码在离开某个节点之后的那个时间点执行</strong>。</p><p>回想我们刚才说的，「路径」和「选择」是每个节点的属性，函数在树上游走要正确维护节点的属性，那么就要在这两个特殊时间点搞点动作：</p><img src="/ck3okpvpk005ynsg4dpn2ftwk/image-20191125214111739.png" class=""><p> 现在，你是否理解了回溯算法的这段核心框架？ </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 选择 in 选择列表:</span><br><span class="line">    # 做选择</span><br><span class="line">    将该选择从选择列表移除</span><br><span class="line">    路径.add(选择)</span><br><span class="line">    backtrack(路径, 选择列表)</span><br><span class="line">    # 撤销选择</span><br><span class="line">    路径.remove(选择)</span><br><span class="line">    将该选择再加入选择列表</span><br></pre></td></tr></table></figure><p><strong>我们只要在递归之前做出选择，在递归之后撤销刚才的选择</strong>，就能正确得到每个节点的选择列表和路径。</p><p>下面，直接看全排列代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 主函数，输入一组不重复的数字，返回它们的全排列 */</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="comment">// 记录「路径」</span></span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backtrack(nums, track);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径：记录在 track 中</span></span><br><span class="line"><span class="comment">// 选择列表：nums 中不存在于 track 的那些元素</span></span><br><span class="line"><span class="comment">// 结束条件：nums 中的元素全都在 track 中出现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (track.size() == nums.length) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 排除不合法的选择</span></span><br><span class="line">        <span class="keyword">if</span> (track.contains(nums[i]))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.add(nums[i]);</span><br><span class="line">        <span class="comment">// 进入下一层决策树</span></span><br><span class="line">        backtrack(nums, track);</span><br><span class="line">        <span class="comment">// 取消选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 我们这里稍微做了些变通，没有显式记录「选择列表」，而是通过<code>nums</code>和<code>track</code>推导出当前的选择列表： </p><img src="/ck3okpvpk005ynsg4dpn2ftwk/image-20191125214229597.png" class=""><p>至此，我们就通过全排列问题详解了回溯算法的底层原理。当然，这个算法解决全排列不是很高效，因为对链表使用<code>contains</code>方法需要 O(N) 的时间复杂度。有更好的方法通过交换元素达到目的，但是难理解一些，这里就不写了，有兴趣可以自行搜索一下。</p><p>但是必须说明的是，不管怎么优化，都符合回溯框架，而且时间复杂度都不可能低于 O(N!)，因为穷举整棵决策树是无法避免的。<strong>这也是回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高</strong>。</p><p>明白了全排列问题，就可以直接套回溯算法框架了，下面简单看看 N 皇后问题。</p><h4 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h4><p>这个问题很经典了，简单解释一下：给你一个 N×N 的棋盘，让你放置 N 个皇后，使得它们不能互相攻击。</p><p>PS：皇后可以攻击同一行、同一列、左上左下右上右下四个方向的任意单位。</p><p>这是 N = 8 的一种放置方法：</p><img src="/ck3okpvpk005ynsg4dpn2ftwk/image-20191125214412332.png" class=""><p> 这个问题本质上跟全排列问题差不多，决策树的每一层表示棋盘上的每一行；每个节点可以做出的选择是，在该行的任意一列放置一个皇后。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输入棋盘边长 n，返回所有合法的放置 */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="comment">// '.' 表示空，'Q' 表示皇后，初始化空棋盘。</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; board(n, <span class="built_in">string</span>(n, <span class="string">'.'</span>));</span><br><span class="line">    backtrack(board, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径：board 中小于 row 的那些行都已经成功放置了皇后</span></span><br><span class="line"><span class="comment">// 选择列表：第 row 行的所有列都是放置皇后的选择</span></span><br><span class="line"><span class="comment">// 结束条件：row 超过 board 的最后一行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; board, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (row == board.size()) &#123;</span><br><span class="line">        res.push_back(board);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = board[row].size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        <span class="comment">// 排除不合法选择</span></span><br><span class="line">        <span class="keyword">if</span> (!isValid(board, row, col)) </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        board[row][col] = <span class="string">'Q'</span>;</span><br><span class="line">        <span class="comment">// 进入下一行决策</span></span><br><span class="line">        backtrack(board, row + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        board[row][col] = <span class="string">'.'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这部分主要代码，跟全排列问题差不多。<code>isValid</code>函数的实现也很简单： </p><ul><li>这里要注意的是，我们是从上往下放的皇后，所以不需要再去检查左下，右下是否有皇后了，在这一列上也只需要到第row行之前就可以了。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 是否可以在 board[row][col] 放置皇后？ */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = board.size();</span><br><span class="line">    <span class="comment">// 检查列是否有皇后互相冲突</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][col] == <span class="string">'Q'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查右上方是否有皇后互相冲突</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; </span><br><span class="line">            i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">'Q'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查左上方是否有皇后互相冲突</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>;</span><br><span class="line">            i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">'Q'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数<code>backtrack</code>依然像个在决策树上游走的指针，每个节点就表示在<code>board[row][col]</code>上放置皇后，通过<code>isValid</code>函数可以将不符合条件的情况剪枝</strong>： </p><p>如果直接给你这么一大段解法代码，可能是懵逼的。但是现在明白了回溯算法的框架套路，还有啥难理解的呢？无非是改改做选择的方式，排除不合法选择的方式而已，只要框架存于心，你面对的只剩下小问题了。</p><p>当<code>N = 8</code>时，就是八皇后问题，数学大佬高斯穷尽一生都没有数清楚八皇后问题到底有几种可能的放置方法，但是我们的算法只需要一秒就可以算出来所有可能的结果。</p><p>不过真的不怪高斯。这个问题的复杂度确实非常高，看看我们的决策树，虽然有<code>isValid</code>函数剪枝，但是最坏时间复杂度仍然是 O(N^(N+1))（这个时间复杂度需要考虑），而且无法优化。如果<code>N = 10</code>的时候，计算就已经很耗时了。</p><p><strong>有的时候，我们并不想得到所有合法的答案，只想要一个答案，怎么办呢</strong>？比如解数独的算法，找所有解法复杂度太高，只要找到一种解法就可以。</p><p>其实特别简单，只要稍微修改一下回溯算法的代码即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数找到一个答案后就返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; board, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (row == board.size()) &#123;</span><br><span class="line">        res.push_back(board);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        ...</span><br><span class="line">        board[row][col] = <span class="string">'Q'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (backtrack(board, row + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        board[row][col] = <span class="string">'.'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样修改后，只要找到一个答案，for 循环的后续递归穷举都会被阻断。也许你可以在 N 皇后问题的代码框架上，稍加修改，写一个解数独的算法？</p><h4 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h4><p> 回溯算法就是个多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置做一些操作，算法框架如下： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def backtrack(...):</span><br><span class="line">    <span class="keyword">for</span> 选择 in 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(...)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure><p><strong>写<code>backtrack</code>函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集</strong>。 </p><p>其实想想看，回溯算法和动态规划是不是有点像呢？我们在动态规划系列文章中多次强调，动态规划的三个需要明确的点就是「状态」「选择」和「base case」，是不是就对应着走过的「路径」，当前的「选择列表」和「结束条件」？</p><p>某种程度上说，动态规划的暴力求解阶段就是回溯算法。只是有的问题具有重叠子问题性质，可以用 dp table 或者备忘录优化，将递归树大幅剪枝，这就变成了动态规划。而今天的两个问题，都没有重叠子问题，也就是回溯算法问题了，复杂度非常高是不可避免的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这两天在研究回溯算法，所以特此记录一下，这一片文章是看的一个知乎上的人的总结，感觉非常不错，很容易理解。&lt;/p&gt;
&lt;h4 id=&quot;解决一个回溯问题，实际上就是一个决策树的遍历过程。&quot;&gt;&lt;a href=&quot;#解决一个回溯问题，实际上就是一个决策树的遍历过程。&quot; class=&quot;headerlink&quot; title=&quot;解决一个回溯问题，实际上就是一个决策树的遍历过程。&quot;&gt;&lt;/a&gt;解决一个回溯问题，实际上就是一个决策树的遍历过程。&lt;/h4&gt;&lt;p&gt;你只需要思考 3 个问题：&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://cblog.club/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://cblog.club/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>47全排列II</title>
    <link href="https://cblog.club/ck3okpvn4002cnsg49a1u7mzt.html"/>
    <id>https://cblog.club/ck3okpvn4002cnsg49a1u7mzt.html</id>
    <published>2019-11-25T13:19:15.000Z</published>
    <updated>2019-11-25T13:29:28.171Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p> 给定一个可包含重复数字的序列，返回所有不重复的全排列。 </p><a id="more"></a><blockquote><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：本题是全排列的升级版，主要区别是给定数组有重复数字出现，但是返回的数组不能有重复数字。大体的思路就是先将数组进行排序，因为我们很容易想到，排序后，重复的元素是相邻的，然后我们在根据要求，在重复的位置上进行剪枝即可。具体思路可以参考一个大佬的写的解题过程-https-leetcode-cn-com-problems-permutations-ii-solution-hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2-，今天思考递归，想了好久，手动模拟，感觉比以前要深刻一点。"><a href="#解题思路：本题是全排列的升级版，主要区别是给定数组有重复数字出现，但是返回的数组不能有重复数字。大体的思路就是先将数组进行排序，因为我们很容易想到，排序后，重复的元素是相邻的，然后我们在根据要求，在重复的位置上进行剪枝即可。具体思路可以参考一个大佬的写的解题过程-https-leetcode-cn-com-problems-permutations-ii-solution-hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2-，今天思考递归，想了好久，手动模拟，感觉比以前要深刻一点。" class="headerlink" title="解题思路：本题是全排列的升级版，主要区别是给定数组有重复数字出现，但是返回的数组不能有重复数字。大体的思路就是先将数组进行排序，因为我们很容易想到，排序后，重复的元素是相邻的，然后我们在根据要求，在重复的位置上进行剪枝即可。具体思路可以参考一个大佬的写的解题过程  https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/ ，今天思考递归，想了好久，手动模拟，感觉比以前要深刻一点。"></a>解题思路：本题是全排列的升级版，主要区别是给定数组有重复数字出现，但是返回的数组不能有重复数字。大体的思路就是先将数组进行排序，因为我们很容易想到，排序后，重复的元素是相邻的，然后我们在根据要求，在重复的位置上进行剪枝即可。具体思路可以参考一个大佬的写的解题过程  <a href="https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/</a> ，今天思考递归，想了好久，手动模拟，感觉比以前要深刻一点。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;result;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;init_path;</span><br><span class="line">        <span class="keyword">int</span> size=nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;visited(size,<span class="literal">false</span>);</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        Backtracking(init_path,nums,result,visited);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Backtracking</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;path,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;select,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp;result,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp;visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size()==select.size())&#123;</span><br><span class="line">            result.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;select.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;select[i<span class="number">-1</span>]==select[i]&amp;&amp;visited[i<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">                path.push_back(select[i]);</span><br><span class="line">                visited[i]=<span class="literal">true</span>;</span><br><span class="line">                Backtracking(path,select,result,visited);</span><br><span class="line">                path.pop_back();</span><br><span class="line">                visited[i]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt; 给定一个可包含重复数字的序列，返回所有不重复的全排列。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="回溯" scheme="https://cblog.club/categories/leetcode/%E5%9B%9E%E6%BA%AF/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="回溯" scheme="https://cblog.club/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>attetion机制简单了解</title>
    <link href="https://cblog.club/ck3okpvp8005fnsg4gajd29cb.html"/>
    <id>https://cblog.club/ck3okpvp8005fnsg4gajd29cb.html</id>
    <published>2019-11-25T11:53:16.000Z</published>
    <updated>2019-11-25T12:04:56.199Z</updated>
    
    <content type="html"><![CDATA[<p>读了一篇关于水表数字识别的论文，里面有个名词attention mechanism(注意力机制)，没有接触过，所以找了一些资料来看，特此记录一下，主要是记录下它的作用，具体的算法及其推导就不看了，不是NLP方向，就做个简单的了解 = =！（其实是太难了…）</p><a id="more"></a><h4 id="What-is-attention-mechanism"><a href="#What-is-attention-mechanism" class="headerlink" title="What is attention mechanism"></a>What is attention mechanism</h4><p>先简单描述一下attention机制是什么。相信做NLP的同学对这个机制不会很陌生，它在<strong>Attention is all you need</strong>可以说是大放异彩，在machine translation任务中，帮助深度模型在性能上有了很大的提升，输出了当时最好的state-of-art model。当然该模型除了attention机制外，还用了很多有用的trick，以帮助提升模型性能。但是不能否认的时，这个模型的核心就是attention。</p><p>attention机制：又称为注意力机制，顾名思义，是<strong>一种能让模型对重要信息重点关注并充分学习吸收的技术</strong>，它不算是一个完整的模型，应当是一种技术，能够作用于任何序列模型中。</p><p>注意力机制是一种基于RNN（LSTM或GRU）的编码器+解码器模型（我们之前在seq2seq模型中简单介绍过）的效果的机制（机制），一般称为注意机制。注意机制目前非常流行，广泛应用于机器翻译，语音识别，图像标注（Image Caption）等很多领域，之所以它这么受欢迎，是因为Attention给模型赋予了区分辨别的能力，例如，在机器翻译，语音识别应用中，为句子中的每个词赋予不同的权重，使神经网络模型的学习变得更加灵活（软），同时注意力本身可以做为一种对齐关系，解释输入/输出句子之间的对齐关系，解释模型到底学到了什么知识，为我们打开深度学习的黑箱，提供了一个窗口。</p><h4 id="Why-attention？"><a href="#Why-attention？" class="headerlink" title="Why attention？"></a>Why attention？</h4><p>讲一下为什么要引入attention机制。在之前总结过的seq2seq模型以及之前做NLP的比赛中，对于一段文本序列，我们通常要使用某种机制对该序列进行编码，通过降维等方式将其encode成一个固定长度的向量，用于输入到后面的全连接层。 </p><img src="/ck3okpvp8005fnsg4gajd29cb/image-20191125200235039.png" class=""><p>一般我们会使用CNN或者RNN（包括GRU或者LSTM）等模型来对序列数据进行编码，然后采用各种pooling或者对RNN直接取最后一个t时刻的hidden state作为句子的向量输出。这里会有一个问题：</p><p>常规的编码方法，无法体现对一个句子序列中不同语素的关注程度，在自然语言中，一个句子中的不同部分是有不同含义和重要性的，比如上面的例子中：I hate this movie.如果做情感分析，明显对hate这个词语应当关注更多。当然是用CNN和RNN能够编码这种信息。但是如果序列长度很长的情况下，这种方法会有一定的瓶颈。拿CNN举例，具体如下图：图来自  <a href="https://link.zhihu.com/?target=https%3A//cloud.tencent.com/developer/article/1153079">“变形金刚”为何强大：从模型到代码全面解析Google Tensor2Tensor系统</a></p><img src="/ck3okpvp8005fnsg4gajd29cb/image-20191125200402273.png" class=""><p>CNN的核心就是卷积核能够变相学习n-gram的信息，如果是用hierarchical的卷积核，那么越上层的卷积核越能编码原始距离较远的词组的信息。但是这种编码能力也是有上限的，对于较长的文本，模型效果不会再提升太多。RNN也是同理。</p><p>基于参加达观文本分类的经历，对于这种长文本处理，使用RNN+attention的效果比使用单纯的RNN+pooling的效果要好不少。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;读了一篇关于水表数字识别的论文，里面有个名词attention mechanism(注意力机制)，没有接触过，所以找了一些资料来看，特此记录一下，主要是记录下它的作用，具体的算法及其推导就不看了，不是NLP方向，就做个简单的了解 = =！（其实是太难了…）&lt;/p&gt;
    
    </summary>
    
    
      <category term="深度学习" scheme="https://cblog.club/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="https://cblog.club/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>seq2seq模型简单了解</title>
    <link href="https://cblog.club/ck3okpvpb005insg4fo2z5r3d.html"/>
    <id>https://cblog.club/ck3okpvpb005insg4fo2z5r3d.html</id>
    <published>2019-11-25T11:41:24.000Z</published>
    <updated>2019-11-25T11:49:39.035Z</updated>
    
    <content type="html"><![CDATA[<p>读了一篇关于水表数字识别的论文，里面有个名词seq2seq，没有接触过，所以找了一些资料来看，特此记录一下，主要是记录下它的作用，具体的算法及其推导还没看，因为不是NLP方向，就想简单了解一下。</p><a id="more"></a><h4 id="Seq2Seq模型简介"><a href="#Seq2Seq模型简介" class="headerlink" title="Seq2Seq模型简介"></a>Seq2Seq模型简介</h4><p>Seq2Seq模型是输出的长度不确定时采用的模型，这种情况一般是在机器翻译的任务中出现，将一句中文翻译成英文，那么这句英文的长度有可能会比中文短，也有可能会比中文长，所以输出的长度就不确定了。如下图所，输入的中文长度为4，输出的英文长度为2。</p><img src="/ck3okpvpb005insg4fo2z5r3d/image-20191125194417521.png" class=""><p>在网络结构中，输入一个中文序列，然后输出它对应的中文翻译，输出的部分的结果预测后面，根据上面的例子，也就是先输出“machine”，将”machine”作为下一次的输入，接着输出”learning”,这样就能输出任意长的序列。<br>机器翻译、人机对话、聊天机器人等等，这些都是应用在当今社会都或多或少的运用到了我们这里所说的Seq2Seq。</p><h4 id="Seq2Seq结构"><a href="#Seq2Seq结构" class="headerlink" title="Seq2Seq结构"></a>Seq2Seq结构</h4><p>seq2seq属于encoder-decoder结构的一种，这里看看常见的encoder-decoder结构，基本思想就是利用两个RNN，一个RNN作为encoder，另一个RNN作为decoder。<strong>encoder负责将输入序列压缩成指定长度的向量</strong>，这个向量就可以看成是这个序列的语义，这个过程称为编码，如下图，<strong>获取语义向量最简单的方式就是直接将最后一个输入的隐状态作为语义向量C</strong>。也可以对最后一个隐含状态做一个变换得到语义向量，还可以将输入序列的所有隐含状态做一个变换得到语义变量。</p><img src="/ck3okpvpb005insg4fo2z5r3d/image-20191125194651707.png" class=""><p>而<strong>decoder则负责根据语义向量生成指定的序列</strong>，这个过程也称为解码，如下图，最简单的方式是将encoder得到的语义变量作为初始状态输入到decoder的RNN中，得到输出序列。可以看到上一时刻的输出会作为当前时刻的输入，而且其中语义向量C只作为初始状态参与运算，后面的运算都与语义向量C无关。</p><img src="/ck3okpvpb005insg4fo2z5r3d/image-20191125194809371.png" class=""><p>decoder处理方式还有另外一种，就是语义向量C参与了序列所有时刻的运算，如下图，上一时刻的输出仍然作为当前时刻的输入，但语义向量C会参与所有时刻的运算。 </p><img src="/ck3okpvpb005insg4fo2z5r3d/image-20191125194907893.png" class="">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;读了一篇关于水表数字识别的论文，里面有个名词seq2seq，没有接触过，所以找了一些资料来看，特此记录一下，主要是记录下它的作用，具体的算法及其推导还没看，因为不是NLP方向，就想简单了解一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="深度学习" scheme="https://cblog.club/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="https://cblog.club/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>lemon</title>
  
  <subtitle>一直在路上</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cblog.club/"/>
  <updated>2019-11-21T03:40:59.316Z</updated>
  <id>https://cblog.club/</id>
  
  <author>
    <name>lemon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>279完全平方数</title>
    <link href="https://cblog.club/ck3865rmj000e2wg427g13a1c.html"/>
    <id>https://cblog.club/ck3865rmj000e2wg427g13a1c.html</id>
    <published>2019-11-21T03:36:38.000Z</published>
    <updated>2019-11-21T03:40:59.316Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p> 给定正整数 <em>n</em>，找到若干个完全平方数（比如 <code>1, 4, 9, 16, ...</code>）使得它们的和等于 <em>n</em>。你需要让组成和的完全平方数的个数最少。 </p><a id="more"></a><blockquote><p><strong>示例 1:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n = <span class="number">12</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: <span class="number">12</span> = <span class="number">4</span> + <span class="number">4</span> + <span class="number">4.</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n = <span class="number">13</span></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: <span class="number">13</span> = <span class="number">4</span> + <span class="number">9.</span></span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：本题思考了一会，在想怎么使用DP呢？然后灵光一现，这不就是兑换零钱的变种吗，只不过零钱的面额在这一题中，不再是固定的了，比如12，那么对应的“面额”就应该是1，4，9，这些完全平方数，以此类推，第一代的代码，我是将这些“面额”循环插入到一个数组中了（其实没必要，可以合并，进行代码优化），其他的思想和兑换零钱一样。"><a href="#解题思路：本题思考了一会，在想怎么使用DP呢？然后灵光一现，这不就是兑换零钱的变种吗，只不过零钱的面额在这一题中，不再是固定的了，比如12，那么对应的“面额”就应该是1，4，9，这些完全平方数，以此类推，第一代的代码，我是将这些“面额”循环插入到一个数组中了（其实没必要，可以合并，进行代码优化），其他的思想和兑换零钱一样。" class="headerlink" title="解题思路：本题思考了一会，在想怎么使用DP呢？然后灵光一现，这不就是兑换零钱的变种吗，只不过零钱的面额在这一题中，不再是固定的了，比如12，那么对应的“面额”就应该是1，4，9，这些完全平方数，以此类推，第一代的代码，我是将这些“面额”循环插入到一个数组中了（其实没必要，可以合并，进行代码优化），其他的思想和兑换零钱一样。"></a>解题思路：本题思考了一会，在想怎么使用DP呢？然后灵光一现，这不就是兑换零钱的变种吗，只不过零钱的面额在这一题中，不再是固定的了，比如12，那么对应的“面额”就应该是1，4，9，这些完全平方数，以此类推，第一代的代码，我是将这些“面额”循环插入到一个数组中了（其实没必要，可以合并，进行代码优化），其他的思想和兑换零钱一样。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(n+<span class="number">1</span>,n);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j*j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> cur=j*j;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;cur)<span class="keyword">break</span>;</span><br><span class="line">                dp[i]=min(<span class="number">1</span>+dp[i-cur],dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt; 给定正整数 &lt;em&gt;n&lt;/em&gt;，找到若干个完全平方数（比如 &lt;code&gt;1, 4, 9, 16, ...&lt;/code&gt;）使得它们的和等于 &lt;em&gt;n&lt;/em&gt;。你需要让组成和的完全平方数的个数最少。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/categories/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>152乘积最大子序列</title>
    <link href="https://cblog.club/ck3865rkr00062wg4aixjb3k3.html"/>
    <id>https://cblog.club/ck3865rkr00062wg4aixjb3k3.html</id>
    <published>2019-11-21T03:30:32.000Z</published>
    <updated>2019-11-21T03:35:40.032Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p> 给定一个整数数组 <code>nums</code> ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。 </p><a id="more"></a><blockquote><p><strong>示例 1:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">-2</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">6</span></span><br><span class="line">解释: 子数组 [<span class="number">2</span>,<span class="number">3</span>] 有最大乘积 <span class="number">6</span>。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">-2</span>,<span class="number">0</span>,<span class="number">-1</span>]</span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line">解释: 结果不能为 <span class="number">2</span>, 因为 [<span class="number">-2</span>,<span class="number">-1</span>] 不是子数组。</span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：刚开始，我觉得非常简单，是一道特别基础的DP题目，但是后来提交的时候才发现，欠考虑了，dp-i-代表以当前节点为终止结点的最大连乘值，但是这一题特别就特别在他有负的值，所以我们不能只保存最大的连乘值，我们还要保存最小的连乘值，然后取前一个最大连乘值的时候就要注意，如果当前节点是负数，那我就要去最小的连乘值了，所以采用两个dp，一个存最大，一个存最小，（最大的来源要有最小这个因素）最后去取最大即可。"><a href="#解题思路：刚开始，我觉得非常简单，是一道特别基础的DP题目，但是后来提交的时候才发现，欠考虑了，dp-i-代表以当前节点为终止结点的最大连乘值，但是这一题特别就特别在他有负的值，所以我们不能只保存最大的连乘值，我们还要保存最小的连乘值，然后取前一个最大连乘值的时候就要注意，如果当前节点是负数，那我就要去最小的连乘值了，所以采用两个dp，一个存最大，一个存最小，（最大的来源要有最小这个因素）最后去取最大即可。" class="headerlink" title="解题思路：刚开始，我觉得非常简单，是一道特别基础的DP题目，但是后来提交的时候才发现，欠考虑了，dp[i]代表以当前节点为终止结点的最大连乘值，但是这一题特别就特别在他有负的值，所以我们不能只保存最大的连乘值，我们还要保存最小的连乘值，然后取前一个最大连乘值的时候就要注意，如果当前节点是负数，那我就要去最小的连乘值了，所以采用两个dp，一个存最大，一个存最小，（最大的来源要有最小这个因素）最后去取最大即可。"></a>解题思路：刚开始，我觉得非常简单，是一道特别基础的DP题目，但是后来提交的时候才发现，欠考虑了，dp[i]代表以当前节点为终止结点的最大连乘值，但是这一题特别就特别在他有负的值，所以我们不能只保存最大的连乘值，我们还要保存最小的连乘值，然后取前一个最大连乘值的时候就要注意，如果当前节点是负数，那我就要去最小的连乘值了，所以采用两个dp，一个存最大，一个存最小，（最大的来源要有最小这个因素）最后去取最大即可。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size=nums.size();</span><br><span class="line">        <span class="keyword">int</span> mul_pre,mul_pre2,res,max_temp,min_temp;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(size);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp2(size);</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        dp2[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        res=dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;size;i++)&#123;</span><br><span class="line">            mul_pre=nums[i]*dp[i<span class="number">-1</span>];</span><br><span class="line">            mul_pre2=nums[i]*dp2[i<span class="number">-1</span>];</span><br><span class="line">            max_temp=max(mul_pre,mul_pre2);</span><br><span class="line">            dp[i]=max(max_temp,nums[i]);</span><br><span class="line">            min_temp=min(mul_pre,mul_pre2);</span><br><span class="line">            dp2[i]=min(min_temp,nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(res&lt;dp[i])res=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt; 给定一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/categories/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Python回顾之OOP</title>
    <link href="https://cblog.club/ck3865rxe002d2wg423mz9unt.html"/>
    <id>https://cblog.club/ck3865rxe002d2wg423mz9unt.html</id>
    <published>2019-11-20T14:27:36.000Z</published>
    <updated>2019-11-20T14:28:47.456Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面向对象的两个基本概念"><a href="#面向对象的两个基本概念" class="headerlink" title="面向对象的两个基本概念"></a>面向对象的两个基本概念</h3><p>编程语言中，一般有两种编程思维，面向过程和面向对象。</p><p>面向过程，看重的是解决问题的过程。</p><p>这好比我们解决日常生活问题差不多，分析解决问题的步骤，然后一步一步的解决。</p><p>而面向对象是一种抽象，抽象是指用分类的眼光去看世界的一种方法。</p><a id="more"></a><p>Python 就是一门面向对象的语言,</p><p>如果你学过 Java ，就知道 Java 的编程思想就是：万事万物皆对象。Python 也不例外，在解决实际问题的过程中，可以把构成问题事务分解成各个对象。</p><p>面向对象都有两个基本的概率，分别是类和对象。</p><ul><li><p>类<br>用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</p></li><li><p>对象<br>通过类定义的数据结构实例</p></li></ul><h3 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h3><p>面向对象的编程语言，也有三大特性，继承，多态和封装性。</p><ul><li><p>继承<br>即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如：一个 Dog 类型的对象派生自 Animal 类，这是模拟”是一个（is-a）”关系（例图，Dog 是一个 Animal ）。</p></li><li><p>多态<br>它是指对不同类型的变量进行相同的操作，它会根据对象（或类）类型的不同而表现出不同的行为。</p></li><li><p>封装性<br>“封装”就是将抽象得到的数据和行为（或功能）相结合，形成一个有机的整体（即类）；封装的目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只是要通过外部接口，一特定的访问权限来使用类的成员。</p></li></ul><h4 id="类方法如何调用类属性"><a href="#类方法如何调用类属性" class="headerlink" title="类方法如何调用类属性"></a>类方法如何调用类属性</h4><p>如果没有声明是类方法，方法参数中就没有 cls , 就没法通过 cls 获取到类属性。</p><p>因此类方法，想要调用类属性，需要以下步骤：</p><ul><li>在方法上面，用 @classmethon 声明该方法是类方法。只有声明了是类方法，才能使用类属性</li><li>类方法想要使用类属性，在第一个参数中，需要写上 cls , cls 是 class 的缩写，其实意思就是把这个类作为参数，传给自己，这样就可以使用类属性了。</li><li>类属性的使用方式就是 cls.变量名</li></ul><p>记住，无论是 @classmethon 还是 cls ,都是不能省去的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span>:</span></span><br><span class="line">    name=<span class="string">"lc"</span></span><br><span class="line">    age=<span class="number">18</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(cls)</span>:</span></span><br><span class="line">        print(<span class="string">"name is "</span>+cls.name)</span><br><span class="line"></span><br><span class="line">Person.get_name()</span><br></pre></td></tr></table></figure><pre><code>name is lc</code></pre><h4 id="类方法传参"><a href="#类方法传参" class="headerlink" title="类方法传参"></a>类方法传参</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span>:</span></span><br><span class="line">    name=<span class="string">"lc"</span></span><br><span class="line">    age=<span class="number">18</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(cls,str)</span>:</span></span><br><span class="line">        print(<span class="string">"name is "</span>+cls.name+str)</span><br><span class="line"></span><br><span class="line">Person.get_name(<span class="string">"1998"</span>)</span><br></pre></td></tr></table></figure><pre><code>name is lc1998</code></pre><h4 id="修改和增加类属性"><a href="#修改和增加类属性" class="headerlink" title="修改和增加类属性"></a>修改和增加类属性</h4><ul><li>从内部增加和修改类属性</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span>:</span></span><br><span class="line">    name=<span class="string">"lc"</span></span><br><span class="line">    age=<span class="number">18</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rename</span><span class="params">(cls)</span>:</span></span><br><span class="line">        print(<span class="string">"original name is "</span>+cls.name)</span><br><span class="line">        cls.name=input(<span class="string">'please input your name:'</span>)</span><br><span class="line">        print(<span class="string">"current name is "</span>+cls.name)</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rename_customize</span><span class="params">(cls,str)</span>:</span></span><br><span class="line">        print(<span class="string">"original name is "</span>+cls.name)</span><br><span class="line">        cls.name=str</span><br><span class="line">        print(<span class="string">"current name is "</span>+cls.name)</span><br><span class="line">Person.rename_customize(<span class="string">"lemon"</span>)</span><br></pre></td></tr></table></figure><pre><code>original name is lccurrent name is lemon</code></pre><ul><li>从外部增加和修改类属性</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lc=Person()</span><br><span class="line">print(lc.name)</span><br><span class="line">lc.name=<span class="string">"lc"</span></span><br><span class="line">print(lc.name)</span><br></pre></td></tr></table></figure><pre><code>12lc</code></pre><h3 id="对象的实例化"><a href="#对象的实例化" class="headerlink" title="对象的实例化"></a>对象的实例化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#属性</span></span><br><span class="line">    name=<span class="string">"lc"</span></span><br><span class="line">    age=<span class="number">18</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#类方法</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rename</span><span class="params">(cls)</span>:</span></span><br><span class="line">        print(<span class="string">"original name is "</span>+cls.name)</span><br><span class="line">        cls.name=input(<span class="string">'please input your name:'</span>)</span><br><span class="line">        print(<span class="string">"current name is "</span>+cls.name)</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rename_customize</span><span class="params">(cls,str)</span>:</span></span><br><span class="line">        print(<span class="string">"original name is "</span>+cls.name)</span><br><span class="line">        cls.name=str</span><br><span class="line">        print(<span class="string">"current name is "</span>+cls.name)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_age</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"age is "</span>+str(self.age))</span><br><span class="line"></span><br><span class="line">lc=Person()</span><br><span class="line">lc.get_age()</span><br></pre></td></tr></table></figure><pre><code>age is 18</code></pre><p>只不过使用 cls 和 self 是我们的编程习惯，这也是我们的编程规范。</p><p>因为 cls 是 class 的缩写，代表这类 ， 而 self 代表这对象的意思。</p><p>所以啊，这里我们实例化对象的时候，就使用 self 。</p><p>而且 self 是所有类方法位于首位、默认的特殊参数。</p><p>除此之外，在这里，还要强调一个概念，当你把类实例化之后，里面的属性和方法，就不叫类属性和类方法了，改为叫实例</p><p>属性和实例方法，也可以叫对象属性和对象方法。</p><h4 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h4><ul><li>发现类属性改变了，实例属性也会改变，因为我们的实例对象就是根据类来复制出来的，类属性改变了，实例对象的属性也会跟着改变。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lemon=Person()</span><br><span class="line">Person.age=<span class="number">19</span></span><br><span class="line">lemon.get_age()</span><br></pre></td></tr></table></figure><pre><code>age is 19</code></pre><ul><li>当我们修改实例对象的属性是，类属性是不会改变的,因为每个实例都是单独的个体，不能影响到类的。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lemon=Person()</span><br><span class="line">print(Person.age)</span><br><span class="line">lemon.age=<span class="number">19</span></span><br><span class="line">print(Person.age)</span><br></pre></td></tr></table></figure><pre><code>1818</code></pre><h4 id="实例方法和类方法"><a href="#实例方法和类方法" class="headerlink" title="实例方法和类方法"></a>实例方法和类方法</h4><ul><li>如果类方法改变了，实例方法会不会跟着改变呢？答案是肯定</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#属性</span></span><br><span class="line">    name=<span class="string">"lc"</span></span><br><span class="line">    age=<span class="number">18</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#类方法</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rename</span><span class="params">(cls)</span>:</span></span><br><span class="line">        print(<span class="string">"original name is "</span>+cls.name)</span><br><span class="line">        cls.name=input(<span class="string">'please input your name:'</span>)</span><br><span class="line">        print(<span class="string">"current name is "</span>+cls.name)</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rename_customize</span><span class="params">(cls,str)</span>:</span></span><br><span class="line">        print(<span class="string">"original name is "</span>+cls.name)</span><br><span class="line">        cls.name=str</span><br><span class="line">        print(<span class="string">"current name is "</span>+cls.name)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_age</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"age is "</span>+str(self.age))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lc=Person()</span><br><span class="line">lc.get_age()</span><br></pre></td></tr></table></figure><pre><code>age is 18</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_get_age</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">"age + 1 is "</span>+str(self.age+<span class="number">1</span>))</span><br><span class="line">Person.get_age=new_get_age</span><br><span class="line">lc.get_age()</span><br></pre></td></tr></table></figure><pre><code>age + 1 is 19</code></pre><p>在这个例子中，我们需要改变类方法，就用到了<strong>类的重写</strong>。</p><p>我们使用了 类.原始函数 = 新函数 就完成类的重写。</p><h4 id="要注意的是，这里的赋值是在替换方法，并不是调用函数。所以是不能加上括号的，也就是-类-原始函数-新函数-这个写法是不对的。"><a href="#要注意的是，这里的赋值是在替换方法，并不是调用函数。所以是不能加上括号的，也就是-类-原始函数-新函数-这个写法是不对的。" class="headerlink" title="要注意的是，这里的赋值是在替换方法，并不是调用函数。所以是不能加上括号的，也就是 类.原始函数() = 新函数() 这个写法是不对的。"></a>要注意的是，这里的赋值是在替换方法，并不是调用函数。所以是不能加上括号的，也就是 类.原始函数() = 新函数() 这个写法是不对的。</h4><ul><li>那么如果实例方法改变了，类方法会改变吗？答案是肯定不会的</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#属性</span></span><br><span class="line">    name=<span class="string">"lc"</span></span><br><span class="line">    age=<span class="number">18</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#类方法</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rename</span><span class="params">(cls)</span>:</span></span><br><span class="line">        print(<span class="string">"original name is "</span>+cls.name)</span><br><span class="line">        cls.name=input(<span class="string">'please input your name:'</span>)</span><br><span class="line">        print(<span class="string">"current name is "</span>+cls.name)</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rename_customize</span><span class="params">(cls,str)</span>:</span></span><br><span class="line">        print(<span class="string">"original name is "</span>+cls.name)</span><br><span class="line">        cls.name=str</span><br><span class="line">        print(<span class="string">"current name is "</span>+cls.name)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_age</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"age is "</span>+str(self.age))</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(self,str)</span>:</span></span><br><span class="line">        print(<span class="string">"name is "</span>+str)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lc=Person()</span><br><span class="line">lc.get_age()</span><br></pre></td></tr></table></figure><pre><code>age is 18</code></pre><h4 id="我们发现也能改写（但是教程上说不可以，它出错的原因是缺少参数self）"><a href="#我们发现也能改写（但是教程上说不可以，它出错的原因是缺少参数self）" class="headerlink" title="我们发现也能改写（但是教程上说不可以，它出错的原因是缺少参数self）"></a>我们发现也能改写（但是教程上说不可以，它出错的原因是缺少参数self）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_get_name</span><span class="params">(str)</span>:</span></span><br><span class="line">        print(<span class="string">"your name is "</span>+str)</span><br><span class="line">lc.get_name=new_get_name</span><br><span class="line">lc.get_name(<span class="string">"leocode"</span>)</span><br></pre></td></tr></table></figure><pre><code>your name is leocode</code></pre><h4 id="修改实例方法，只对于这一个实例起作用"><a href="#修改实例方法，只对于这一个实例起作用" class="headerlink" title="修改实例方法，只对于这一个实例起作用"></a>修改实例方法，只对于这一个实例起作用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">leo=Person()</span><br><span class="line">leo.get_name(<span class="string">"lc"</span>)</span><br></pre></td></tr></table></figure><pre><code>name is lc</code></pre><h3 id="初始化函数（也就是构造函数）"><a href="#初始化函数（也就是构造函数）" class="headerlink" title="初始化函数（也就是构造函数）"></a>初始化函数（也就是构造函数）</h3><ul><li>初始化函数的意思是，当你创建一个实例的时候，这个函数就会被调用。</li><li>当代码在执行 dog=Animals() 的语句时，就自动调用了 _<em>init_</em>(self) 函数。</li><li>而这个 _<em>init_</em>(self) 函数就是初始化函数，也叫构造函数</li><li>构造函数格式：<code>def __init__(self,[参数1，参数2...]):</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animals</span><span class="params">()</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#初始化函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"初始化成功！"</span>)</span><br><span class="line">        </span><br><span class="line">dog=Animals()</span><br></pre></td></tr></table></figure><pre><code>初始化成功！</code></pre><h4 id="构造函数也可以传递参数"><a href="#构造函数也可以传递参数" class="headerlink" title="构造函数也可以传递参数"></a>构造函数也可以传递参数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animals</span><span class="params">()</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#初始化函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,str)</span>:</span></span><br><span class="line">        print(<span class="string">"初始化成功！"</span>+str)</span><br><span class="line">        </span><br><span class="line">dog=Animals(<span class="string">"leocode"</span>)</span><br></pre></td></tr></table></figure><pre><code>初始化成功！leocode</code></pre><h3 id="析构函数（用于销毁实例）"><a href="#析构函数（用于销毁实例）" class="headerlink" title="析构函数（用于销毁实例）"></a>析构函数（用于销毁实例）</h3><ul><li>一个在创建的时候，会调用构造函数，那么理所当然，这个当一个类销毁的时候，就会调用析构函数</li><li>格式：<code>def __del__(self,[参数1，参数2...]):</code></li><li>使用del调用析构函数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animals</span><span class="params">()</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#初始化函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,str)</span>:</span></span><br><span class="line">        print(<span class="string">"初始化成功！"</span>+str)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"实例已销毁"</span>)</span><br><span class="line">        </span><br><span class="line">dog=Animals(<span class="string">"leocode"</span>)</span><br><span class="line"><span class="keyword">del</span> dog</span><br></pre></td></tr></table></figure><pre><code>初始化成功！leocode实例已销毁</code></pre><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><ul><li>定义类的继承</li></ul><p>说到继承，你一定会联想到继承你老爸的家产之类的。</p><p>类的继承也是一样。</p><p>比如有一个旧类，是可以算平均数的。然后这时候有一个新类，也要用到算平均数，那么这时候我们就可以使用继承的方式。新类继承旧类，这样子新类也就有这个功能了。</p><p>通常情况下，我们叫旧类为父类，新类为子类。</p><p>在定义类的时候，可以在括号里写继承的类，如果不用继承类的时候，也要写继承 object 类（也可以不写），因为在 Python 中 object 类是一切类的父类。</p><p>当然上面的是单继承，Python 也是支持多继承的，具体的语法如下：</p><p>多继承有一点需要注意的：若是父类中有相同的方法名，而在子类使用时未指定，python 在圆括号中父类的顺序，从左至右搜索 ， 即方法在子类中未找到时，从左到右查找父类中是否包含方法。</p><p>那么继承的子类可以干什么呢？</p><p>继承的子类的好处：</p><ul><li>会继承父类的属性和方法</li><li>可以自己定义，覆盖父类的属性和方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animals</span><span class="params">()</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,kind,name)</span>:</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.kind=kind</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"its name is "</span>+self.name)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.kind+<span class="string">"在吃东西"</span>)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animals)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,kind,name,age)</span>:</span></span><br><span class="line">        super(Dog,self).__init__(kind,name)</span><br><span class="line">        self.age=age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.kind+<span class="string">"在吃东西,并且它"</span>+str(self.age)+<span class="string">"岁了"</span>)</span><br><span class="line">dog_a=Dog(<span class="string">"dog"</span>,<span class="string">"dz"</span>,<span class="number">2</span>)</span><br><span class="line">dog_a.get_name()</span><br><span class="line">dog_a.eat()</span><br></pre></td></tr></table></figure><pre><code>its name is dzdog在吃东西,并且它2岁了</code></pre><h4 id="子类的类型判断"><a href="#子类的类型判断" class="headerlink" title="子类的类型判断"></a>子类的类型判断</h4><p>对于 class 的继承关系来说，有些时候我们需要判断 class 的类型，该怎么办呢？</p><p>可以使用 isinstance() 函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User2</span><span class="params">(User1)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User3</span><span class="params">(User2)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">user1=User1()</span><br><span class="line">user2=User2()</span><br><span class="line">user3=User3()</span><br><span class="line"></span><br><span class="line">print(isinstance(user1,User1))</span><br><span class="line">print(isinstance(user2,User1))</span><br><span class="line">print(isinstance(user3,User2))</span><br><span class="line">print(isinstance(<span class="number">1321</span>,str))</span><br><span class="line">print(isinstance(<span class="number">1321</span>,int))</span><br><span class="line">print(type(user1))</span><br></pre></td></tr></table></figure><pre><code>TrueTrueTrueFalseTrue&lt;class &apos;__main__.User1&apos;&gt;</code></pre><ul><li>可以看到 isinstance() 不仅可以告诉我们，一个对象是否是某种类型，也可以用于基本类型的判断</li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态的概念其实不难理解，它是指对不同类型的变量进行相同的操作，它会根据对象（或类）类型的不同而表现出不同的行为。</p><p>事实上，我们经常用到多态的性质，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;1 + 2</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt;&apos;a&apos; + &apos;b&apos;</span><br><span class="line">&apos;ab&apos;</span><br></pre></td></tr></table></figure><p>可以看到，我们对两个整数进行 + 操作，会返回它们的和，对两个字符进行相同的 + 操作，会返回拼接后的字符串。</p><p>也就是说，不同类型的对象对同一消息会作出不同的响应。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.name+<span class="string">"在工作！他现在"</span>+str(self.age)+<span class="string">"岁！"</span>)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"他现在"</span>+str(self.age)+<span class="string">"岁！"</span>+self.name+<span class="string">"在工作！"</span>)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inter_work</span><span class="params">(user)</span>:</span></span><br><span class="line">    user.work()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lc=User1(<span class="string">"lc"</span>,<span class="number">22</span>)</span><br><span class="line">lemon=User2(<span class="string">"lemon"</span>,<span class="number">21</span>)</span><br><span class="line">inter_work(lc)</span><br><span class="line">inter_work(lemon)</span><br></pre></td></tr></table></figure><pre><code>lc在工作！他现在22岁！他现在21岁！lemon在工作！</code></pre><p>可以看到，lc 和 lemon 是两个不同的对象，对它们调用 inter_work 方法，它们会自动调用实际类型的 work 方法，作出不同的响应。这就是多态的魅力。</p><p>要注意喔，有了继承，才有了多态，也会有不同类的对象对同一消息会作出不同的相应。</p><h3 id="类的访问控制"><a href="#类的访问控制" class="headerlink" title="类的访问控制"></a>类的访问控制</h3><ul><li>类属性的访问控制<br>在 Java 中，有 public （公共）属性 和 private （私有）属性，这可以对属性进行访问控制。</li></ul><p>那么在 Python 中有没有属性的访问控制呢？</p><p>一般情况下，我们会使用 __private_attrs 两个下划线开头，声明该属性为私有，不能在类地外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs。</p><p>为什么只能说一般情况下呢？</p><p>因为实际上， Python 中是没有提供私有属性等功能的。</p><p>但是 Python 对属性的访问控制是靠程序员自觉的。为什么这么说呢？</p><p>看看下面的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age,account)</span>:</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self._age=age</span><br><span class="line">        self.__account=account</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get_account</span><span class="params">(self)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> self.__account</span><br><span class="line">        </span><br><span class="line">userInfo=UserInfo(<span class="string">"leocode"</span>,<span class="number">21</span>,<span class="number">199831</span>)</span><br><span class="line"><span class="comment">#输出所有属性</span></span><br><span class="line">print(dir(userInfo))</span><br><span class="line"><span class="comment">#输出构造函数中的属性</span></span><br><span class="line">print(userInfo.__dict__)</span><br><span class="line"><span class="comment">#用于验证双下划线是否是真正的私有属性</span></span><br><span class="line">print(userInfo._UserInfo__account)</span><br><span class="line">print(userInfo._age)</span><br></pre></td></tr></table></figure><pre><code>[&apos;_UserInfo__account&apos;, &apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__dict__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__module__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;__weakref__&apos;, &apos;_age&apos;, &apos;name&apos;]{&apos;name&apos;: &apos;leocode&apos;, &apos;_age&apos;: 21, &apos;_UserInfo__account&apos;: 199831}19983121</code></pre><h3 id="类专有的方法"><a href="#类专有的方法" class="headerlink" title="类专有的方法"></a>类专有的方法</h3><ul><li>一个类创建的时候，就会包含一些方法</li></ul><h3 id="方法的访问控制"><a href="#方法的访问控制" class="headerlink" title="方法的访问控制"></a>方法的访问控制</h3><ul><li>方法也可以看成类的属性（只是看成），用法是一样的</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;面向对象的两个基本概念&quot;&gt;&lt;a href=&quot;#面向对象的两个基本概念&quot; class=&quot;headerlink&quot; title=&quot;面向对象的两个基本概念&quot;&gt;&lt;/a&gt;面向对象的两个基本概念&lt;/h3&gt;&lt;p&gt;编程语言中，一般有两种编程思维，面向过程和面向对象。&lt;/p&gt;
&lt;p&gt;面向过程，看重的是解决问题的过程。&lt;/p&gt;
&lt;p&gt;这好比我们解决日常生活问题差不多，分析解决问题的步骤，然后一步一步的解决。&lt;/p&gt;
&lt;p&gt;而面向对象是一种抽象，抽象是指用分类的眼光去看世界的一种方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://cblog.club/categories/Python/"/>
    
    
      <category term="Python" scheme="https://cblog.club/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>300最长上升子序列</title>
    <link href="https://cblog.club/ck3865rlq000a2wg4911ff5po.html"/>
    <id>https://cblog.club/ck3865rlq000a2wg4911ff5po.html</id>
    <published>2019-11-20T14:13:00.000Z</published>
    <updated>2019-11-20T14:18:20.703Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p> 给定一个无序的整数数组，找到其中最长上升子序列的长度。 </p><a id="more"></a><blockquote><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">10</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">101</span>,<span class="number">18</span>]</span><br><span class="line">输出: <span class="number">4</span> </span><br><span class="line">解释: 最长的上升子序列是 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">101</span>]，它的长度是 <span class="number">4</span>。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。</li><li>你算法的时间复杂度应该为 O(<em>n2</em>) 。</li></ul><p><strong>进阶:</strong> 你能将算法的时间复杂度降低到 O(<em>n</em> log <em>n</em>) 吗?</p></blockquote><h6 id="解题思路：本题思路不是很难，但是时间复杂度在O-n-2-，想要让时间复杂度降低到-O-n-log-n-，暂时还没有想到，而且使用的已经是动态规划了（记录以当前结点为终止结点的子序列的最长长度），但是我发现其实还是多级算了一些结点，其实并不一定要一个一个遍历，我们只需要找到在当前结点之前最大的（但又是必须要小于他）的结点即可，所以暂时停留在这一步，明天重构一下，用我现在的思路。"><a href="#解题思路：本题思路不是很难，但是时间复杂度在O-n-2-，想要让时间复杂度降低到-O-n-log-n-，暂时还没有想到，而且使用的已经是动态规划了（记录以当前结点为终止结点的子序列的最长长度），但是我发现其实还是多级算了一些结点，其实并不一定要一个一个遍历，我们只需要找到在当前结点之前最大的（但又是必须要小于他）的结点即可，所以暂时停留在这一步，明天重构一下，用我现在的思路。" class="headerlink" title="解题思路：本题思路不是很难，但是时间复杂度在O(n^2)，想要让时间复杂度降低到 O(n log n)，暂时还没有想到，而且使用的已经是动态规划了（记录以当前结点为终止结点的子序列的最长长度），但是我发现其实还是多级算了一些结点，其实并不一定要一个一个遍历，我们只需要找到在当前结点之前最大的（但又是必须要小于他）的结点即可，所以暂时停留在这一步，明天重构一下，用我现在的思路。"></a>解题思路：本题思路不是很难，但是时间复杂度在O(n^2)，想要让时间复杂度降低到 O(<em>n</em> log <em>n</em>)，暂时还没有想到，而且使用的已经是动态规划了（记录以当前结点为终止结点的子序列的最长长度），但是我发现其实还是多级算了一些结点，其实并不一定要一个一个遍历，我们只需要找到在当前结点之前最大的（但又是必须要小于他）的结点即可，所以暂时停留在这一步，明天重构一下，用我现在的思路。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size=nums.size();</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_val,cur_max;</span><br><span class="line">        max_val=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(size);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;size;i++)&#123;</span><br><span class="line">            cur_max=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&lt;nums[i])&#123;</span><br><span class="line">                    dp[i]=dp[j]+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(cur_max&lt;dp[i])cur_max=dp[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i]=cur_max;</span><br><span class="line">            <span class="keyword">if</span>(max_val&lt;dp[i])max_val=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt; 给定一个无序的整数数组，找到其中最长上升子序列的长度。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/categories/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>62不同路径</title>
    <link href="https://cblog.club/ck3865rr1001q2wg403ioguu9.html"/>
    <id>https://cblog.club/ck3865rr1001q2wg403ioguu9.html</id>
    <published>2019-11-20T14:08:46.000Z</published>
    <updated>2019-11-20T14:12:20.800Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>一个机器人位于一个 <em>m x n</em> 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><a id="more"></a><blockquote><p><strong>说明：</strong>m 和 <em>n</em> 的值均不超过 100。</p><p><strong>示例 1:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: m = <span class="number">3</span>, n = <span class="number">2</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释:</span><br><span class="line">从左上角开始，总共有 <span class="number">3</span> 条路径可以到达右下角。</span><br><span class="line"><span class="number">1.</span> 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line"><span class="number">2.</span> 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line"><span class="number">3.</span> 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: m = <span class="number">7</span>, n = <span class="number">3</span></span><br><span class="line">输出: <span class="number">28</span></span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：本题其实还是蛮简单的，就是模拟一下走的路径，只能向下走和向右走，用一个二维数组模拟即可，注意的是第一行和第一列都是1，代表当前走到这里可能的路径数目（如果只有起点，算一个路径）"><a href="#解题思路：本题其实还是蛮简单的，就是模拟一下走的路径，只能向下走和向右走，用一个二维数组模拟即可，注意的是第一行和第一列都是1，代表当前走到这里可能的路径数目（如果只有起点，算一个路径）" class="headerlink" title="解题思路：本题其实还是蛮简单的，就是模拟一下走的路径，只能向下走和向右走，用一个二维数组模拟即可，注意的是第一行和第一列都是1，代表当前走到这里可能的路径数目（如果只有起点，算一个路径）"></a>解题思路：本题其实还是蛮简单的，就是模拟一下走的路径，只能向下走和向右走，用一个二维数组模拟即可，注意的是第一行和第一列都是1，代表当前走到这里可能的路径数目（如果只有起点，算一个路径）</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[m][n];</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][j]+dp[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;一个机器人位于一个 &lt;em&gt;m x n&lt;/em&gt; 网格的左上角 （起始点在下图中标记为“Start” ）。&lt;/p&gt;
&lt;p&gt;机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。&lt;/p&gt;
&lt;p&gt;问总共有多少条不同的路径？&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/categories/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>55跳跃游戏</title>
    <link href="https://cblog.club/ck3865rqm001j2wg430dxgrfn.html"/>
    <id>https://cblog.club/ck3865rqm001j2wg430dxgrfn.html</id>
    <published>2019-11-20T14:03:59.000Z</published>
    <updated>2019-11-20T14:08:02.392Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个位置。</p><a id="more"></a><blockquote><p><strong>示例 1:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 我们可以先跳 <span class="number">1</span> 步，从位置 <span class="number">0</span> 到达 位置 <span class="number">1</span>, 然后再从位置 <span class="number">1</span> 跳 <span class="number">3</span> 步到达最后一个位置。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">解释: 无论怎样，你总会到达索引为 <span class="number">3</span> 的位置。但该位置的最大跳跃长度是 <span class="number">0</span> ， 所以你永远不可能到达最后一个位置。</span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：本题很想走楼梯那一题，思路其实是类似的，dp-i-代表这当前结点能向后走的步数，那么如果他是0，就代表不能向后走，即返回false，状态转移方程为dp-i-max-nums-i-dp-i-1-1"><a href="#解题思路：本题很想走楼梯那一题，思路其实是类似的，dp-i-代表这当前结点能向后走的步数，那么如果他是0，就代表不能向后走，即返回false，状态转移方程为dp-i-max-nums-i-dp-i-1-1" class="headerlink" title="解题思路：本题很想走楼梯那一题，思路其实是类似的，dp[i]代表这当前结点能向后走的步数，那么如果他是0，就代表不能向后走，即返回false，状态转移方程为dp[i]=max(nums[i],dp[i-1]-1)"></a>解题思路：本题很想走楼梯那一题，思路其实是类似的，dp[i]代表这当前结点能向后走的步数，那么如果他是0，就代表不能向后走，即返回false，状态转移方程为dp[i]=max(nums[i],dp[i-1]-1)</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size=nums.size();</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(size);</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(dp[<span class="number">0</span>]==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;size;i++)&#123;</span><br><span class="line">            dp[i]=max(nums[i],dp[i<span class="number">-1</span>]<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span>(dp[i]==<span class="number">0</span>&amp;&amp;i!=size<span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;给定一个非负整数数组，你最初位于数组的第一个位置。&lt;/p&gt;
&lt;p&gt;数组中的每个元素代表你在该位置可以跳跃的最大长度。&lt;/p&gt;
&lt;p&gt;判断你是否能够到达最后一个位置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/categories/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>198打家劫舍</title>
    <link href="https://cblog.club/ck3865rl300082wg47pky1f8v.html"/>
    <id>https://cblog.club/ck3865rl300082wg47pky1f8v.html</id>
    <published>2019-11-19T12:06:04.000Z</published>
    <updated>2019-11-19T12:17:25.556Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>在不触动警报装置的情况下，</strong>能够偷窃到的最高金额。</p><a id="more"></a><blockquote><p><strong>示例 1:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: 偷窃 <span class="number">1</span> 号房屋 (金额 = <span class="number">1</span>) ，然后偷窃 <span class="number">3</span> 号房屋 (金额 = <span class="number">3</span>)。</span><br><span class="line">     偷窃到的最高金额 = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">12</span></span><br><span class="line">解释: 偷窃 <span class="number">1</span> 号房屋 (金额 = <span class="number">2</span>), 偷窃 <span class="number">3</span> 号房屋 (金额 = <span class="number">9</span>)，接着偷窃 <span class="number">5</span> 号房屋 (金额 = <span class="number">1</span>)。</span><br><span class="line">     偷窃到的最高金额 = <span class="number">2</span> + <span class="number">9</span> + <span class="number">1</span> = <span class="number">12</span> 。</span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：本题还算是比较简单，仔细分析一下还是能做出来的，状态转移方程dp-i-max-dp-i-2-nums-i-dp-i-3-nums-i-因为要隔着一个，那么就只能考虑这俩个，因为再往前就会影响到其他的房间了（不是相互独立的了），还有就是如果i-3没有的话，就直接选dp-i-2-nums-i-即可。"><a href="#解题思路：本题还算是比较简单，仔细分析一下还是能做出来的，状态转移方程dp-i-max-dp-i-2-nums-i-dp-i-3-nums-i-因为要隔着一个，那么就只能考虑这俩个，因为再往前就会影响到其他的房间了（不是相互独立的了），还有就是如果i-3没有的话，就直接选dp-i-2-nums-i-即可。" class="headerlink" title="解题思路：本题还算是比较简单，仔细分析一下还是能做出来的，状态转移方程dp[i]=max(dp[i-2]+nums[i],dp[i-3]+nums[i]);因为要隔着一个，那么就只能考虑这俩个，因为再往前就会影响到其他的房间了（不是相互独立的了），还有就是如果i-3没有的话，就直接选dp[i-2]+nums[i]即可。"></a>解题思路：本题还算是比较简单，仔细分析一下还是能做出来的，状态转移方程dp[i]=max(dp[i-2]+nums[i],dp[i-3]+nums[i]);因为要隔着一个，那么就只能考虑这俩个，因为再往前就会影响到其他的房间了（不是相互独立的了），还有就是如果i-3没有的话，就直接选dp[i-2]+nums[i]即可。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size=nums.size();</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">1</span>)<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(size);</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>]=nums[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> result=max(dp[<span class="number">0</span>],dp[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i<span class="number">-3</span>&lt;<span class="number">0</span>)dp[i]=dp[i<span class="number">-2</span>]+nums[i];</span><br><span class="line">            <span class="keyword">else</span> dp[i]=max(dp[i<span class="number">-2</span>]+nums[i],dp[i<span class="number">-3</span>]+nums[i]);</span><br><span class="line">            result=max(dp[i],result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，&lt;strong&gt;如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;给定一个代表每个房屋存放金额的非负整数数组，计算你&lt;strong&gt;在不触动警报装置的情况下，&lt;/strong&gt;能够偷窃到的最高金额。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/categories/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>53最大子序和</title>
    <link href="https://cblog.club/ck3865rq6001e2wg430185gpe.html"/>
    <id>https://cblog.club/ck3865rq6001e2wg430185gpe.html</id>
    <published>2019-11-19T11:57:50.000Z</published>
    <updated>2019-11-19T12:05:25.942Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p> 给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 </p><a id="more"></a><blockquote><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong></p><p>如果你已经实现复杂度为 O(<em>n</em>) 的解法，尝试使用更为精妙的分治法求解。</p></blockquote><h6 id="解题思路：本题刚开始我就在纠结于，遍历到当前元素时dp-i-的值，但是发现自己想的有点乱，借鉴了别人的思路，发现很不错，dp-i-代表以当前元素为终止元素的子序和（dp的选值就是max-以当前元素为终止结点的序列和，当前节点值-），因为我们要找的子序列一定是以某个元素为终止元素的，所以这么找一定会找到最终的结果，但是要注意的是，虽然当前元素会只用到前一个节点的dp值，但是最终结点的dp值不一定是最大的（这个要注意，和兑换零钱那种不太一样，要区别一下），最后找出其中最大的值即可。"><a href="#解题思路：本题刚开始我就在纠结于，遍历到当前元素时dp-i-的值，但是发现自己想的有点乱，借鉴了别人的思路，发现很不错，dp-i-代表以当前元素为终止元素的子序和（dp的选值就是max-以当前元素为终止结点的序列和，当前节点值-），因为我们要找的子序列一定是以某个元素为终止元素的，所以这么找一定会找到最终的结果，但是要注意的是，虽然当前元素会只用到前一个节点的dp值，但是最终结点的dp值不一定是最大的（这个要注意，和兑换零钱那种不太一样，要区别一下），最后找出其中最大的值即可。" class="headerlink" title="解题思路：本题刚开始我就在纠结于，遍历到当前元素时dp[i]的值，但是发现自己想的有点乱，借鉴了别人的思路，发现很不错，dp[i]代表以当前元素为终止元素的子序和（dp的选值就是max(以当前元素为终止结点的序列和，当前节点值)），因为我们要找的子序列一定是以某个元素为终止元素的，所以这么找一定会找到最终的结果，但是要注意的是，虽然当前元素会只用到前一个节点的dp值，但是最终结点的dp值不一定是最大的（这个要注意，和兑换零钱那种不太一样，要区别一下），最后找出其中最大的值即可。"></a>解题思路：本题刚开始我就在纠结于，遍历到当前元素时dp[i]的值，但是发现自己想的有点乱，借鉴了别人的思路，发现很不错，dp[i]代表以当前元素为终止元素的子序和（dp的选值就是max(以当前元素为终止结点的序列和，当前节点值)），因为我们要找的子序列一定是以某个元素为终止元素的，所以这么找一定会找到最终的结果，但是要注意的是，虽然当前元素会只用到前一个节点的dp值，但是最终结点的dp值不一定是最大的（这个要注意，和兑换零钱那种不太一样，要区别一下），最后找出其中最大的值即可。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size=nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(size);</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> result=dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;dp.size();i++)&#123;</span><br><span class="line">            dp[i]=max(dp[i<span class="number">-1</span>]+nums[i],nums[i]);</span><br><span class="line">            result=max(dp[i],result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt; 给定一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/categories/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>121买卖股票的最佳时机</title>
    <link href="https://cblog.club/ck3865rj600022wg43mjg9529.html"/>
    <id>https://cblog.club/ck3865rj600022wg43mjg9529.html</id>
    <published>2019-11-19T11:49:56.000Z</published>
    <updated>2019-11-19T11:57:46.887Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。</p><a id="more"></a><blockquote><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：可能是刚接触动态规划不久，一开始做这一题的时候，一直找不到状态转移方程（找这个真的不简单）-最终借鉴别人的思想，dp-i-max-前i-1天的最大利润，（当前价格-前i-1天最低的价格-，豁然开朗，找最低的价格，我想到的是使用multiset（因为set插入即有序的，比较方便，但是时间可能会慢一点）。（暴力破解也能过-）"><a href="#解题思路：可能是刚接触动态规划不久，一开始做这一题的时候，一直找不到状态转移方程（找这个真的不简单）-最终借鉴别人的思想，dp-i-max-前i-1天的最大利润，（当前价格-前i-1天最低的价格-，豁然开朗，找最低的价格，我想到的是使用multiset（因为set插入即有序的，比较方便，但是时间可能会慢一点）。（暴力破解也能过-）" class="headerlink" title="解题思路：可能是刚接触动态规划不久，一开始做这一题的时候，一直找不到状态转移方程（找这个真的不简单）,最终借鉴别人的思想，dp[i]=max(前i-1天的最大利润，（当前价格-前i-1天最低的价格))，豁然开朗，找最低的价格，我想到的是使用multiset（因为set插入即有序的，比较方便，但是时间可能会慢一点）。（暴力破解也能过= =）"></a>解题思路：可能是刚接触动态规划不久，一开始做这一题的时候，一直找不到状态转移方程（找这个真的不简单）,最终借鉴别人的思想，dp[i]=max(前i-1天的最大利润，（当前价格-前i-1天最低的价格))，豁然开朗，找最低的价格，我想到的是使用multiset（因为set插入即有序的，比较方便，但是时间可能会慢一点）。（暴力破解也能过= =）</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*class Solution &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span></span><br><span class="line"><span class="comment">        int max=0;</span></span><br><span class="line"><span class="comment">        int cur_sub;</span></span><br><span class="line"><span class="comment">        for(int j=0;j&lt;prices.size();j++)&#123;</span></span><br><span class="line"><span class="comment">            for(int i=j+1;i&lt;prices.size();i++)&#123;</span></span><br><span class="line"><span class="comment">                if(prices[j]&lt;prices[i])&#123;</span></span><br><span class="line"><span class="comment">                    cur_sub=prices[i]-prices[j];</span></span><br><span class="line"><span class="comment">                    if(max&lt;cur_sub)max=cur_sub;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return max;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size=prices.size();</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;mset;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(size);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur_sub_pre;</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;dp.size();i++)&#123;</span><br><span class="line">            mset.insert(prices[i<span class="number">-1</span>]);</span><br><span class="line">            it=mset.begin();</span><br><span class="line">            cur_sub_pre=prices[i]-*(it);</span><br><span class="line">            dp[i]=max(dp[i<span class="number">-1</span>],cur_sub_pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[size<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;给定一个数组，它的第 &lt;em&gt;i&lt;/em&gt; 个元素是一支给定股票第 &lt;em&gt;i&lt;/em&gt; 天的价格。&lt;/p&gt;
&lt;p&gt;如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。&lt;/p&gt;
&lt;p&gt;注意你不能在买入股票前卖出股票。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/categories/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>70爬楼梯</title>
    <link href="https://cblog.club/ck3865rsp001w2wg409k4fb92.html"/>
    <id>https://cblog.club/ck3865rsp001w2wg409k4fb92.html</id>
    <published>2019-11-19T11:42:03.000Z</published>
    <updated>2019-11-19T11:49:30.206Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。</p><p>你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p><a id="more"></a><blockquote><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：这一题刚开始在想，这题和动态规划有关系吗？也没有什么最优子结构什么的啊？细细一想，这不就是斐波那契数吗-（原理很类似），我们这样考虑：假设我们当前处于第四层，那么我们是怎么上来的呢？一共有两种可能，第一：从第三层上来的，第二：从第二层上来的，那么此时我们就会有两种可能，同理，第三层，第二层也都是这么上来的，故我们自底向上（动态规划的思想出现了），第一层只有一种可能，第二层有两种可能，从第三层开始，当前层-n-1-层-n-2-层-（这不就是斐波那契数列的原型吗-，只不过数不一样了）。当然，空间复杂度还可以优化为O-1-，如第二种方法所示。"><a href="#解题思路：这一题刚开始在想，这题和动态规划有关系吗？也没有什么最优子结构什么的啊？细细一想，这不就是斐波那契数吗-（原理很类似），我们这样考虑：假设我们当前处于第四层，那么我们是怎么上来的呢？一共有两种可能，第一：从第三层上来的，第二：从第二层上来的，那么此时我们就会有两种可能，同理，第三层，第二层也都是这么上来的，故我们自底向上（动态规划的思想出现了），第一层只有一种可能，第二层有两种可能，从第三层开始，当前层-n-1-层-n-2-层-（这不就是斐波那契数列的原型吗-，只不过数不一样了）。当然，空间复杂度还可以优化为O-1-，如第二种方法所示。" class="headerlink" title="解题思路：这一题刚开始在想，这题和动态规划有关系吗？也没有什么最优子结构什么的啊？细细一想，这不就是斐波那契数吗= =（原理很类似），我们这样考虑：假设我们当前处于第四层，那么我们是怎么上来的呢？一共有两种可能，第一：从第三层上来的，第二：从第二层上来的，那么此时我们就会有两种可能，同理，第三层，第二层也都是这么上来的，故我们自底向上（动态规划的思想出现了），第一层只有一种可能，第二层有两种可能，从第三层开始，当前层=(n-1)层+(n-2)层,（这不就是斐波那契数列的原型吗= =，只不过数不一样了）。当然，空间复杂度还可以优化为O(1)，如第二种方法所示。"></a>解题思路：这一题刚开始在想，这题和动态规划有关系吗？也没有什么最优子结构什么的啊？细细一想，这不就是斐波那契数吗= =（原理很类似），我们这样考虑：假设我们当前处于第四层，那么我们是怎么上来的呢？一共有两种可能，第一：从第三层上来的，第二：从第二层上来的，那么此时我们就会有两种可能，同理，第三层，第二层也都是这么上来的，故我们自底向上（动态规划的思想出现了），第一层只有一种可能，第二层有两种可能，从第三层开始，当前层=(n-1)层+(n-2)层,（这不就是斐波那契数列的原型吗= =，只不过数不一样了）。当然，空间复杂度还可以优化为O(1)，如第二种方法所示。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int climbStairs(int n) &#123;</span></span><br><span class="line"><span class="comment">        vector&lt;int&gt;dp(n+2);</span></span><br><span class="line"><span class="comment">        dp[1]=1;</span></span><br><span class="line"><span class="comment">        dp[2]=2;</span></span><br><span class="line"><span class="comment">        for(int i=3;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">            dp[i]=dp[i-1]+dp[i-2];</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return dp[n];</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pre=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cur=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-2</span>;i++)&#123;</span><br><span class="line">            sum=cur+pre;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;假设你正在爬楼梯。需要 &lt;em&gt;n&lt;/em&gt; 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。&lt;/p&gt;
&lt;p&gt;你有多少种不同的方法可以爬到楼顶呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;给定 &lt;em&gt;n&lt;/em&gt; 是一个正整数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/categories/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>322零钱兑换</title>
    <link href="https://cblog.club/ck3865rmz000j2wg4cy7k6mrh.html"/>
    <id>https://cblog.club/ck3865rmz000j2wg4cy7k6mrh.html</id>
    <published>2019-11-19T11:33:23.000Z</published>
    <updated>2019-11-19T11:41:57.625Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p> 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code>。 </p><a id="more"></a><blockquote><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: coins = [1, 2, 5], amount = 11</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: coins = [2], amount = 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure><p><strong>说明</strong>:<br>你可以认为每种硬币的数量是无限的。</p></blockquote><h6 id="解题思路：这一题是动态规划的入门题目，可以说是很经典的一道题，对于动态规划，关键在于你是否能够写出状态转移方程（能写出来就已经成功了80-），这一题的状态转移方程主要是dp-i-min-dp-i-1-dp-i-coin-其中coin为零钱的面额，最后返回dp-总金额-即可。"><a href="#解题思路：这一题是动态规划的入门题目，可以说是很经典的一道题，对于动态规划，关键在于你是否能够写出状态转移方程（能写出来就已经成功了80-），这一题的状态转移方程主要是dp-i-min-dp-i-1-dp-i-coin-其中coin为零钱的面额，最后返回dp-总金额-即可。" class="headerlink" title="解题思路：这一题是动态规划的入门题目，可以说是很经典的一道题，对于动态规划，关键在于你是否能够写出状态转移方程（能写出来就已经成功了80%），这一题的状态转移方程主要是dp[i]=min(dp[i],1+dp[i-coin])其中coin为零钱的面额，最后返回dp[总金额]即可。"></a>解题思路：这一题是动态规划的入门题目，可以说是很经典的一道题，对于动态规划，关键在于你是否能够写出状态转移方程（能写出来就已经成功了80%），这一题的状态转移方程主要是dp[i]=min(dp[i],1+dp[i-coin])其中coin为零钱的面额，最后返回dp[总金额]即可。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;</span></span><br><span class="line"><span class="comment">        vector&lt;int&gt;dp(amount+1,amount+1);</span></span><br><span class="line"><span class="comment">        dp[0]=0;</span></span><br><span class="line"><span class="comment">        for(int i=0;i&lt;=amount;i++)&#123;</span></span><br><span class="line"><span class="comment">            for(int coin:coins)&#123;</span></span><br><span class="line"><span class="comment">                if(i&lt;coin)continue;</span></span><br><span class="line"><span class="comment">                dp[i]=min(dp[i],1+dp[i-coin]);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return (dp[amount]==amount+1)?-1:dp[amount];</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;memo(amount+<span class="number">1</span>,<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">return</span> helper(coins,amount,memo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; memo)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(amount==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(memo[amount]!=<span class="number">-2</span>)<span class="keyword">return</span> memo[amount];</span><br><span class="line">        <span class="keyword">int</span> ans=__INT_MAX__;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> coin:coins)&#123;</span><br><span class="line">            <span class="keyword">if</span>(amount&lt;coin)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> sub_curcoin=helper(coins,amount-coin,memo);</span><br><span class="line">            <span class="keyword">if</span>(sub_curcoin==<span class="number">-1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            ans=min(ans,<span class="number">1</span>+sub_curcoin);</span><br><span class="line">        &#125;</span><br><span class="line">        memo[amount]=(ans==__INT_MAX__)?<span class="number">-1</span>:ans;</span><br><span class="line">        <span class="keyword">return</span> memo[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt; 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 &lt;code&gt;-1&lt;/code&gt;。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/categories/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="https://cblog.club/ck3865rzb002g2wg4ht081do3.html"/>
    <id>https://cblog.club/ck3865rzb002g2wg4ht081do3.html</id>
    <published>2019-11-19T11:10:56.000Z</published>
    <updated>2019-11-19T11:33:29.566Z</updated>
    
    <content type="html"><![CDATA[<p>最近在知乎上看到了一篇讲动态规划的文章，感觉还可以，比较好理解。</p><p>出于对作者的尊重，特别感谢作者，其知乎： <a href="https://www.zhihu.com/search?type=content&q=动态规划" target="_blank" rel="noopener">https://www.zhihu.com/search?type=content&amp;q=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92</a> </p><p>动态规划算法似乎是一种很高深莫测的算法，你会在一些面试或算法书籍的高级技巧部分看到相关内容，什么状态转移方程，重叠子问题，最优子结构等高大上的词汇也可能让你望而却步。</p><a id="more"></a><p>而且，当你去看用动态规划解决某个问题的代码时，你会觉得这样解决问题竟然如此巧妙，但却难以理解，你可能惊讶于人家是怎么想到这种解法的。</p><p>实际上，动态规划是一种常见的「算法设计技巧」，并没有什么高深莫测，至于各种高大上的术语，那是吓唬别人用的，只要你亲自体验几把，这些名词的含义其实显而易见，再简单不过了。</p><p>至于为什么最终的解法看起来如此精妙，是因为动态规划遵循一套固定的流程：<strong>递归的暴力解法 -&gt; 带备忘录的递归解法 -&gt; 非递归的动态规划解法</strong>。这个过程是层层递进的解决问题的过程，你如果没有前面的铺垫，直接看最终的非递归动态规划解法，当然会觉得牛逼而不可及了。</p><p>当然，见的多了，思考多了，是可以一步写出非递归的动态规划解法的。任何技巧都需要练习，我们先遵循这个流程走，算法设计也就这些套路，除此之外，真的没啥高深的。</p><p>以下，先通过两个个比较简单的例子：斐波那契和凑零钱问题，揭开动态规划的神秘面纱，描述上述三个流程。后续还会写几篇文章探讨如何使用动态规划技巧解决比较复杂的经典问题。</p><p>首先，第一个快被举烂了的例子，斐波那契数列。<strong>请读者不要嫌弃这个例子简单，因为简单的例子才能让你把精力充分集中在算法背后的通用思想和技巧上</strong>，而不会被那些隐晦的细节问题搞的莫名其妙。后续，困难的例子有的是。</p><p> <strong>步骤一、暴力的递归算法</strong> </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">1</span> || N == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fib(N - <span class="number">1</span>) + fib(N - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个不用多说了，学校老师讲递归的时候似乎都是拿这个举例。我们也知道这样写代码虽然简洁易懂，但是十分低效，低效在哪里？假设 n = 20，请画出递归树。</p><p>PS：但凡遇到需要递归的问题，最好都画出递归树，这对你分析算法的复杂度，寻找算法低效的原因都有巨大帮助。</p><img src="/ck3865rzb002g2wg4ht081do3/1.jpg" class=""><p>这个递归树怎么理解？就是说想要计算原问题 f(20)，我就得先计算出子问题 f(19) 和 f(18)，然后要计算 f(19)，我就要先算出子问题 f(18) 和 f(17)，以此类推。最后遇到 f(1) 或者 f(2) 的时候，结果已知，就能直接返回结果，递归树不再向下生长了。</p><p> <strong>递归算法的时间复杂度怎么计算？子问题个数乘以解决一个子问题需要的时间。</strong> </p><p>子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。</p><p>解决一个子问题的时间，在本算法中，没有循环，只有 f(n - 1) + f(n - 2) 一个加法操作，时间为 O(1)。</p><p>所以，这个算法的时间复杂度为 O(2^n)，指数级别，爆炸。</p><p>观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如 f(18) 被计算了两次，而且你可以看到，以 f(18) 为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 f(18) 这一个节点被重复计算，所以这个算法极其低效。</p><p> 这就是动态规划问题的第一个性质：<strong>重叠子问题</strong>。下面，我们想办法解决这个问题。 </p><p><strong>步骤二、带备忘录的递归解法</strong></p><p>明确了问题，其实就已经把问题解决了一半。即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。</p><p>一般使用一个数组充当这个「备忘录」，当然你也可以使用哈希表（字典），思想都是一样的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 备忘录全初始化为 0</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; memo(N + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 初始化最简情况</span></span><br><span class="line">    memo[<span class="number">1</span>] = memo[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> helper(memo, N);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; memo, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 未被计算过</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span> &amp;&amp; memo[n] == <span class="number">0</span>) </span><br><span class="line">        memo[n] = helper(memo, n - <span class="number">1</span>) + </span><br><span class="line">                  helper(memo, n - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 现在，画出递归树，你就知道「备忘录」到底做了什么。 </p><img src="/ck3865rzb002g2wg4ht081do3/2.jpg" class=""><p>实际上，带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。</p><p>递归算法的时间复杂度怎么算？子问题个数乘以解决一个子问题需要的时间。</p><p>子问题个数，即图中节点的总数，由于本算法不存在冗余计算，子问题就是 f(1), f(2), f(3) … f(20)，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)。</p><p>解决一个子问题的时间，同上，没有什么循环，时间为 O(1)。</p><p>所以，本算法的时间复杂度是 O(n)。比起暴力算法，是降维打击。</p><p>至此，带备忘录的递归解法的效率已经和动态规划一样了。实际上，这种解法和动态规划的思想已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。</p><p>啥叫「自顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 f(20)，向下逐渐分解规模，直到 f(1) 和 f(2) 触底，然后逐层返回答案，这就叫「自顶向下」。</p><p>啥叫「自底向上」？反过来，我们直接从最底下，最简单，问题规模最小的 f(1) 和 f(2) 开始往上推，直到推到我们想要的答案 f(20)，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。</p><p> <strong>步骤三、动态规划</strong> </p><p> 有了上一步「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一张表，就叫做 DP table 吧，在这张表上完成「自底向上」的推算岂不美哉！ </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(N + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">1</span>] = dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= N; i++)</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/ck3865rzb002g2wg4ht081do3/3.jpg" class=""><p>画个图就很好理解了，而且你发现这个 DP table 特别像之前那个「剪枝」后的结果，只是反过来算而已。实际上，带备忘录的递归解法中的「备忘录」，最终完成后就是这个 DP table，所以说这两种解法其实是差不多的，大部分情况下，效率也基本相同。</p><p>这里，引出「动态转移方程」这个名词，实际上就是描述问题结构的数学形式：</p><img src="/ck3865rzb002g2wg4ht081do3/4.jpg" class=""><p>为啥叫「状态转移方程」？为了听起来高端。你把 f(n) 想做一个状态 n，这个状态 n 是由状态 n - 1 和状态 n - 2 相加转移而来，这就叫状态转移，仅此而已。</p><p>你会发现，上面的几种解法中的所有操作，例如 return f(n - 1) + f(n - 2)，dp[i] = dp[i - 1] + dp[i - 2]，以及对备忘录或 DP table 的初始化操作，都是围绕这个方程式的不同表现形式。可见列出「状态转移方程」的重要性，它是解决问题的核心。很容易发现，其实状态转移方程直接代表着暴力解法。</p><p><strong>千万不要看不起暴力解，动态规划问题最困难的就是写出状态转移方程</strong>，即这个暴力解。优化方法无非是用备忘录或者 DP table，再无奥妙可言。</p><p>这个例子的最后，讲一个细节优化。细心的读者会发现，根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 O(1)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span> prev = <span class="number">0</span>, curr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = prev + curr;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有人会问，动态规划的另一个重要特性「最优子结构」，怎么没有涉及？下面会涉及。斐波那契数列的例子严格来说不算动态规划，以上旨在演示算法设计螺旋上升的过程。当问题中要求求一个最优解或在代码中看到循环和 max、min 等函数时，十有八九，需要动态规划大显身手。</p><p>下面，看第二个例子，凑零钱问题，有了上面的详细铺垫，这个问题会很快解决。</p><p>题目：给你 k 种面值的硬币，面值分别为 c1, c2 … ck，再给一个总金额 n，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，则回答 -1 。</p><p>比如说，k = 3，面值分别为 1，2，5，总金额 n = 11，那么最少需要 3 枚硬币，即 11 = 5 + 5 + 1 。下面走流程。</p><p><strong>一、暴力解法</strong></p><p>首先是最困难的一步，写出状态转移方程，这个问题比较好写：</p><img src="/ck3865rzb002g2wg4ht081do3/5.jpg" class=""><p>其实，这个方程就用到了<strong>「最优子结构」性质：原问题的解由子问题的最优解构成。</strong>即 f(11) 由 f(10), f(9), f(6) 的最优解转移而来。</p><p>记住，<strong>要符合「最优子结构」，子问题间必须互相独立。</strong>啥叫相互独立？你肯定不想看数学证明，我用一个直观的例子来讲解。</p><p>比如说，你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。</p><p>得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。</p><p>但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，此消彼长。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。</p><p>回到凑零钱问题，显然子问题之间没有相互制约，而是互相独立的。所以这个状态转移方程是可以得到正确答案的。</p><p>之后就没啥难点了，按照方程写暴力递归算法即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">        <span class="comment">// 金额不可达</span></span><br><span class="line">        <span class="keyword">if</span> (amount - coin &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> subProb = coinChange(coins, amount - coin);</span><br><span class="line">        <span class="comment">// 子问题无解</span></span><br><span class="line">        <span class="keyword">if</span> (subProb == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        ans = min(ans, subProb + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans == INT_MAX ? <span class="number">-1</span> : ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 画出递归树： </p><img src="/ck3865rzb002g2wg4ht081do3/6.jpg" class=""><p> 时间复杂度分析：子问题总数 x 每个子问题的时间。子问题总数为递归树节点个数，这个比较难看出来，是 O(n^k)，总之是指数级别的。每个子问题中含有一个 for 循环，复杂度为 O(k)。所以总时间复杂度为 O(k*n^k)，指数级别。 </p><p><strong>二、带备忘录的递归算法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 备忘录初始化为 -2</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; memo(amount + <span class="number">1</span>, <span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">return</span> helper(coins, amount, memo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; memo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (memo[amount] != <span class="number">-2</span>) <span class="keyword">return</span> memo[amount];</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">        <span class="comment">// 金额不可达</span></span><br><span class="line">        <span class="keyword">if</span> (amount - coin &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> subProb = helper(coins, amount - coin, memo);</span><br><span class="line">        <span class="comment">// 子问题无解</span></span><br><span class="line">        <span class="keyword">if</span> (subProb == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        ans = min(ans, subProb + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录本轮答案</span></span><br><span class="line">    memo[amount] = (ans == INT_MAX) ? <span class="number">-1</span> : ans;</span><br><span class="line">    <span class="keyword">return</span> memo[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 不画图了，很显然「备忘录」大大减小了子问题数目，完全消除了子问题的冗余，所以子问题总数不会超过金额数 n，即子问题数目为 O(n)。处理一个子问题的时间不变，仍是 O(k)，所以总的时间复杂度是 O(kn)。 </p><p> <strong>三、动态规划</strong> </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(amount + <span class="number">1</span>, amount + <span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.size(); i++) &#123;</span><br><span class="line">        <span class="comment">// 内层 for 在求所有子问题 + 1 的最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i - coin &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dp[i] = min(dp[i], <span class="number">1</span> + dp[i - coin]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (dp[amount] == amount + <span class="number">1</span>) ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/ck3865rzb002g2wg4ht081do3/7.jpg" class=""><p><strong>最后总结</strong></p><p>如果你不太了解动态规划，还能看到这里，真得给你鼓掌，相信你已经掌握了这个算法的设计技巧。</p><p>计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举，穷举所有可能性。算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。</p><p>列出动态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。</p><p>备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门，除此之外，试问，还能玩出啥花活？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在知乎上看到了一篇讲动态规划的文章，感觉还可以，比较好理解。&lt;/p&gt;
&lt;p&gt;出于对作者的尊重，特别感谢作者，其知乎： &lt;a href=&quot;https://www.zhihu.com/search?type=content&amp;q=动态规划&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.zhihu.com/search?type=content&amp;amp;q=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;动态规划算法似乎是一种很高深莫测的算法，你会在一些面试或算法书籍的高级技巧部分看到相关内容，什么状态转移方程，重叠子问题，最优子结构等高大上的词汇也可能让你望而却步。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://cblog.club/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://cblog.club/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>PyTorch_Day2</title>
    <link href="https://cblog.club/ck3865rue00222wg4aoleaa6z.html"/>
    <id>https://cblog.club/ck3865rue00222wg4aoleaa6z.html</id>
    <published>2019-11-19T03:26:51.000Z</published>
    <updated>2019-11-20T14:33:08.085Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Autograd-自动求导机制"><a href="#Autograd-自动求导机制" class="headerlink" title="Autograd: 自动求导机制"></a>Autograd: 自动求导机制</h2><p>PyTorch 中所有神经网络的核心是 autograd 包。 我们先简单介绍一下这个包，然后训练第一个简单的神经网络。<br>autograd包为张量上的所有操作提供了自动求导。 它是一个在运行时定义的框架，这意味着反向传播是根据你的代码来确定如何运行，并且每次迭代可以是不同的。</p><h3 id="张量Tensor"><a href="#张量Tensor" class="headerlink" title="张量Tensor"></a>张量Tensor</h3><ul><li>torch.Tensor 是包的核心类。如果将其属性 .requires_grad 设置为 True，则会开始跟踪针对 tensor 的所有操作。完成计算后，您可以调用 .backward() 来自动计算所有梯度。该张量的梯度将累积到 .grad 属性中。</li><li>要停止 tensor 历史记录的跟踪，您可以调用 .detach()，它将其与计算历史记录分离，并防止将来的计算被跟踪。</li><li>要停止跟踪历史记录（和使用内存），您还可以将代码块使用 with torch.no_grad(): 包装起来。在评估模型时，这是特别有用，因为模型在训练阶段具有 requires_grad = True 的可训练参数有利于调参，但在评估阶段我们不需要梯度。</li><li>还有一个类对于 autograd 实现非常重要那就是 Function。Tensor 和 Function 互相连接并构建一个非循环图，它保存整个完整的计算过程的历史信息。每个张量都有一个 .grad_fn 属性保存着创建了张量的 Function 的引用，（如果用户自己创建张量，则grad_fn 是 None ）。</li><li>如果你想计算导数，你可以调用 Tensor.backward()。如果 Tensor 是标量（即它包含一个元素数据），则不需要指定任何参数backward()，但是如果它有更多元素，则需要指定一个gradient 参数来指定张量的形状。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br></pre></td></tr></table></figure><h4 id="创建一个tensor张量，并且设置requires-grad-True用来追踪他的计算历史"><a href="#创建一个tensor张量，并且设置requires-grad-True用来追踪他的计算历史" class="headerlink" title="创建一个tensor张量，并且设置requires_grad=True用来追踪他的计算历史"></a>创建一个tensor张量，并且设置requires_grad=True用来追踪他的计算历史</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=torch.ones(<span class="number">2</span>,<span class="number">2</span>,requires_grad=<span class="literal">True</span>)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><pre><code>tensor([[1., 1.],        [1., 1.]], requires_grad=True)</code></pre><h4 id="结果y已经被计算出来了，所以，grad-fn已经被自动生成了"><a href="#结果y已经被计算出来了，所以，grad-fn已经被自动生成了" class="headerlink" title="结果y已经被计算出来了，所以，grad_fn已经被自动生成了"></a>结果y已经被计算出来了，所以，grad_fn已经被自动生成了</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y=x+<span class="number">2</span></span><br><span class="line">print(y)</span><br><span class="line">print(y .grad_fn)</span><br></pre></td></tr></table></figure><pre><code>tensor([[3., 3.],        [3., 3.]], grad_fn=&lt;AddBackward0&gt;)&lt;AddBackward0 object at 0x000001A29043E080&gt;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">z=y*y*<span class="number">3</span></span><br><span class="line"><span class="comment">#mean() 返回数组的算术平均值</span></span><br><span class="line">out=z.mean()</span><br><span class="line">print(z,out)</span><br></pre></td></tr></table></figure><pre><code>tensor([[27., 27.],        [27., 27.]], grad_fn=&lt;MulBackward0&gt;) tensor(27., grad_fn=&lt;MeanBackward0&gt;)</code></pre><h4 id="requires-grad-…-可以改变现有张量的-requires-grad属性。-如果没有指定的话，默认输入的flag是-False"><a href="#requires-grad-…-可以改变现有张量的-requires-grad属性。-如果没有指定的话，默认输入的flag是-False" class="headerlink" title=".requires_grad_( … ) 可以改变现有张量的 requires_grad属性。 如果没有指定的话，默认输入的flag是 False"></a>.requires_grad_( … ) 可以改变现有张量的 requires_grad属性。 如果没有指定的话，默认输入的flag是 False</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a=torch.randn(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">a=(a*<span class="number">3</span>)/(a<span class="number">-1</span>)</span><br><span class="line">print(a.requires_grad)</span><br><span class="line">a.requires_grad_(<span class="literal">True</span>)</span><br><span class="line">print(a.requires_grad)</span><br><span class="line">b=(a*a).sum()</span><br><span class="line">print(b.grad_fn)</span><br></pre></td></tr></table></figure><pre><code>FalseTrue&lt;SumBackward0 object at 0x000001A29097A748&gt;</code></pre><h3 id="梯度Gradient"><a href="#梯度Gradient" class="headerlink" title="梯度Gradient"></a>梯度Gradient</h3><p>反向传播，因为上文中的out是一个纯量(scalar)，out.backward()等于out.backwad(torch.tensor(1))</p><ul><li>x梯度计算不是很理解原理</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#out.backward()       #只能使用一次 </span></span><br><span class="line">print(x.grad)</span><br></pre></td></tr></table></figure><pre><code>tensor([[4.5000, 4.5000],        [4.5000, 4.5000]])</code></pre><h4 id="现在让我们看一个雅可比向量积的例子：-不理解"><a href="#现在让我们看一个雅可比向量积的例子：-不理解" class="headerlink" title="现在让我们看一个雅可比向量积的例子：(不理解= =)"></a>现在让我们看一个雅可比向量积的例子：(不理解= =)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x=torch.randn(<span class="number">3</span>,requires_grad=<span class="literal">True</span>)</span><br><span class="line">y=x*<span class="number">2</span></span><br><span class="line"><span class="comment">#torch.norm是对输入的Tensor求范数</span></span><br><span class="line"><span class="keyword">while</span> y.data.norm()&lt;<span class="number">1000</span>:</span><br><span class="line">    y=y*<span class="number">2</span></span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure><pre><code>tensor([-340.3439, 1044.5084, -227.5869], grad_fn=&lt;MulBackward0&gt;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gradients=torch.tensor([<span class="number">0.1</span>,<span class="number">1.0</span>,<span class="number">0.0001</span>],dtype=torch.float)</span><br><span class="line"><span class="comment">#y.backward(gradients)</span></span><br><span class="line">print(x.grad)</span><br></pre></td></tr></table></figure><pre><code>tensor([5.1200e+01, 5.1200e+02, 5.1200e-02])</code></pre><h4 id="如果-requires-grad-True但是你又不希望进行autograd的计算，-那么可以将变量包裹在-with-torch-no-grad-中"><a href="#如果-requires-grad-True但是你又不希望进行autograd的计算，-那么可以将变量包裹在-with-torch-no-grad-中" class="headerlink" title="如果.requires_grad=True但是你又不希望进行autograd的计算， 那么可以将变量包裹在 with torch.no_grad()中:"></a>如果.requires_grad=True但是你又不希望进行autograd的计算， 那么可以将变量包裹在 with torch.no_grad()中:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(x.requires_grad)</span><br><span class="line">print((x**<span class="number">2</span>).requires_grad)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    print((x**<span class="number">2</span>).requires_grad)</span><br></pre></td></tr></table></figure><pre><code>TrueTrueFalse</code></pre><h2 id="神经网络Neural-Networks"><a href="#神经网络Neural-Networks" class="headerlink" title="神经网络Neural Networks"></a>神经网络Neural Networks</h2><p>神经网络可以通过 torch.nn 包来构建。<br>上一讲已经讲过了autograd，nn包依赖autograd包来定义模型并求导。 一个nn.Module包含各个层和一个forward(input)方法，该方法返回output。<br>例如，看一下数字图片识别的网络：</p><img src="/ck3865rue00222wg4aoleaa6z/1.jpg" class=""><p>它是一个简单的前馈神经网络，它接受一个输入，然后一层接着一层地传递，最后输出计算的结果。<br>神经网络的典型训练过程如下：</p><ul><li>定义包含一些可学习的参数(或者叫权重)神经网络模型；</li><li>在数据集上迭代；</li><li>通过神经网络处理输入；</li><li>计算损失(输出结果和正确值的差值大小)；</li><li>将梯度反向传播回网络的参数；</li><li>更新网络的参数，主要使用如下简单的更新原则： weight = weight - learning_rate * gradient</li></ul><h3 id="定义一个网络"><a href="#定义一个网络" class="headerlink" title="定义一个网络"></a>定义一个网络</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#继承</span></span><br><span class="line">        super(Net,self).__init__()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#建立了两个卷积层，self.conv1, self.conv2，注意，这些层都是不包含激活函数的</span></span><br><span class="line">        self.conv1=nn.Conv2d(<span class="number">1</span>,<span class="number">6</span>,<span class="number">5</span>)</span><br><span class="line">        self.conv2=nn.Conv2d(<span class="number">6</span>,<span class="number">16</span>,<span class="number">5</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#三个全连接层</span></span><br><span class="line">        self.fc1=nn.Linear(<span class="number">16</span>*<span class="number">5</span>*<span class="number">5</span>,<span class="number">120</span>)</span><br><span class="line">        self.fc2=nn.Linear(<span class="number">120</span>,<span class="number">84</span>)</span><br><span class="line">        self.fc3=nn.Linear(<span class="number">84</span>,<span class="number">10</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        <span class="comment">#max_pooling池化操作   2x2的框</span></span><br><span class="line">        x=F.max_pool2d(F.relu(self.conv1(x)),(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line">        <span class="comment">#只写一个参数，相当于默认2x2</span></span><br><span class="line">        x=F.max_pool2d(F.relu(self.conv2(x)),<span class="number">2</span>)</span><br><span class="line">        x=x.view(<span class="number">-1</span>,self.num_falt_features(x))</span><br><span class="line">        x=F.relu(self.fc1(x))</span><br><span class="line">        x=F.relu(self.fc2(x))</span><br><span class="line">        x=self.fc3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">num_falt_features</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        size=x.size()[<span class="number">1</span>:]</span><br><span class="line">        num_features=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> size:</span><br><span class="line">            num_features*=s</span><br><span class="line">        <span class="keyword">return</span> num_features</span><br><span class="line">        </span><br><span class="line">net =Net()</span><br><span class="line">print(net)</span><br></pre></td></tr></table></figure><pre><code>Net(  (conv1): Conv2d(1, 6, kernel_size=(5, 5), stride=(1, 1))  (conv2): Conv2d(6, 16, kernel_size=(5, 5), stride=(1, 1))  (fc1): Linear(in_features=400, out_features=120, bias=True)  (fc2): Linear(in_features=120, out_features=84, bias=True)  (fc3): Linear(in_features=84, out_features=10, bias=True))</code></pre><ul><li>你只需定义forward函数,backward函数(计算梯度)在使用autograd时自动为你创建.你可以在forward函数中使用Tensor的任何操作。</li></ul><h4 id="net-parameters-返回模型需要学习的参数。"><a href="#net-parameters-返回模型需要学习的参数。" class="headerlink" title="net.parameters()返回模型需要学习的参数。"></a>net.parameters()返回模型需要学习的参数。</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">params=list(net.parameters())</span><br><span class="line">print(len(params))</span><br><span class="line">print(params[<span class="number">0</span>].size())</span><br></pre></td></tr></table></figure><pre><code>10torch.Size([6, 1, 5, 5])</code></pre><ul><li>为什么是10呢？ 因为不仅有weights，还有bias(偏置)， 10=5*2。</li><li>forward的输入和输出都是autograd.Variable.注意:这个网络(LeNet)期望的输入大小是32x32.如果使用MNIST数据集来训练这个网络,请把图片大小重新调整到32x32.</li><li>注意，2D卷积层的输入data维数是 batchsize channel height width</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input=torch.randn(<span class="number">1</span>,<span class="number">1</span>,<span class="number">32</span>,<span class="number">32</span>)</span><br><span class="line">out=net(input)</span><br><span class="line">print(out)</span><br></pre></td></tr></table></figure><pre><code>tensor([[-0.0662,  0.0852,  0.0259, -0.0536, -0.0588,  0.1479,  0.1092, -0.1086,          0.0060, -0.0747]], grad_fn=&lt;AddmmBackward&gt;)</code></pre><h4 id="将所有参数的梯度缓存清零-然后进行随机梯度的的反向传播"><a href="#将所有参数的梯度缓存清零-然后进行随机梯度的的反向传播" class="headerlink" title="将所有参数的梯度缓存清零,然后进行随机梯度的的反向传播."></a>将所有参数的梯度缓存清零,然后进行随机梯度的的反向传播.</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.zero_grad()</span><br><span class="line">out.backward(torch.randn(<span class="number">1</span>,<span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>注意</p><ul><li>torch.nn 只支持小批量输入,整个torch.nn包都只支持小批量样本,而不支持单个样本</li><li>例如,nn.Conv2d将接受一个4维的张量,每一维分别是$nSamples\times nChannels\times Height\times Width$(样本数x通道数x高x宽).</li><li>如果你有单个样本,只需使用input.unsqueeze(0)来添加其它的维数.</li></ul><h4 id="在继续之前-我们回顾一下到目前为止见过的所有类"><a href="#在继续之前-我们回顾一下到目前为止见过的所有类" class="headerlink" title="在继续之前,我们回顾一下到目前为止见过的所有类."></a>在继续之前,我们回顾一下到目前为止见过的所有类.</h4><ul><li>torch.Tensor-支持自动编程操作（如backward()）的多维数组。 同时保持梯度的张量。</li><li>nn.Module-神经网络模块.封装参数,移动到GPU上运行,导出,加载等</li><li>nn.Parameter-一种张量,当把它赋值给一个Module时,被自动的注册为参数.</li><li>autograd.Function-实现一个自动求导操作的前向和反向定义, 每个张量操作都会创建至少一个Function节点，该节点连接到创建张量并对其历史进行编码的函数。 </li></ul><h4 id="现在-我们包含了如下内容"><a href="#现在-我们包含了如下内容" class="headerlink" title="现在,我们包含了如下内容:"></a>现在,我们包含了如下内容:</h4><ul><li>定义一个神经网络</li><li>处理输入和调用backward</li></ul><h4 id="剩下的内容"><a href="#剩下的内容" class="headerlink" title="剩下的内容:"></a>剩下的内容:</h4><ul><li>计算损失值</li><li>更新神经网络的权值</li></ul><h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><ul><li>一个损失函数接受一对(output, target)作为输入(output为网络的输出,target为实际值),计算一个值来估计网络的输出和目标值相差多少。</li><li>在nn包中有几种不同的损失函数.一个简单的损失函数是:nn.MSELoss,它计算输入和目标之间的均方误差。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">out=net(input)</span><br><span class="line"><span class="comment">#一个虚拟的目标（举个例子用的）</span></span><br><span class="line">target=torch.randn(<span class="number">10</span>)</span><br><span class="line">target=target.view(<span class="number">1</span>,<span class="number">-1</span>)</span><br><span class="line">criterion=nn.MSELoss()</span><br><span class="line"></span><br><span class="line">loss=criterion(out,target)</span><br><span class="line">print(loss)</span><br></pre></td></tr></table></figure><pre><code>tensor(1.4106, grad_fn=&lt;MseLossBackward&gt;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(loss.grad_fn)</span><br><span class="line">print(loss.grad_fn.next_functions[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">print(loss.grad_fn.next_functions[<span class="number">0</span>][<span class="number">0</span>].next_functions[<span class="number">0</span>][<span class="number">0</span>])</span><br></pre></td></tr></table></figure><pre><code>&lt;MseLossBackward object at 0x000001A29B005DD8&gt;&lt;AddmmBackward object at 0x000001A29B005DD8&gt;&lt;AccumulateGrad object at 0x000001A29B083358&gt;</code></pre><p>现在,你反向跟踪loss,使用它的.grad_fn属性,你会看到向下面这样的一个计算图:</p><p>input -&gt; conv2d -&gt; relu -&gt; maxpool2d -&gt; conv2d -&gt; relu -&gt; maxpool2d -&gt; view -&gt; linear -&gt; relu -&gt; linear -&gt; relu -&gt; linear -&gt; MSELoss -&gt; loss</p><p>所以, 当你调用loss.backward(),整个图被区分为损失以及图中所有具有requires_grad = True的张量，并且其.grad 张量的梯度累积。</p><h4 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h4><ul><li><p>为了反向传播误差,我们所需做的是调用loss.backward().你需要清除已存在的梯度,否则梯度将被累加到已存在的梯度。</p></li><li><p>现在,我们将调用loss.backward(),并查看conv1层的偏置项在反向传播前后的梯度。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">net.zero_grad()</span><br><span class="line">print(net.conv1.bias.grad)</span><br><span class="line">loss.backward()</span><br><span class="line">print(net.conv1.bias.grad)</span><br></pre></td></tr></table></figure><pre><code>tensor([0., 0., 0., 0., 0., 0.])tensor([-0.0026,  0.0136, -0.0092, -0.0128, -0.0098, -0.0080])</code></pre><h4 id="更新网络的权重"><a href="#更新网络的权重" class="headerlink" title="更新网络的权重"></a>更新网络的权重</h4><p>实践中最简单的更新规则是随机梯度下降(SGD)．</p><ul><li>weight=weight−learning_rate∗gradient</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">learning_rate=<span class="number">0.01</span></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> net.parameters():</span><br><span class="line">    f.data.sub_(f.grad.data*learning_rate)</span><br></pre></td></tr></table></figure><p>然而,当你使用神经网络是,你想要使用各种不同的更新规则,比如SGD,Nesterov-SGD,Adam, RMSPROP等.为了能做到这一点,我们构建了一个包torch.optim实现了所有的这些规则.使用他们非常简单:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"></span><br><span class="line"><span class="comment">#自定义优化器</span></span><br><span class="line">optimizer=optim.SGD(net.parameters(),lr=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#在训练过程中循环</span></span><br><span class="line">optimizer.zero_grad()  <span class="comment">#将梯度缓冲区置0</span></span><br><span class="line">out=net(input)</span><br><span class="line">loss=criterion(out,target)</span><br><span class="line">loss.backward()</span><br><span class="line"><span class="comment">#更新</span></span><br><span class="line">optimizer.step()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Autograd-自动求导机制&quot;&gt;&lt;a href=&quot;#Autograd-自动求导机制&quot; class=&quot;headerlink&quot; title=&quot;Autograd: 自动求导机制&quot;&gt;&lt;/a&gt;Autograd: 自动求导机制&lt;/h2&gt;&lt;p&gt;PyTorch 中所有神经网络的
      
    
    </summary>
    
    
      <category term="PyTorch" scheme="https://cblog.club/categories/PyTorch/"/>
    
    
      <category term="PyTorch" scheme="https://cblog.club/tags/PyTorch/"/>
    
  </entry>
  
  <entry>
    <title>PyTorch_Day1</title>
    <link href="https://cblog.club/ck3865rvx00252wg4hc2u7bwv.html"/>
    <id>https://cblog.club/ck3865rvx00252wg4hc2u7bwv.html</id>
    <published>2019-11-18T12:57:55.000Z</published>
    <updated>2019-11-18T14:21:46.550Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直在看keras，但是看了之后，给我一种感觉就是：本来深度学习就已经够黑盒了，你再给我封装的这么死，我不想成为调包侠= =，然后Pytorch最近比较流行，在封装性上也没有keras那么死板，所以尝试学习一下。</p><a id="more"></a><h3 id="PyTorch简介"><a href="#PyTorch简介" class="headerlink" title="PyTorch简介"></a>PyTorch简介</h3><p>PyTorch是一个基于 Python 的科学计算包，主要定位两类人群：</p><ul><li>NumPy的替代品，可以利用GPU的性能进行计算</li><li>深度学习研究平台拥有足够的灵活性和速度</li></ul><p>要介绍PyTorch之前，不得不说一下Torch。Torch是一个有大量机器学习算法支持的科学计算框架，是一个与Numpy类似的张量（Tensor） 操作库，其特点是特别灵活，但因其采用了小众的编程语言是Lua，所以流行度不高，这也就有了PyTorch的出现。所以其实Torch是 PyTorch的前身，它们的底层语言相同，只是使用了不同的上层包装语言。</p><p>PyTorch是一个基于Torch的Python开源机器学习库，用于自然语言处理等应用程序。它主要由Facebookd的人工智能小组开发，不仅能够 实现强大的GPU加速，同时还支持动态神经网络，这一点是现在很多主流框架如TensorFlow都不支持的。 PyTorch提供了两个高级功能： <em>具有强大的GPU加速的张量计算（如Numpy）</em> 包含自动求导系统的深度神经网络。</p><p>TensorFlow和Caffe都是命令式的编程语言，而且是静态的，首先必须构建一个神经网络，然后一次又一次使用相同的结构，如果想要改 变网络的结构，就必须从头开始。但是对于PyTorch，通过反向求导技术，可以让你零延迟地任意改变神经网络的行为，而且其实现速度快。正是这一灵活性是PyTorch对比TensorFlow的最大优势。</p><p>另外，PyTorch的代码对比TensorFlow而言，更加简洁直观，底层代码也更容易看懂，这对于使用它的人来说理解底层肯定是一件令人激动的事。</p><p>所以，总结一下PyTorch的优点： <strong>支持GPU</strong>，灵活，支持动态神经网络 <strong>底层代码易于理解</strong> 命令式体验、 自定义扩展。</p><p>当然，现今任何一个深度学习框架都有其缺点，PyTorch也不例外，对比TensorFlow，其全面性处于劣势，目前PyTorch还不支持快速傅里 叶、沿维翻转张量和检查无穷与非数值张量；针对移动端、嵌入式部署以及高性能服务器端的部署其性能表现有待提升；其次因为这个框 架较新，使得他的社区没有那么强大，在文档方面其C库大多数没有文档。 </p><h3 id="PyTorch安装"><a href="#PyTorch安装" class="headerlink" title="PyTorch安装"></a>PyTorch安装</h3><p>直接官网下载： <a href="https://pytorch.org" target="_blank" rel="noopener">https://pytorch.org</a>，在anaconda中输入以下命令即可（先查看自己的cudatoolkit是什么版本，选择对应版本）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pytorch torchvision cudatoolkit=10.0 -c pytorch</span><br></pre></td></tr></table></figure><p>在下载过程中可能由于是网速不快，pytorch又有点大，所以总是下载失败，可以设置一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --<span class="built_in">set</span> remote_read_timeout_secs 600.0</span><br></pre></td></tr></table></figure><p>最后检查PyTorch是否在用GPU加速：</p><ul><li>方法一：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">a = torch.cuda.is_available()</span><br><span class="line">print(a)</span><br><span class="line">ngpu= <span class="number">1</span></span><br><span class="line"><span class="comment"># Decide which device we want to run on</span></span><br><span class="line">device = torch.device(<span class="string">"cuda:0"</span> <span class="keyword">if</span> (torch.cuda.is_available() <span class="keyword">and</span> ngpu &gt; <span class="number">0</span>) <span class="keyword">else</span> <span class="string">"cpu"</span>)</span><br><span class="line">print(device)</span><br><span class="line">print(torch.cuda.get_device_name(<span class="number">0</span>))</span><br><span class="line">print(torch.rand(<span class="number">3</span>,<span class="number">3</span>).cuda())</span><br></pre></td></tr></table></figure><p>结果如下即可（每个人显卡不一样，这里是自己的电脑配置）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">True</span></span><br><span class="line">cuda:<span class="number">0</span></span><br><span class="line">GeForce GTX <span class="number">950</span>M</span><br><span class="line">tensor([[<span class="number">0.8102</span>, <span class="number">0.1912</span>, <span class="number">0.2961</span>],</span><br><span class="line">        [<span class="number">0.9527</span>, <span class="number">0.1479</span>, <span class="number">0.8146</span>],</span><br><span class="line">        [<span class="number">0.4283</span>, <span class="number">0.3469</span>, <span class="number">0.3501</span>]], device=<span class="string">'cuda:0'</span>)</span><br></pre></td></tr></table></figure><ul><li>方法二</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.cuda.is_available()</span><br></pre></td></tr></table></figure><p>输出为<code>True</code>即可</p><h3 id="开始学习"><a href="#开始学习" class="headerlink" title="开始学习"></a>开始学习</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.cuda.is_available()</span><br></pre></td></tr></table></figure><pre><code>True</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">a = torch.cuda.is_available()</span><br><span class="line">print(a)</span><br><span class="line">ngpu= <span class="number">1</span></span><br><span class="line"><span class="comment"># Decide which device we want to run on</span></span><br><span class="line">device = torch.device(<span class="string">"cuda:0"</span> <span class="keyword">if</span> (torch.cuda.is_available() <span class="keyword">and</span> ngpu &gt; <span class="number">0</span>) <span class="keyword">else</span> <span class="string">"cpu"</span>)</span><br><span class="line">print(device)</span><br><span class="line">print(torch.cuda.get_device_name(<span class="number">0</span>))</span><br><span class="line">print(torch.rand(<span class="number">3</span>,<span class="number">3</span>).cuda())</span><br></pre></td></tr></table></figure><pre><code>Truecuda:0GeForce GTX 950Mtensor([[0.2935, 0.9656, 0.2542],        [0.3013, 0.2124, 0.9071],        [0.5502, 0.8500, 0.2255]], device=&apos;cuda:0&apos;)</code></pre><h4 id="Tensors张量，类似于Numpy里的ndarrays，同时Tensors可以使用GPU进行计算"><a href="#Tensors张量，类似于Numpy里的ndarrays，同时Tensors可以使用GPU进行计算" class="headerlink" title="Tensors张量，类似于Numpy里的ndarrays，同时Tensors可以使用GPU进行计算"></a>Tensors张量，类似于Numpy里的ndarrays，同时Tensors可以使用GPU进行计算</h4><ul><li>在开头加上from _<em>future_</em> import print_function这句之后，即使在python2.X，使用print就得像python3.X那样加括号使用python2.X中print不需要括号，而在python3.X中则需要。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><h4 id="构造一个5x3的矩阵，不初始化"><a href="#构造一个5x3的矩阵，不初始化" class="headerlink" title="构造一个5x3的矩阵，不初始化"></a>构造一个5x3的矩阵，不初始化</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=torch.empty(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><pre><code>tensor([[9.2755e-39, 8.4490e-39, 1.0286e-38],        [1.0102e-38, 1.0837e-38, 1.0286e-38],        [1.0653e-38, 1.0194e-38, 4.1328e-39],        [4.2245e-39, 4.2245e-39, 4.2245e-39],        [4.9592e-39, 9.1836e-39, 1.0561e-38]])</code></pre><h4 id="构造一个随机初始化的矩阵"><a href="#构造一个随机初始化的矩阵" class="headerlink" title="构造一个随机初始化的矩阵"></a>构造一个随机初始化的矩阵</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=torch.rand(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><pre><code>tensor([[0.9536, 0.5859, 0.3502],        [0.2301, 0.2587, 0.7727],        [0.3513, 0.1247, 0.0136],        [0.6168, 0.2126, 0.5314],        [0.8289, 0.0799, 0.9224]])</code></pre><h4 id="构造一个矩阵全为0，且数据类型为long"><a href="#构造一个矩阵全为0，且数据类型为long" class="headerlink" title="构造一个矩阵全为0，且数据类型为long"></a>构造一个矩阵全为0，且数据类型为long</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=torch.zeros(<span class="number">5</span>,<span class="number">3</span>,dtype=torch.long)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><pre><code>tensor([[0, 0, 0],        [0, 0, 0],        [0, 0, 0],        [0, 0, 0],        [0, 0, 0]])</code></pre><h4 id="构造一个张量，直接使用设定的数据"><a href="#构造一个张量，直接使用设定的数据" class="headerlink" title="构造一个张量，直接使用设定的数据"></a>构造一个张量，直接使用设定的数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=torch.tensor([<span class="number">5.5</span>,<span class="number">3</span>])</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><pre><code>tensor([5.5000, 3.0000])</code></pre><h4 id="创建一个张量（Tensor）基于已经存在的张量-这些方法将重用输入张量的属性，例如，-dtype，除非设置新的值进行覆盖"><a href="#创建一个张量（Tensor）基于已经存在的张量-这些方法将重用输入张量的属性，例如，-dtype，除非设置新的值进行覆盖" class="headerlink" title="创建一个张量（Tensor）基于已经存在的张量,这些方法将重用输入张量的属性，例如， dtype，除非设置新的值进行覆盖"></a>创建一个张量（Tensor）基于已经存在的张量,这些方法将重用输入张量的属性，例如， dtype，除非设置新的值进行覆盖</h4><ul><li>new_*方法来创建对象</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=x.new_ones(<span class="number">5</span>,<span class="number">3</span>,dtype=torch.double)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><pre><code>tensor([[1., 1., 1.],        [1., 1., 1.],        [1., 1., 1.],        [1., 1., 1.],        [1., 1., 1.]], dtype=torch.float64)</code></pre><ul><li>覆盖了dtype，但是对象的size还是相同的，只是值和类型发生了变化<ul><li>使用size方法与Numpy的shape属性返回的相同，张量也支持shape属性，后面会详细介绍</li><li>torch.Size 返回值是 tuple类型, 所以它支持tuple类型的所有操作.</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x=torch.randn_like(x,dtype=torch.float)</span><br><span class="line">print(x)</span><br><span class="line">print(x.size())</span><br></pre></td></tr></table></figure><pre><code>tensor([[ 0.3013,  0.9319, -1.0935],        [-1.9418,  0.3797,  1.4079],        [ 0.4928, -0.9644, -0.5722],        [-0.3585,  0.5682, -0.6689],        [-0.5044, -0.4755, -1.2299]])torch.Size([5, 3])</code></pre><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul><li>加法操作</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y=torch.rand(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line">print(x+y)</span><br></pre></td></tr></table></figure><pre><code>tensor([[ 0.7946,  1.0250, -0.8948],        [-1.2244,  0.6311,  1.6266],        [ 0.5959, -0.7320,  0.3882],        [-0.1263,  0.8522,  0.0948],        [-0.4211,  0.1972, -0.4704]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(torch.add(x,y))</span><br></pre></td></tr></table></figure><pre><code>tensor([[ 0.7946,  1.0250, -0.8948],        [-1.2244,  0.6311,  1.6266],        [ 0.5959, -0.7320,  0.3882],        [-0.1263,  0.8522,  0.0948],        [-0.4211,  0.1972, -0.4704]])</code></pre><h4 id="提供输出tensor作为参数"><a href="#提供输出tensor作为参数" class="headerlink" title="提供输出tensor作为参数"></a>提供输出tensor作为参数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result=torch.empty(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line">torch.add(x,y,out=result)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><pre><code>tensor([[ 0.7946,  1.0250, -0.8948],        [-1.2244,  0.6311,  1.6266],        [ 0.5959, -0.7320,  0.3882],        [-0.1263,  0.8522,  0.0948],        [-0.4211,  0.1972, -0.4704]])</code></pre><h4 id="任何-以-结尾的操作都会用结果替换原变量-例如-x-copy-y-x-t-都会改变x"><a href="#任何-以-结尾的操作都会用结果替换原变量-例如-x-copy-y-x-t-都会改变x" class="headerlink" title="任何 以 _ 结尾的操作都会用结果替换原变量. 例如: x.copy_(y), x.t_(), 都会改变x."></a>任何 以 _ 结尾的操作都会用结果替换原变量. 例如: x.copy_(y), x.t_(), 都会改变x.</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y.add_(x)</span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tensor([[ <span class="number">0.7946</span>,  <span class="number">1.0250</span>, <span class="number">-0.8948</span>],</span><br><span class="line">        [<span class="number">-1.2244</span>,  <span class="number">0.6311</span>,  <span class="number">1.6266</span>],</span><br><span class="line">        [ <span class="number">0.5959</span>, <span class="number">-0.7320</span>,  <span class="number">0.3882</span>],</span><br><span class="line">        [<span class="number">-0.1263</span>,  <span class="number">0.8522</span>,  <span class="number">0.0948</span>],</span><br><span class="line">        [<span class="number">-0.4211</span>,  <span class="number">0.1972</span>, <span class="number">-0.4704</span>]])</span><br></pre></td></tr></table></figure><h4 id="你可以使用与NumPy索引方式相同的操作来进行对张量的操作"><a href="#你可以使用与NumPy索引方式相同的操作来进行对张量的操作" class="headerlink" title="你可以使用与NumPy索引方式相同的操作来进行对张量的操作"></a>你可以使用与NumPy索引方式相同的操作来进行对张量的操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(x)</span><br><span class="line">print(x[:,<span class="number">1</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tensor([[ <span class="number">0.3013</span>,  <span class="number">0.9319</span>, <span class="number">-1.0935</span>],</span><br><span class="line">        [<span class="number">-1.9418</span>,  <span class="number">0.3797</span>,  <span class="number">1.4079</span>],</span><br><span class="line">        [ <span class="number">0.4928</span>, <span class="number">-0.9644</span>, <span class="number">-0.5722</span>],</span><br><span class="line">        [<span class="number">-0.3585</span>,  <span class="number">0.5682</span>, <span class="number">-0.6689</span>],</span><br><span class="line">        [<span class="number">-0.5044</span>, <span class="number">-0.4755</span>, <span class="number">-1.2299</span>]])</span><br><span class="line">tensor([ <span class="number">0.9319</span>,  <span class="number">0.3797</span>, <span class="number">-0.9644</span>,  <span class="number">0.5682</span>, <span class="number">-0.4755</span>])</span><br></pre></td></tr></table></figure><h4 id="torch-view-可以改变张量的维度和大小-与Numpy的reshape类似"><a href="#torch-view-可以改变张量的维度和大小-与Numpy的reshape类似" class="headerlink" title="torch.view: 可以改变张量的维度和大小, 与Numpy的reshape类似"></a>torch.view: 可以改变张量的维度和大小, 与Numpy的reshape类似</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x=torch.randn(<span class="number">4</span>,<span class="number">4</span>)</span><br><span class="line">print(x.size())</span><br><span class="line">y=x.view(<span class="number">16</span>)</span><br><span class="line"><span class="comment"># size -1 从其他维度推断</span></span><br><span class="line">z=x.view(<span class="number">-1</span>,<span class="number">8</span>)</span><br><span class="line">print(y.size())</span><br><span class="line">print(z.size())</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">torch.Size([<span class="number">4</span>, <span class="number">4</span>])</span><br><span class="line">torch.Size([<span class="number">16</span>])</span><br><span class="line">torch.Size([<span class="number">2</span>, <span class="number">8</span>])</span><br></pre></td></tr></table></figure><h4 id="如果你有只有一个元素的张量，使用-item-来得到Python数据类型的数值"><a href="#如果你有只有一个元素的张量，使用-item-来得到Python数据类型的数值" class="headerlink" title="如果你有只有一个元素的张量，使用.item()来得到Python数据类型的数值"></a>如果你有只有一个元素的张量，使用.item()来得到Python数据类型的数值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x=torch.randn(<span class="number">1</span>)</span><br><span class="line">print(x)</span><br><span class="line">print(x.item())</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tensor([<span class="number">0.0918</span>])</span><br><span class="line"><span class="number">0.0918206200003624</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前一直在看keras，但是看了之后，给我一种感觉就是：本来深度学习就已经够黑盒了，你再给我封装的这么死，我不想成为调包侠= =，然后Pytorch最近比较流行，在封装性上也没有keras那么死板，所以尝试学习一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="PyTorch" scheme="https://cblog.club/categories/PyTorch/"/>
    
    
      <category term="PyTorch" scheme="https://cblog.club/tags/PyTorch/"/>
    
      <category term="深度学习" scheme="https://cblog.club/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>347前K个高频元素</title>
    <link href="https://cblog.club/ck3865rn5000k2wg4735cbkvn.html"/>
    <id>https://cblog.club/ck3865rn5000k2wg4735cbkvn.html</id>
    <published>2019-11-18T12:06:04.000Z</published>
    <updated>2019-11-18T12:12:17.093Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p> 给定一个非空的整数数组，返回其中出现频率前 <strong>k</strong> 高的元素。 </p><a id="more"></a><blockquote><p><strong>示例 1:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>], k = <span class="number">2</span></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>], k = <span class="number">1</span></span><br><span class="line">输出: [<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>你可以假设给定的 <em>k</em> 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</li><li>你的算法的时间复杂度<strong>必须</strong>优于 O(<em>n</em> log <em>n</em>) , <em>n</em> 是数组的大小。</li></ul></blockquote><h6 id="解题思路：其实本题思路还是比较容易想到的，我们把key设计成数组中出现的元素值，value设置成其出现的次数，然后使用sort函数按照value的值进行降序排列，但是sort只能给顺序类容器排序，而map的元素是pair类型，所以我们将一个pair类型插入到数组中，然后自定义排序规则，最后在使用sort排序即可，这种自定义sort排序，还是要掌握一点，这样遇到和排序相关的题目就可以直接用即可（快排一定手撕一下）。"><a href="#解题思路：其实本题思路还是比较容易想到的，我们把key设计成数组中出现的元素值，value设置成其出现的次数，然后使用sort函数按照value的值进行降序排列，但是sort只能给顺序类容器排序，而map的元素是pair类型，所以我们将一个pair类型插入到数组中，然后自定义排序规则，最后在使用sort排序即可，这种自定义sort排序，还是要掌握一点，这样遇到和排序相关的题目就可以直接用即可（快排一定手撕一下）。" class="headerlink" title="解题思路：其实本题思路还是比较容易想到的，我们把key设计成数组中出现的元素值，value设置成其出现的次数，然后使用sort函数按照value的值进行降序排列，但是sort只能给顺序类容器排序，而map的元素是pair类型，所以我们将一个pair类型插入到数组中，然后自定义排序规则，最后在使用sort排序即可，这种自定义sort排序，还是要掌握一点，这样遇到和排序相关的题目就可以直接用即可（快排一定手撕一下）。"></a>解题思路：其实本题思路还是比较容易想到的，我们把key设计成数组中出现的元素值，value设置成其出现的次数，然后使用sort函数按照value的值进行降序排列，但是sort只能给顺序类容器排序，而map的元素是pair类型，所以我们将一个pair类型插入到数组中，然后自定义排序规则，最后在使用sort排序即可，这种自定义sort排序，还是要掌握一点，这样遇到和排序相关的题目就可以直接用即可（快排一定手撕一下）。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; topKFrequent(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;umap;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            umap[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;vec_umap(umap.begin(), umap.end());</span><br><span class="line">        sort(vec_umap.begin(), vec_umap.end(), </span><br><span class="line">        [](<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;x, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;y) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x.second &gt; y.second;</span><br><span class="line">    &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            result.push_back(vec_umap[i].first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt; 给定一个非空的整数数组，返回其中出现频率前 &lt;strong&gt;k&lt;/strong&gt; 高的元素。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>454四数相加II</title>
    <link href="https://cblog.club/ck3865rp700162wg46972hhi8.html"/>
    <id>https://cblog.club/ck3865rp700162wg46972hhi8.html</id>
    <published>2019-11-18T11:46:04.000Z</published>
    <updated>2019-11-18T12:04:23.762Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 <code>(i, j, k, l)</code> ，使得 <code>A[i] + B[j] + C[k] + D[l] = 0</code>。</p><p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。</p><a id="more"></a><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">A = [ <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">B = [<span class="number">-2</span>,<span class="number">-1</span>]</span><br><span class="line">C = [<span class="number">-1</span>, <span class="number">2</span>]</span><br><span class="line">D = [ <span class="number">0</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">两个元组如下:</span><br><span class="line"><span class="number">1.</span> (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>) -&gt; A[<span class="number">0</span>] + B[<span class="number">0</span>] + C[<span class="number">0</span>] + D[<span class="number">1</span>] = <span class="number">1</span> + (<span class="number">-2</span>) + (<span class="number">-1</span>) + <span class="number">2</span> = <span class="number">0</span></span><br><span class="line"><span class="number">2.</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>) -&gt; A[<span class="number">1</span>] + B[<span class="number">1</span>] + C[<span class="number">0</span>] + D[<span class="number">0</span>] = <span class="number">2</span> + (<span class="number">-1</span>) + (<span class="number">-1</span>) + <span class="number">0</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：本题刚开始就知道暴力破解肯定不对，O-N-4-的时间复杂度太大，所以就一直在找时间复杂度怎么才能够减小，怎么和hash结合，还是没有想到，有了别人的思路，如果分成两个双循环，我用unordered-multiset（元素可以重复出现），将A-B出现的结果存入其中，之后再双循环去找前者里是否有-C-D-的值，但是不幸的是，超时了，最后一组测试数据没有通过，怀疑是其查找的速度要比unordered-map慢，然后借鉴了别人的思路，将A和B加起来的结果放进一个hash-map中key就是A-B的和，value就是这个结果出现的次数，因为要计算最终的组合数，然后再双循环计算C-D，那么只要在之前的hash-map中去找一个数正好等于-（C-D）即可，这样的话，由于unordered-map的查找时间为O（1），那么其实时间就主要来源于两个双循环，那么时间复杂度就是O（n-2）-500x500-250000，还能接受。"><a href="#解题思路：本题刚开始就知道暴力破解肯定不对，O-N-4-的时间复杂度太大，所以就一直在找时间复杂度怎么才能够减小，怎么和hash结合，还是没有想到，有了别人的思路，如果分成两个双循环，我用unordered-multiset（元素可以重复出现），将A-B出现的结果存入其中，之后再双循环去找前者里是否有-C-D-的值，但是不幸的是，超时了，最后一组测试数据没有通过，怀疑是其查找的速度要比unordered-map慢，然后借鉴了别人的思路，将A和B加起来的结果放进一个hash-map中key就是A-B的和，value就是这个结果出现的次数，因为要计算最终的组合数，然后再双循环计算C-D，那么只要在之前的hash-map中去找一个数正好等于-（C-D）即可，这样的话，由于unordered-map的查找时间为O（1），那么其实时间就主要来源于两个双循环，那么时间复杂度就是O（n-2）-500x500-250000，还能接受。" class="headerlink" title="解题思路：本题刚开始就知道暴力破解肯定不对，O(N^4)的时间复杂度太大，所以就一直在找时间复杂度怎么才能够减小，怎么和hash结合，还是没有想到，有了别人的思路，如果分成两个双循环，我用unordered_multiset（元素可以重复出现），将A+B出现的结果存入其中，之后再双循环去找前者里是否有-(C+D)的值，但是不幸的是，超时了，最后一组测试数据没有通过，怀疑是其查找的速度要比unordered_map慢，然后借鉴了别人的思路，将A和B加起来的结果放进一个hash map中key就是A+B的和，value就是这个结果出现的次数，因为要计算最终的组合数，然后再双循环计算C+D，那么只要在之前的hash map中去找一个数正好等于-（C+D）即可，这样的话，由于unordered_map的查找时间为O（1），那么其实时间就主要来源于两个双循环，那么时间复杂度就是O（n^2）,500x500=250000，还能接受。"></a>解题思路：本题刚开始就知道暴力破解肯定不对，O(N^4)的时间复杂度太大，所以就一直在找时间复杂度怎么才能够减小，怎么和hash结合，还是没有想到，有了别人的思路，如果分成两个双循环，我用unordered_multiset（元素可以重复出现），将A+B出现的结果存入其中，之后再双循环去找前者里是否有-(C+D)的值，但是不幸的是，超时了，最后一组测试数据没有通过，怀疑是其查找的速度要比unordered_map慢，然后借鉴了别人的思路，将A和B加起来的结果放进一个hash map中key就是A+B的和，value就是这个结果出现的次数，因为要计算最终的组合数，然后再双循环计算C+D，那么只要在之前的hash map中去找一个数正好等于-（C+D）即可，这样的话，由于unordered_map的查找时间为O（1），那么其实时间就主要来源于两个双循环，那么时间复杂度就是O（n^2）,500x500=250000，还能接受。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; C, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; D)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;umap;</span><br><span class="line">        <span class="keyword">int</span> size=A.size();</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;size;j++)&#123;</span><br><span class="line">                umap[A[i]+B[j]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;size;j++)&#123;</span><br><span class="line">                <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator it=umap.find(-(C[i]+D[j]));</span><br><span class="line">                <span class="keyword">if</span>(it!=umap.end())res+=umap[-(C[i]+D[j])];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 &lt;code&gt;(i, j, k, l)&lt;/code&gt; ，使得 &lt;code&gt;A[i] + B[j] + C[k] + D[l] = 0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>652寻找重复的子树</title>
    <link href="https://cblog.club/ck3865rsh001t2wg4hm3d1opv.html"/>
    <id>https://cblog.club/ck3865rsh001t2wg4hm3d1opv.html</id>
    <published>2019-11-18T11:30:05.000Z</published>
    <updated>2019-11-18T11:44:16.095Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意<strong>一棵</strong>的根结点即可。</p><p>两棵树重复是指它们具有相同的结构以及相同的结点值。</p><a id="more"></a><blockquote><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> /   / \</span><br><span class="line">4   2   4</span><br><span class="line">   /</span><br><span class="line">  4</span><br></pre></td></tr></table></figure><p>下面是两个重复的子树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  2</span><br><span class="line"> /</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>因此，你需要以列表的形式返回上述重复子树的根结点。</p></blockquote><h6 id="解题思路：本题刚开始没有解出来，我刚开始的思路就是把键设计成一个数组，然后将其先序序列插入进去，最后再查找键，如果有和它一样的键的话，那么就是相同的子树，但是发现，这么想其实是错的，因为你先序的话，如果采用的不是递归的话，那么默认是不将空指针当作元素的，所以其实序列如果一样，但是树的结构可能是不一样的！然后借鉴了别人的想法，采用string的方法，将遍历序列转换成一个字符串，如果遇到空指针，那么就当作-，这样以来，采用递归遍历，将其遍历序列生成一个字符串，当作其键，然后value值设置成0，1，0代表没出现这个序列，1代表出现了这个序列。遍历到当前结点，只需要判断其遍历序列是否存在即可。"><a href="#解题思路：本题刚开始没有解出来，我刚开始的思路就是把键设计成一个数组，然后将其先序序列插入进去，最后再查找键，如果有和它一样的键的话，那么就是相同的子树，但是发现，这么想其实是错的，因为你先序的话，如果采用的不是递归的话，那么默认是不将空指针当作元素的，所以其实序列如果一样，但是树的结构可能是不一样的！然后借鉴了别人的想法，采用string的方法，将遍历序列转换成一个字符串，如果遇到空指针，那么就当作-，这样以来，采用递归遍历，将其遍历序列生成一个字符串，当作其键，然后value值设置成0，1，0代表没出现这个序列，1代表出现了这个序列。遍历到当前结点，只需要判断其遍历序列是否存在即可。" class="headerlink" title="解题思路：本题刚开始没有解出来，我刚开始的思路就是把键设计成一个数组，然后将其先序序列插入进去，最后再查找键，如果有和它一样的键的话，那么就是相同的子树，但是发现，这么想其实是错的，因为你先序的话，如果采用的不是递归的话，那么默认是不将空指针当作元素的，所以其实序列如果一样，但是树的结构可能是不一样的！然后借鉴了别人的想法，采用string的方法，将遍历序列转换成一个字符串，如果遇到空指针，那么就当作#，这样以来，采用递归遍历，将其遍历序列生成一个字符串，当作其键，然后value值设置成0，1，0代表没出现这个序列，1代表出现了这个序列。遍历到当前结点，只需要判断其遍历序列是否存在即可。"></a>解题思路：本题刚开始没有解出来，我刚开始的思路就是把键设计成一个数组，然后将其先序序列插入进去，最后再查找键，如果有和它一样的键的话，那么就是相同的子树，但是发现，这么想其实是错的，因为你先序的话，如果采用的不是递归的话，那么默认是不将空指针当作元素的，所以其实序列如果一样，但是树的结构可能是不一样的！然后借鉴了别人的想法，采用string的方法，将遍历序列转换成一个字符串，如果遇到空指针，那么就当作#，这样以来，采用递归遍历，将其遍历序列生成一个字符串，当作其键，然后value值设置成0，1，0代表没出现这个序列，1代表出现了这个序列。遍历到当前结点，只需要判断其遍历序列是否存在即可。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; findDuplicateSubtrees(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt;result;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;node_seq;</span><br><span class="line">        node_sequences(root,result,node_seq);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">node_sequences</span><span class="params">(TreeNode* root,<span class="built_in">vector</span>&lt;TreeNode*&gt;&amp;result,<span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&amp;node_seq)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="string">"#"</span>;</span><br><span class="line">        <span class="built_in">string</span> str=to_string(root-&gt;val)+node_sequences(root-&gt;left,result,node_seq)+node_sequences(root-&gt;right,result,node_seq);</span><br><span class="line">        <span class="keyword">if</span>(node_seq[str]==<span class="number">1</span>)result.push_back(root);</span><br><span class="line">        node_seq[str]++;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意&lt;strong&gt;一棵&lt;/strong&gt;的根结点即可。&lt;/p&gt;
&lt;p&gt;两棵树重复是指它们具有相同的结构以及相同的结点值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>理解LSTM</title>
    <link href="https://cblog.club/ck3865s01002l2wg4b666c5v0.html"/>
    <id>https://cblog.club/ck3865s01002l2wg4b666c5v0.html</id>
    <published>2019-11-17T01:38:27.000Z</published>
    <updated>2019-11-17T15:43:35.337Z</updated>
    
    <content type="html"><![CDATA[<p>SimpleRNN并不是keras中唯一的循环层，另外还有两个：LSTM和GRU。SimpleRNN最大的问题就是：在t时刻，理论上讲它能记住许多时间步之前见过的信息，但是实际上他是不可能学到这种长期依赖的。其原因就在于梯度消失问题，这一问题有点类似于在层数比较多的非循环网络（前馈网络）中观察到的效应：随着层数的增加，网络最终无法训练（具体原因没有深究，以后一定要看看论文），而LSTM和GRU就是为了解决SimpleRNN梯度消失这个问题设计的。<a id="more"></a></p><h4 id="LSTM-长短期记忆-算法的提出，是研究梯度消失的重要成果，-解决长依赖问题-。"><a href="#LSTM-长短期记忆-算法的提出，是研究梯度消失的重要成果，-解决长依赖问题-。" class="headerlink" title="LSTM(长短期记忆)算法的提出，是研究梯度消失的重要成果， 解决长依赖问题 。"></a>LSTM(长短期记忆)算法的提出，是研究梯度消失的重要成果， 解决长依赖问题 。</h4><p>所有循环神经网络都具有神经网络的重复模块链的形式。 在标准的RNN中，该重复模块将具有非常简单的结构，例如单个tanh层。标准的RNN网络如下图所示：</p><img src="/ck3865s01002l2wg4b666c5v0/1.png" class=""><p> LSTM也具有这种链式结构，但是它的重复单元不同于标准RNN网络里的单元只有一个网络层，它的内部有四个网络层。LSTMs的结构如下图所示：</p><img src="/ck3865s01002l2wg4b666c5v0/2.png" class=""><p> 在解释LSTMs的详细结构时先定义一下图中各个符号的含义，符号包括下面几种 </p><img src="/ck3865s01002l2wg4b666c5v0/3.jpg" class=""><p>图中黄色类似于CNN里的激活函数操作，粉色圆圈表示点操作，单箭头表示数据流向，箭头合并表示向量的合并（concat）操作，箭头分叉表示向量的拷贝操作 </p><h4 id="LSTM核心思想"><a href="#LSTM核心思想" class="headerlink" title="LSTM核心思想"></a>LSTM核心思想</h4><p>LSTM的关键在于细胞的状态(整个绿色的图表示的是一个cell)，和穿过细胞的那条水平线。</p><p>细胞状态类似于传送带。直接在整个链上运行，只有一些少量的线性交互。信息在上面流传保持不变会很容易。</p><img src="/ck3865s01002l2wg4b666c5v0/4.png" class=""><p>若只有上面的那条水平线是没办法实现添加或者删除信息的。而是通过一种叫做 门（gates） 的结构来实现的。</p><p>门 可以实现选择性地让信息通过，主要是通过一个 sigmoid 的神经层 和一个逐点相乘的操作来实现的。</p><img src="/ck3865s01002l2wg4b666c5v0/5.png" class=""><p>sigmoid 层输出（是一个向量）的每个元素都是一个在 0 和 1 之间的实数，表示让对应信息通过的权重（或者占比）。比如， 0 表示“不让任何信息通过”， 1 表示“让所有信息通过”。</p><p>LSTM通过三个这样的结构来实现信息的保护和控制。这三个门分别输入门、遗忘门和输出门。</p><h4 id="逐步理解LSTM"><a href="#逐步理解LSTM" class="headerlink" title="逐步理解LSTM"></a>逐步理解LSTM</h4><p>接下来通过三个门来逐步理解LSTM的原理</p><h5 id="遗忘门"><a href="#遗忘门" class="headerlink" title="遗忘门"></a>遗忘门</h5><p>在我们 LSTM 中的第一步是决定我们会从细胞状态中丢弃什么信息。这个决定通过一个称为忘记门层完成。该门会读取 h(t-1)和x(t)， 输出一个在 0到 1之间的数值即每个在细胞状态C(t-1)中的数字， 1 表示“完全保留”，0 表示“完全舍弃” 。</p><p>举个例子，在语言中我们基于已经看到的词来预测下一个词。在这个问题中，细胞状态可能包含当前主语的性别，因此正确的代词可以被选择出来。当我们看到新的主语，我们希望忘记旧的主语。 </p><img src="/ck3865s01002l2wg4b666c5v0/6.png" class=""><p> 其中h(t-1)表示的是上一个cell的输出，x(t)表示的是当前细胞的输入。σ表示sigmod函数。 </p><h5 id="输入门"><a href="#输入门" class="headerlink" title="输入门"></a>输入门</h5><p>下一步是决定给细胞状态添加哪些新的信息。这一步又分为两个步骤，首先，利用h(t-1)和x(t)通过一个称为输入门的操作来决定更新哪些信息。然后利用h(t-1)和x(t)通过一个tanh层得到新的候选细胞信息~Ct，这些信息可能会被更新到细胞信息中。这两步描述如下图所示：</p><img src="/ck3865s01002l2wg4b666c5v0/7.png" class=""><p> 下面将更新旧的细胞信息C(t-1)，变为新的细胞信息Ct。更新的规则就是通过忘记门选择忘记旧细胞信息的一部分，通过输入门选择添加候选细胞信息~Ct的一部分得到新的细胞信息Ct。更新操作如下图所示:</p><img src="/ck3865s01002l2wg4b666c5v0/8.png" class=""><h5 id="输出门"><a href="#输出门" class="headerlink" title="输出门"></a>输出门</h5><p>最终，我们需要确定输出什么值。这个输出将会基于我们的细胞状态，但是也是一个过滤后的版本。首先，我们运行一个 sigmoid 层来确定细胞状态的哪个部分将输出出去。接着，我们把细胞状态通过 tanh 进行处理（得到一个在 -1 到 1 之间的值）并将它和 sigmoid 门的输出相乘，最终我们仅仅会输出我们确定输出的那部分。</p><p> 还是拿语言模型来举例说明，在预测动词形式的时候，我们需要通过输入的主语是单数还是复数来推断输出门输出的预测动词是单数形式还是复数形式。 </p><img src="/ck3865s01002l2wg4b666c5v0/9.png" class=""><h4 id="LSTM变体"><a href="#LSTM变体" class="headerlink" title="LSTM变体"></a>LSTM变体</h4><p>下面主要讲一下其中比较著名的变种 GRU（Gated Recurrent Unit ），这是由 Cho, et al. (2014) 提出。在 GRU 中，如下图所示，只有两个门：重置门（reset gate）和更新门（update gate）。同时在这个结构中，把细胞状态和隐藏状态进行了合并。最后模型比标准的 LSTM 结构要简单，而且这个结构后来也非常流行。</p><img src="/ck3865s01002l2wg4b666c5v0/10.png" class=""><p> 其中，<strong>r</strong>表示重置门，<strong>t</strong>表示更新门。重置门决定是否将之前的状态忘记。(作用相当于合并了 LSTM 中的遗忘门和传入门）当<strong>r</strong>趋于0的时候，前一个时刻的状态信息 h(t-1)会被忘掉，隐藏状态^ht 会被重置为当前输入的信息。更新门决定是否要将隐藏状态更新为新的状态 ht(作用相当于 LSTM 中的输出门)</p><p>其中重置门为上图中前面那个门，决定了如何将新的输入信息与前面的记忆相结合。更新门为上图中后面那个门，定义了前面记忆保存到当前时间步的量。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SimpleRNN并不是keras中唯一的循环层，另外还有两个：LSTM和GRU。SimpleRNN最大的问题就是：在t时刻，理论上讲它能记住许多时间步之前见过的信息，但是实际上他是不可能学到这种长期依赖的。其原因就在于梯度消失问题，这一问题有点类似于在层数比较多的非循环网络（前馈网络）中观察到的效应：随着层数的增加，网络最终无法训练（具体原因没有深究，以后一定要看看论文），而LSTM和GRU就是为了解决SimpleRNN梯度消失这个问题设计的。
    
    </summary>
    
    
      <category term="深度学习" scheme="https://cblog.club/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="https://cblog.club/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>3无重复字符的最长子串</title>
    <link href="https://cblog.club/ck3865rp000132wg486177dj7.html"/>
    <id>https://cblog.club/ck3865rp000132wg486177dj7.html</id>
    <published>2019-11-16T15:17:37.000Z</published>
    <updated>2019-11-16T15:22:48.290Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><a id="more"></a><blockquote><p><strong>示例 1:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"abcabcbb"</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"abc"</span>，所以其长度为 <span class="number">3</span>。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"bbbbb"</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"b"</span>，所以其长度为 <span class="number">1</span>。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"pwwkew"</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"wke"</span>，所以其长度为 <span class="number">3</span>。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">"pwke"</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：本题一开始的思路就是循环当前元素，（但是没考虑到双循环，慢慢做，才发现需要-，因为我们只能确定以当前为首字母的字串的长度），然后就是使用哈希set，从当前元素向后循环，只要没出现在set中的，就插入到set中，并且使用count计数，如果见到了，就代表有重复，令count和max比较，确定是否更新，count置0，以此类推即可，但是要注意的是如果都没有见到重复元素，也要更新max值（这点忽视了，导致数据点没全部通过-）"><a href="#解题思路：本题一开始的思路就是循环当前元素，（但是没考虑到双循环，慢慢做，才发现需要-，因为我们只能确定以当前为首字母的字串的长度），然后就是使用哈希set，从当前元素向后循环，只要没出现在set中的，就插入到set中，并且使用count计数，如果见到了，就代表有重复，令count和max比较，确定是否更新，count置0，以此类推即可，但是要注意的是如果都没有见到重复元素，也要更新max值（这点忽视了，导致数据点没全部通过-）" class="headerlink" title="解题思路：本题一开始的思路就是循环当前元素，（但是没考虑到双循环，慢慢做，才发现需要= =，因为我们只能确定以当前为首字母的字串的长度），然后就是使用哈希set，从当前元素向后循环，只要没出现在set中的，就插入到set中，并且使用count计数，如果见到了，就代表有重复，令count和max比较，确定是否更新，count置0，以此类推即可，但是要注意的是如果都没有见到重复元素，也要更新max值（这点忽视了，导致数据点没全部通过~）"></a>解题思路：本题一开始的思路就是循环当前元素，（但是没考虑到双循环，慢慢做，才发现需要= =，因为我们只能确定以当前为首字母的字串的长度），然后就是使用哈希set，从当前元素向后循环，只要没出现在set中的，就插入到set中，并且使用count计数，如果见到了，就代表有重复，令count和max比较，确定是否更新，count置0，以此类推即可，但是要注意的是如果都没有见到重复元素，也要更新max值（这点忽视了，导致数据点没全部通过~）</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt;S_set;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=i;j&lt;s.size();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(S_set.count(s[j])==<span class="number">0</span>)count++; </span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(max&lt;count)max=count;</span><br><span class="line">                    count=<span class="number">0</span>;</span><br><span class="line">                    S_set.clear();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                S_set.insert(s[j]);</span><br><span class="line">                <span class="keyword">if</span>(j==s.size()<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(max&lt;count)max=count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的 &lt;strong&gt;最长子串&lt;/strong&gt; 的长度。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>771宝石与石头</title>
    <link href="https://cblog.club/ck3865ru7001z2wg403e40jrg.html"/>
    <id>https://cblog.club/ck3865ru7001z2wg403e40jrg.html</id>
    <published>2019-11-16T15:13:32.000Z</published>
    <updated>2019-11-17T01:32:43.727Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定字符串<code>J</code> 代表石头中宝石的类型，和字符串 <code>S</code>代表你拥有的石头。 <code>S</code> 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。</p><p><code>J</code> 中的字母不重复，<code>J</code> 和 <code>S</code>中的所有字符都是字母。字母区分大小写，因此<code>&quot;a&quot;</code>和<code>&quot;A&quot;</code>是不同类型的石头。</p><a id="more"></a><blockquote><p><strong>示例 1:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: J = <span class="string">"aA"</span>, S = <span class="string">"aAAbbbb"</span></span><br><span class="line">输出: <span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: J = <span class="string">"z"</span>, S = <span class="string">"ZZ"</span></span><br><span class="line">输出: <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><code>S</code> 和 <code>J</code> 最多含有50个字母。</li><li><code>J</code> 中的字符不重复。</li></ul></blockquote><h6 id="解题思路：本题是最基础的哈希集合的题目，一眼就可以看出来要使用哈希set，将J的插入到set中，然后循环S，再判断当前元素是否在J中即可，比较水。"><a href="#解题思路：本题是最基础的哈希集合的题目，一眼就可以看出来要使用哈希set，将J的插入到set中，然后循环S，再判断当前元素是否在J中即可，比较水。" class="headerlink" title="解题思路：本题是最基础的哈希集合的题目，一眼就可以看出来要使用哈希set，将J的插入到set中，然后循环S，再判断当前元素是否在J中即可，比较水。"></a>解题思路：本题是最基础的哈希集合的题目，一眼就可以看出来要使用哈希set，将J的插入到set中，然后循环S，再判断当前元素是否在J中即可，比较水。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(<span class="built_in">string</span> J, <span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt;J_set;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;J.size();i++)&#123;</span><br><span class="line">            J_set.insert(J[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(J_set.count(S[i])&gt;<span class="number">0</span>)count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;给定字符串&lt;code&gt;J&lt;/code&gt; 代表石头中宝石的类型，和字符串 &lt;code&gt;S&lt;/code&gt;代表你拥有的石头。 &lt;code&gt;S&lt;/code&gt; 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;J&lt;/code&gt; 中的字母不重复，&lt;code&gt;J&lt;/code&gt; 和 &lt;code&gt;S&lt;/code&gt;中的所有字符都是字母。字母区分大小写，因此&lt;code&gt;&amp;quot;a&amp;quot;&lt;/code&gt;和&lt;code&gt;&amp;quot;A&amp;quot;&lt;/code&gt;是不同类型的石头。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>lemon</title>
  
  <subtitle>一直在路上</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cblog.club/"/>
  <updated>2019-11-27T14:57:58.825Z</updated>
  <id>https://cblog.club/</id>
  
  <author>
    <name>lemon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>103二叉树的锯齿形层次遍历</title>
    <link href="https://cblog.club/ck3hez77m0000dwg46ejcc4vj.html"/>
    <id>https://cblog.club/ck3hez77m0000dwg46ejcc4vj.html</id>
    <published>2019-11-27T14:54:36.000Z</published>
    <updated>2019-11-27T14:57:58.825Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p> 给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 </p><a id="more"></a><blockquote><p> 例如：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>, </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line">  / \</span><br><span class="line"> <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">   /  \</span><br><span class="line">  <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><p>返回锯齿形层次遍历如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">20</span>,<span class="number">9</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：本题其实还是很简单的，只要做过层次遍历那一题，这一题很快就能写出来，只不过多了一次反转而已，而且使用一个标志位就能控制次序，这种层次遍历，主要的精彩之处，就是在于循环到当前队列的大小（很巧妙），就可以实现插入每层的结点，还有这一题返回的是int型数组，并不是结点型数组。"><a href="#解题思路：本题其实还是很简单的，只要做过层次遍历那一题，这一题很快就能写出来，只不过多了一次反转而已，而且使用一个标志位就能控制次序，这种层次遍历，主要的精彩之处，就是在于循环到当前队列的大小（很巧妙），就可以实现插入每层的结点，还有这一题返回的是int型数组，并不是结点型数组。" class="headerlink" title="解题思路：本题其实还是很简单的，只要做过层次遍历那一题，这一题很快就能写出来，只不过多了一次反转而已，而且使用一个标志位就能控制次序，这种层次遍历，主要的精彩之处，就是在于循环到当前队列的大小（很巧妙），就可以实现插入每层的结点，还有这一题返回的是int型数组，并不是结点型数组。"></a>解题思路：本题其实还是很简单的，只要做过层次遍历那一题，这一题很快就能写出来，只不过多了一次反转而已，而且使用一个标志位就能控制次序，这种层次遍历，主要的精彩之处，就是在于循环到当前队列的大小（很巧妙），就可以实现插入每层的结点，还有这一题返回的是int型数组，并不是结点型数组。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt;node;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;result;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> result;</span><br><span class="line">        node.push(root);</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">        TreeNode* p;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;cur_layers;</span><br><span class="line">        <span class="keyword">while</span>(!node.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size=node.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                p=node.front();</span><br><span class="line">                node.pop();</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;left)node.push(p-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;right)node.push(p-&gt;right);</span><br><span class="line">                cur_layers.push_back(p-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag%<span class="number">2</span>!=<span class="number">0</span>)result.push_back(cur_layers);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                reverse(cur_layers.begin(),cur_layers.end());</span><br><span class="line">                result.push_back(cur_layers);</span><br><span class="line">            &#125;</span><br><span class="line">            cur_layers.clear();</span><br><span class="line">            flag++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt; 给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="回溯" scheme="https://cblog.club/categories/leetcode/%E5%9B%9E%E6%BA%AF/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="回溯" scheme="https://cblog.club/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>79单词搜索</title>
    <link href="https://cblog.club/ck3hez7ad002tdwg41w4qg59p.html"/>
    <id>https://cblog.club/ck3hez7ad002tdwg41w4qg59p.html</id>
    <published>2019-11-27T14:48:17.000Z</published>
    <updated>2019-11-27T14:54:00.182Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><a id="more"></a><blockquote><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">board =</span><br><span class="line">[</span><br><span class="line">  [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'E'</span>],</span><br><span class="line">  [<span class="string">'S'</span>,<span class="string">'F'</span>,<span class="string">'C'</span>,<span class="string">'S'</span>],</span><br><span class="line">  [<span class="string">'A'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">给定 word = <span class="string">"ABCCED"</span>, 返回 <span class="literal">true</span>.</span><br><span class="line">给定 word = <span class="string">"SEE"</span>, 返回 <span class="literal">true</span>.</span><br><span class="line">给定 word = <span class="string">"ABCB"</span>, 返回 <span class="literal">false</span>.</span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：本题主要是借鉴了一些别人的想法，主要就是主函数循环二维数组（也就是字母表，只要找到一个能够走通的就返回true），然后回溯主要的递归函数里，主要手动模拟四个方向的选择，这一题我按照四个方向走循环，发现有问题，这一题还是需要多看看，感觉还是没彻底搞懂，主要是递归怎么返回，返回时状态不是很清楚，而且自己写递归，也是有问题，这里标记走过的点的方法可以借鉴，走过的就标记为’-’字符，那么下次如果遇到他，就代表走过了。其实像这类题目，已经类似DFS了。"><a href="#解题思路：本题主要是借鉴了一些别人的想法，主要就是主函数循环二维数组（也就是字母表，只要找到一个能够走通的就返回true），然后回溯主要的递归函数里，主要手动模拟四个方向的选择，这一题我按照四个方向走循环，发现有问题，这一题还是需要多看看，感觉还是没彻底搞懂，主要是递归怎么返回，返回时状态不是很清楚，而且自己写递归，也是有问题，这里标记走过的点的方法可以借鉴，走过的就标记为’-’字符，那么下次如果遇到他，就代表走过了。其实像这类题目，已经类似DFS了。" class="headerlink" title="解题思路：本题主要是借鉴了一些别人的想法，主要就是主函数循环二维数组（也就是字母表，只要找到一个能够走通的就返回true），然后回溯主要的递归函数里，主要手动模拟四个方向的选择，这一题我按照四个方向走循环，发现有问题，这一题还是需要多看看，感觉还是没彻底搞懂，主要是递归怎么返回，返回时状态不是很清楚，而且自己写递归，也是有问题，这里标记走过的点的方法可以借鉴，走过的就标记为’#’字符，那么下次如果遇到他，就代表走过了。其实像这类题目，已经类似DFS了。"></a>解题思路：本题主要是借鉴了一些别人的想法，主要就是主函数循环二维数组（也就是字母表，只要找到一个能够走通的就返回true），然后回溯主要的递归函数里，主要手动模拟四个方向的选择，这一题我按照四个方向走循环，发现有问题，这一题还是需要多看看，感觉还是没彻底搞懂，主要是递归怎么返回，返回时状态不是很清楚，而且自己写递归，也是有问题，这里标记走过的点的方法可以借鉴，走过的就标记为’#’字符，那么下次如果遇到他，就代表走过了。其实像这类题目，已经类似DFS了。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row=board.size();</span><br><span class="line">        <span class="keyword">int</span> col=board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(backTrack(board,word,i,j,<span class="number">0</span>))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backTrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board,<span class="built_in">string</span> word,<span class="keyword">int</span> startx,<span class="keyword">int</span> starty,<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        <span class="comment">//越界</span></span><br><span class="line">        <span class="keyword">if</span>(startx&lt;<span class="number">0</span>||startx&gt;=board.size()||starty&lt;<span class="number">0</span>||starty&gt;=board[<span class="number">0</span>].size())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//走过了，或者元素不匹配</span></span><br><span class="line">        <span class="keyword">if</span>(board[startx][starty]!=word[count]||board[startx][starty]==<span class="string">'#'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//走到最后</span></span><br><span class="line">        <span class="keyword">if</span>(count==word.size()<span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">char</span> temp=board[startx][starty];</span><br><span class="line">        <span class="comment">//代表这个点走过了</span></span><br><span class="line">        board[startx][starty]=<span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag=backTrack(board,word,startx,starty<span class="number">-1</span>,count+<span class="number">1</span>)||backTrack(board,word,startx+<span class="number">1</span>,starty,count+<span class="number">1</span>)||backTrack(board,word,startx,starty+<span class="number">1</span>,count+<span class="number">1</span>)||backTrack(board,word,startx<span class="number">-1</span>,starty,count+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//回溯，四个方向都不能走，取消走这个点</span></span><br><span class="line">        board[startx][starty]=temp;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;给定一个二维网格和一个单词，找出该单词是否存在于网格中。&lt;/p&gt;
&lt;p&gt;单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="回溯" scheme="https://cblog.club/categories/leetcode/%E5%9B%9E%E6%BA%AF/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="回溯" scheme="https://cblog.club/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>22括号生成</title>
    <link href="https://cblog.club/ck3hez78j000gdwg44xrv11bu.html"/>
    <id>https://cblog.club/ck3hez78j000gdwg44xrv11bu.html</id>
    <published>2019-11-27T14:38:50.000Z</published>
    <updated>2019-11-27T14:47:23.037Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给出 <em>n</em> 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且<strong>有效的</strong>括号组合。</p><a id="more"></a><blockquote><p>例如，给出 <em>n</em> = 3，生成结果为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">"((()))"</span>,</span><br><span class="line">  <span class="string">"(()())"</span>,</span><br><span class="line">  <span class="string">"(())()"</span>,</span><br><span class="line">  <span class="string">"()(())"</span>,</span><br><span class="line">  <span class="string">"()()()"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：本题和全排列的思维像，但是他是有规定的，比如出现）那么前边一定有一个多余的左括号。刚开始使用全排列的思想，然后去重，规定右括号出现，左边一定有一个多余的左括号，但是失败告终-，借鉴了一些，发现主要还是递归，其实回溯就是递归，个人理解只不过回溯多了一步修改的过程。那么这一题用递归的话，主要思想就是’-‘先放，并且它可以最多放三个，然后再放’-’，放右括号的前提是左边有多余的左括号。可以利用open，close参数来控制，open记录当前的’-‘的位置，close记录当前的’-’的位置，那么放有括号的条件就是open要大于close，这样代表左边有多余的（。"><a href="#解题思路：本题和全排列的思维像，但是他是有规定的，比如出现）那么前边一定有一个多余的左括号。刚开始使用全排列的思想，然后去重，规定右括号出现，左边一定有一个多余的左括号，但是失败告终-，借鉴了一些，发现主要还是递归，其实回溯就是递归，个人理解只不过回溯多了一步修改的过程。那么这一题用递归的话，主要思想就是’-‘先放，并且它可以最多放三个，然后再放’-’，放右括号的前提是左边有多余的左括号。可以利用open，close参数来控制，open记录当前的’-‘的位置，close记录当前的’-’的位置，那么放有括号的条件就是open要大于close，这样代表左边有多余的（。" class="headerlink" title="解题思路：本题和全排列的思维像，但是他是有规定的，比如出现）那么前边一定有一个多余的左括号。刚开始使用全排列的思想，然后去重，规定右括号出现，左边一定有一个多余的左括号，但是失败告终- -，借鉴了一些，发现主要还是递归，其实回溯就是递归，个人理解只不过回溯多了一步修改的过程。那么这一题用递归的话，主要思想就是’(‘先放，并且它可以最多放三个，然后再放’)’，放右括号的前提是左边有多余的左括号。可以利用open，close参数来控制，open记录当前的’(‘的位置，close记录当前的’)’的位置，那么放有括号的条件就是open要大于close，这样代表左边有多余的（。"></a>解题思路：本题和全排列的思维像，但是他是有规定的，比如出现）那么前边一定有一个多余的左括号。刚开始使用全排列的思想，然后去重，规定右括号出现，左边一定有一个多余的左括号，但是失败告终- -，借鉴了一些，发现主要还是递归，其实回溯就是递归，个人理解只不过回溯多了一步修改的过程。那么这一题用递归的话，主要思想就是’(‘先放，并且它可以最多放三个，然后再放’)’，放右括号的前提是左边有多余的左括号。可以利用open，close参数来控制，open记录当前的’(‘的位置，close记录当前的’)’的位置，那么放有括号的条件就是open要大于close，这样代表左边有多余的（。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;result;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">string</span> cur_str=<span class="string">""</span>;</span><br><span class="line">        putParenthesis(cur_str,<span class="number">0</span>,<span class="number">0</span>,n);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">putParenthesis</span><span class="params">(<span class="built_in">string</span> cur_str,<span class="keyword">int</span> open,<span class="keyword">int</span> close,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur_str.size()==<span class="number">2</span>*n)&#123;</span><br><span class="line">            result.push_back(cur_str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(open&lt;n)putParenthesis(cur_str+<span class="string">'('</span>,open+<span class="number">1</span>,close,n);</span><br><span class="line">        <span class="keyword">if</span>(open&gt;close)putParenthesis(cur_str+<span class="string">')'</span>,open,close+<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;给出 &lt;em&gt;n&lt;/em&gt; 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且&lt;strong&gt;有效的&lt;/strong&gt;括号组合。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="回溯" scheme="https://cblog.club/categories/leetcode/%E5%9B%9E%E6%BA%AF/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="回溯" scheme="https://cblog.club/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>17电话号码的字母组合</title>
    <link href="https://cblog.club/ck3hez7860009dwg4d64p6xxc.html"/>
    <id>https://cblog.club/ck3hez7860009dwg4d64p6xxc.html</id>
    <published>2019-11-27T14:32:53.000Z</published>
    <updated>2019-11-27T14:38:18.052Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><a id="more"></a><img src="/ck3hez7860009dwg4d64p6xxc/1.jpg" class=""><blockquote><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="string">"23"</span></span><br><span class="line">输出：[<span class="string">"ad"</span>, <span class="string">"ae"</span>, <span class="string">"af"</span>, <span class="string">"bd"</span>, <span class="string">"be"</span>, <span class="string">"bf"</span>, <span class="string">"cd"</span>, <span class="string">"ce"</span>, <span class="string">"cf"</span>].</span><br></pre></td></tr></table></figure><p><strong>说明:</strong><br>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p></blockquote><h6 id="解题思路：本题倒不是很难，还是在于理解回溯，以及在递归传参的一些细节，我们可以依靠传参来判断我们是应该在第几个找，比如穿的是3，就应该string的序号为3的字符串里找相应的字符。还有要注意的就是string字符串有-连接字符串，但是他没有-这个操作，如果想要使用删除末尾元素的字符，可以使用cur-str-erase-cur-str-end-1-语句，其实做这种排列问题，首先要想到回溯法，就要想到回溯的框架（当然回溯的框架，不适应一些题目）。"><a href="#解题思路：本题倒不是很难，还是在于理解回溯，以及在递归传参的一些细节，我们可以依靠传参来判断我们是应该在第几个找，比如穿的是3，就应该string的序号为3的字符串里找相应的字符。还有要注意的就是string字符串有-连接字符串，但是他没有-这个操作，如果想要使用删除末尾元素的字符，可以使用cur-str-erase-cur-str-end-1-语句，其实做这种排列问题，首先要想到回溯法，就要想到回溯的框架（当然回溯的框架，不适应一些题目）。" class="headerlink" title="解题思路：本题倒不是很难，还是在于理解回溯，以及在递归传参的一些细节，我们可以依靠传参来判断我们是应该在第几个找，比如穿的是3，就应该string的序号为3的字符串里找相应的字符。还有要注意的就是string字符串有+=连接字符串，但是他没有-=这个操作，如果想要使用删除末尾元素的字符，可以使用cur_str.erase(cur_str.end() - 1);语句，其实做这种排列问题，首先要想到回溯法，就要想到回溯的框架（当然回溯的框架，不适应一些题目）。"></a>解题思路：本题倒不是很难，还是在于理解回溯，以及在递归传参的一些细节，我们可以依靠传参来判断我们是应该在第几个找，比如穿的是3，就应该string的序号为3的字符串里找相应的字符。还有要注意的就是string字符串有+=连接字符串，但是他没有-=这个操作，如果想要使用删除末尾元素的字符，可以使用<code>cur_str.erase(cur_str.end() - 1);</code>语句，其实做这种排列问题，首先要想到回溯法，就要想到回溯的框架（当然回溯的框架，不适应一些题目）。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;result;</span><br><span class="line">        <span class="keyword">if</span>(digits.size()==<span class="number">0</span>)<span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">string</span> cur_str=<span class="string">""</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;number&#123;<span class="string">""</span>,<span class="string">""</span>,<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,<span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span>&#125;;</span><br><span class="line">        getResult(digits,number,<span class="number">0</span>,result,cur_str);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getResult</span><span class="params">(<span class="built_in">string</span> digits,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp;number,<span class="keyword">int</span> count,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp;result,<span class="built_in">string</span> cur_str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur_num;</span><br><span class="line">        <span class="keyword">int</span> size=digits.size();</span><br><span class="line">        <span class="keyword">if</span>(count==size)&#123;</span><br><span class="line">            result.push_back(cur_str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur_num=digits[count]-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;number[cur_num].size();j++)&#123;</span><br><span class="line">            cur_str+=number[cur_num][j];</span><br><span class="line">            getResult(digits,number,count+<span class="number">1</span>,result,cur_str);</span><br><span class="line">            cur_str.erase(cur_str.end() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;给定一个仅包含数字 &lt;code&gt;2-9&lt;/code&gt; 的字符串，返回所有它能表示的字母组合。&lt;/p&gt;
&lt;p&gt;给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="回溯" scheme="https://cblog.club/categories/leetcode/%E5%9B%9E%E6%BA%AF/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="回溯" scheme="https://cblog.club/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>78子集</title>
    <link href="https://cblog.club/ck3hez7aa002qdwg44h0w11x1.html"/>
    <id>https://cblog.club/ck3hez7aa002qdwg44h0w11x1.html</id>
    <published>2019-11-27T14:27:59.000Z</published>
    <updated>2019-11-27T14:32:19.368Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定一组<strong>不含重复元素</strong>的整数数组 <em>nums</em>，返回该数组所有可能的子集（幂集）。</p><p><strong>说明：</strong>解集不能包含重复的子集。</p><a id="more"></a><blockquote><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：这一题也是折腾了不少时间，主要是回溯框架思维，以及之前做过的全排列，对我影响太深，有点固化了，所以思考问题还是不行，这一题主要不同在于他是长度是可变的，一开始想的有点麻烦想要传参进行长度的影响，但是稍微转变一点，利用这个长度，进行循环的条件判断，在插入结果数组的时候，我们不加判断，直接插入即可，因为没有长度限制，注意循环可以控制数字的方向从左到右。"><a href="#解题思路：这一题也是折腾了不少时间，主要是回溯框架思维，以及之前做过的全排列，对我影响太深，有点固化了，所以思考问题还是不行，这一题主要不同在于他是长度是可变的，一开始想的有点麻烦想要传参进行长度的影响，但是稍微转变一点，利用这个长度，进行循环的条件判断，在插入结果数组的时候，我们不加判断，直接插入即可，因为没有长度限制，注意循环可以控制数字的方向从左到右。" class="headerlink" title="解题思路：这一题也是折腾了不少时间，主要是回溯框架思维，以及之前做过的全排列，对我影响太深，有点固化了，所以思考问题还是不行，这一题主要不同在于他是长度是可变的，一开始想的有点麻烦想要传参进行长度的影响，但是稍微转变一点，利用这个长度，进行循环的条件判断，在插入结果数组的时候，我们不加判断，直接插入即可，因为没有长度限制，注意循环可以控制数字的方向从左到右。"></a>解题思路：这一题也是折腾了不少时间，主要是回溯框架思维，以及之前做过的全排列，对我影响太深，有点固化了，所以思考问题还是不行，这一题主要不同在于他是长度是可变的，一开始想的有点麻烦想要传参进行长度的影响，但是稍微转变一点，利用这个长度，进行循环的条件判断，在插入结果数组的时候，我们不加判断，直接插入即可，因为没有长度限制，注意循环可以控制数字的方向从左到右。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;select;</span><br><span class="line">        insertSubsets(nums,select,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertSubsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; select,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        result.push_back(select);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=length;i&lt;nums.size();i++)&#123;</span><br><span class="line">            select.push_back(nums[i]);</span><br><span class="line">            insertSubsets(nums,select,i+<span class="number">1</span>);</span><br><span class="line">            select.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;给定一组&lt;strong&gt;不含重复元素&lt;/strong&gt;的整数数组 &lt;em&gt;nums&lt;/em&gt;，返回该数组所有可能的子集（幂集）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;解集不能包含重复的子集。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="回溯" scheme="https://cblog.club/categories/leetcode/%E5%9B%9E%E6%BA%AF/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="回溯" scheme="https://cblog.club/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>51N皇后</title>
    <link href="https://cblog.club/ck3hez79q001zdwg44u44h8ia.html"/>
    <id>https://cblog.club/ck3hez79q001zdwg44u44h8ia.html</id>
    <published>2019-11-27T14:23:10.000Z</published>
    <updated>2019-11-27T14:26:54.634Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p> <em>n</em> 皇后问题研究的是如何将 <em>n</em> 个皇后放置在 <em>n</em>×<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击。 </p><a id="more"></a><blockquote><p>给定一个整数 <em>n</em>，返回所有不同的 <em>n</em> 皇后问题的解决方案。</p><p>每一种解法包含一个明确的 <em>n</em> 皇后问题的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">4</span></span><br><span class="line">输出: [</span><br><span class="line"> [<span class="string">".Q.."</span>,  <span class="comment">// 解法 1</span></span><br><span class="line">  <span class="string">"...Q"</span>,</span><br><span class="line">  <span class="string">"Q..."</span>,</span><br><span class="line">  <span class="string">"..Q."</span>],</span><br><span class="line"></span><br><span class="line"> [<span class="string">"..Q."</span>,  <span class="comment">// 解法 2</span></span><br><span class="line">  <span class="string">"Q..."</span>,</span><br><span class="line">  <span class="string">"...Q"</span>,</span><br><span class="line">  <span class="string">".Q.."</span>]</span><br><span class="line">]</span><br><span class="line">解释: <span class="number">4</span> 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：N皇后问题为经典的回溯算法，回溯算法中，也已经详细的介绍了解法，这里不再赘述，回溯算法的框架，自己一定要想清楚，但是题目还是很灵活的，并不是都是千篇一律，，直接用来套公式就能解决的，所以还是要理解，然后发现递归的模拟，真的是能玩一天-！"><a href="#解题思路：N皇后问题为经典的回溯算法，回溯算法中，也已经详细的介绍了解法，这里不再赘述，回溯算法的框架，自己一定要想清楚，但是题目还是很灵活的，并不是都是千篇一律，，直接用来套公式就能解决的，所以还是要理解，然后发现递归的模拟，真的是能玩一天-！" class="headerlink" title="解题思路：N皇后问题为经典的回溯算法，回溯算法中，也已经详细的介绍了解法，这里不再赘述，回溯算法的框架，自己一定要想清楚，但是题目还是很灵活的，并不是都是千篇一律，，直接用来套公式就能解决的，所以还是要理解，然后发现递归的模拟，真的是能玩一天= =！"></a>解题思路：N皇后问题为经典的回溯算法，回溯算法中，也已经详细的介绍了解法，这里不再赘述，回溯算法的框架，自己一定要想清楚，但是题目还是很灵活的，并不是都是千篇一律，，直接用来套公式就能解决的，所以还是要理解，然后发现递归的模拟，真的是能玩一天= =！</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; result;</span><br><span class="line">        <span class="comment">//初始化一个空的棋盘</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;board(n,<span class="built_in">string</span>(n,<span class="string">'.'</span>));</span><br><span class="line">        putNQueens(board,<span class="number">0</span>,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">putNQueens</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp;board,<span class="keyword">int</span> row,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp;result)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row==board.size())&#123;</span><br><span class="line">            result.push_back(board);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始放置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;board.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!isValid(board,row,i))<span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//做出选择</span></span><br><span class="line">            board[row][i]=<span class="string">'Q'</span>;</span><br><span class="line">            putNQueens(board,row+<span class="number">1</span>,result);</span><br><span class="line">            <span class="comment">//撤销选择</span></span><br><span class="line">            board[row][i]=<span class="string">'.'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp;board,<span class="keyword">int</span> row,<span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">        <span class="comment">//先检查该列上有没有皇后</span></span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][col]==<span class="string">'Q'</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查看左上方有没有皇后</span></span><br><span class="line">        <span class="keyword">for</span>(i=row<span class="number">-1</span>,j=col<span class="number">-1</span>;i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>;i--,j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==<span class="string">'Q'</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查看右上方有没有皇后</span></span><br><span class="line">        <span class="keyword">for</span>(i=row<span class="number">-1</span>,j=col+<span class="number">1</span>;i&gt;=<span class="number">0</span>&amp;&amp;j&lt;board.size();i--,j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==<span class="string">'Q'</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt; &lt;em&gt;n&lt;/em&gt; 皇后问题研究的是如何将 &lt;em&gt;n&lt;/em&gt; 个皇后放置在 &lt;em&gt;n&lt;/em&gt;×&lt;em&gt;n&lt;/em&gt; 的棋盘上，并且使皇后彼此之间不能相互攻击。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="回溯" scheme="https://cblog.club/categories/leetcode/%E5%9B%9E%E6%BA%AF/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="回溯" scheme="https://cblog.club/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>回溯算法</title>
    <link href="https://cblog.club/ck3hez7de004udwg40ktx792t.html"/>
    <id>https://cblog.club/ck3hez7de004udwg40ktx792t.html</id>
    <published>2019-11-25T13:31:14.000Z</published>
    <updated>2019-11-26T06:06:12.996Z</updated>
    
    <content type="html"><![CDATA[<p>这两天在研究回溯算法，所以特此记录一下，这一片文章是看的一个知乎上的人的总结，感觉非常不错，很容易理解。</p><h4 id="解决一个回溯问题，实际上就是一个决策树的遍历过程。"><a href="#解决一个回溯问题，实际上就是一个决策树的遍历过程。" class="headerlink" title="解决一个回溯问题，实际上就是一个决策树的遍历过程。"></a>解决一个回溯问题，实际上就是一个决策树的遍历过程。</h4><p>你只需要思考 3 个问题：</p><a id="more"></a><ul><li><p>路径：也就是已经做出的选择。</p></li><li><p>选择列表：也就是你当前可以做的选择。</p></li><li><p>结束条件：也就是到达决策树底层，无法再做选择的条件。</p></li></ul><p>如果你不理解这三个词语的解释，没关系，我们后面会用「全排列」和「N 皇后问题」这两个经典的回溯算法问题来帮你理解这些词语是什么意思，现在你先留着印象。</p><p>代码方面，回溯算法的框架：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">def backtrack(路径, 选择列表):</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> 选择 in 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure><p><strong>其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」</strong>，特别简单。</p><p>什么叫做选择和撤销选择呢，这个框架的底层原理是什么呢？下面我们就通过「全排列」这个问题来解开之前的疑惑，详细探究一下其中的奥妙！</p><h4 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h4><h4 id="我们在高中的时候就做过排列组合的数学题，我们也知道n个不重复的数，全排列共有-n-个。"><a href="#我们在高中的时候就做过排列组合的数学题，我们也知道n个不重复的数，全排列共有-n-个。" class="headerlink" title="我们在高中的时候就做过排列组合的数学题，我们也知道n个不重复的数，全排列共有 n! 个。"></a>我们在高中的时候就做过排列组合的数学题，我们也知道<code>n</code>个不重复的数，全排列共有 n! 个。</h4><p>PS：<strong>为了简单清晰起见，我们这次讨论的全排列问题不包含重复的数字</strong>。</p><p>那么我们当时是怎么穷举全排列的呢？比方说给三个数<code>[1,2,3]</code>，你肯定不会无规律地乱穷举，一般是这样：</p><p>先固定第一位为 1，然后第二位可以是 2，那么第三位只能是 3；然后可以把第二位变成 3，第三位就只能是 2 了；然后就只能变化第一位，变成 2，然后再穷举后两位……</p><p>其实这就是回溯算法，我们高中无师自通就会用，或者有的同学直接画出如下这棵回溯树：</p><img src="/ck3hez7de004udwg40ktx792t/image-20191125213617585.png" class=""><p>只要从根遍历这棵树，记录路径上的数字，其实就是所有的全排列。<strong>我们不妨把这棵树称为回溯算法的「决策树」</strong>。</p><p><strong>为啥说这是决策树呢，因为你在每个节点上其实都在做决策</strong>。比如说你站在下图的红色节点上：</p><img src="/ck3hez7de004udwg40ktx792t/image-20191125213806909.png" class=""><p>你现在就在做决策，可以选择 1 那条树枝，也可以选择 3 那条树枝。为啥只能在 1 和 3 之中选择呢？因为 2 这个树枝在你身后，这个选择你之前做过了，而全排列是不允许重复使用数字的。 </p><p><strong>现在可以解答开头的几个名词：<code>[2]</code>就是「路径」，记录你已经做过的选择；<code>[1,3]</code>就是「选择列表」，表示你当前可以做出的选择；「结束条件」就是遍历到树的底层，在这里就是选择列表为空的时候</strong>。</p><p>如果明白了这几个名词，<strong>可以把「路径」和「选择列表」作为决策树上每个节点的属性</strong>，比如下图列出了几个节点的属性：</p><img src="/ck3hez7de004udwg40ktx792t/image-20191125213946062.png" class=""><p><strong>我们定义的<code>backtrack</code>函数其实就像一个指针，在这棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层，其「路径」就是一个全排列</strong>。</p><p>再进一步，如何遍历一棵树？这个应该不难吧。回忆一下之前 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484520&idx=1&sn=2c6507c7f25c0fd29fd1d146ee3b067c&chksm=9bd7fa60aca073763785418d15ed03c9debdd93ca36f4828fa809990116b1e7536c3f68a7b71&scene=21#wechat_redirect" target="_blank" rel="noopener">学习数据结构的框架思维</a> 写过，各种搜索问题其实都是树的遍历问题，而多叉树的遍历框架就是这样：</p><p> 而所谓的前序遍历和后序遍历，他们只是两个很有用的时间点，我给你画张图你就明白了： </p><img src="/ck3hez7de004udwg40ktx792t/image-20191125214040894.png" class=""><p><strong>前序遍历的代码在进入某一个节点之前的那个时间点执行，后序遍历代码在离开某个节点之后的那个时间点执行</strong>。</p><p>回想我们刚才说的，「路径」和「选择」是每个节点的属性，函数在树上游走要正确维护节点的属性，那么就要在这两个特殊时间点搞点动作：</p><img src="/ck3hez7de004udwg40ktx792t/image-20191125214111739.png" class=""><p> 现在，你是否理解了回溯算法的这段核心框架？ </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 选择 in 选择列表:</span><br><span class="line">    # 做选择</span><br><span class="line">    将该选择从选择列表移除</span><br><span class="line">    路径.add(选择)</span><br><span class="line">    backtrack(路径, 选择列表)</span><br><span class="line">    # 撤销选择</span><br><span class="line">    路径.remove(选择)</span><br><span class="line">    将该选择再加入选择列表</span><br></pre></td></tr></table></figure><p><strong>我们只要在递归之前做出选择，在递归之后撤销刚才的选择</strong>，就能正确得到每个节点的选择列表和路径。</p><p>下面，直接看全排列代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 主函数，输入一组不重复的数字，返回它们的全排列 */</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="comment">// 记录「路径」</span></span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backtrack(nums, track);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径：记录在 track 中</span></span><br><span class="line"><span class="comment">// 选择列表：nums 中不存在于 track 的那些元素</span></span><br><span class="line"><span class="comment">// 结束条件：nums 中的元素全都在 track 中出现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (track.size() == nums.length) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 排除不合法的选择</span></span><br><span class="line">        <span class="keyword">if</span> (track.contains(nums[i]))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.add(nums[i]);</span><br><span class="line">        <span class="comment">// 进入下一层决策树</span></span><br><span class="line">        backtrack(nums, track);</span><br><span class="line">        <span class="comment">// 取消选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 我们这里稍微做了些变通，没有显式记录「选择列表」，而是通过<code>nums</code>和<code>track</code>推导出当前的选择列表： </p><img src="/ck3hez7de004udwg40ktx792t/image-20191125214229597.png" class=""><p>至此，我们就通过全排列问题详解了回溯算法的底层原理。当然，这个算法解决全排列不是很高效，因为对链表使用<code>contains</code>方法需要 O(N) 的时间复杂度。有更好的方法通过交换元素达到目的，但是难理解一些，这里就不写了，有兴趣可以自行搜索一下。</p><p>但是必须说明的是，不管怎么优化，都符合回溯框架，而且时间复杂度都不可能低于 O(N!)，因为穷举整棵决策树是无法避免的。<strong>这也是回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高</strong>。</p><p>明白了全排列问题，就可以直接套回溯算法框架了，下面简单看看 N 皇后问题。</p><h4 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h4><p>这个问题很经典了，简单解释一下：给你一个 N×N 的棋盘，让你放置 N 个皇后，使得它们不能互相攻击。</p><p>PS：皇后可以攻击同一行、同一列、左上左下右上右下四个方向的任意单位。</p><p>这是 N = 8 的一种放置方法：</p><img src="/ck3hez7de004udwg40ktx792t/image-20191125214412332.png" class=""><p> 这个问题本质上跟全排列问题差不多，决策树的每一层表示棋盘上的每一行；每个节点可以做出的选择是，在该行的任意一列放置一个皇后。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输入棋盘边长 n，返回所有合法的放置 */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="comment">// '.' 表示空，'Q' 表示皇后，初始化空棋盘。</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; board(n, <span class="built_in">string</span>(n, <span class="string">'.'</span>));</span><br><span class="line">    backtrack(board, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径：board 中小于 row 的那些行都已经成功放置了皇后</span></span><br><span class="line"><span class="comment">// 选择列表：第 row 行的所有列都是放置皇后的选择</span></span><br><span class="line"><span class="comment">// 结束条件：row 超过 board 的最后一行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; board, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (row == board.size()) &#123;</span><br><span class="line">        res.push_back(board);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = board[row].size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        <span class="comment">// 排除不合法选择</span></span><br><span class="line">        <span class="keyword">if</span> (!isValid(board, row, col)) </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        board[row][col] = <span class="string">'Q'</span>;</span><br><span class="line">        <span class="comment">// 进入下一行决策</span></span><br><span class="line">        backtrack(board, row + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        board[row][col] = <span class="string">'.'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这部分主要代码，跟全排列问题差不多。<code>isValid</code>函数的实现也很简单： </p><ul><li>这里要注意的是，我们是从上往下放的皇后，所以不需要再去检查左下，右下是否有皇后了，在这一列上也只需要到第row行之前就可以了。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 是否可以在 board[row][col] 放置皇后？ */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = board.size();</span><br><span class="line">    <span class="comment">// 检查列是否有皇后互相冲突</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][col] == <span class="string">'Q'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查右上方是否有皇后互相冲突</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; </span><br><span class="line">            i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">'Q'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查左上方是否有皇后互相冲突</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>;</span><br><span class="line">            i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">'Q'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数<code>backtrack</code>依然像个在决策树上游走的指针，每个节点就表示在<code>board[row][col]</code>上放置皇后，通过<code>isValid</code>函数可以将不符合条件的情况剪枝</strong>： </p><p>如果直接给你这么一大段解法代码，可能是懵逼的。但是现在明白了回溯算法的框架套路，还有啥难理解的呢？无非是改改做选择的方式，排除不合法选择的方式而已，只要框架存于心，你面对的只剩下小问题了。</p><p>当<code>N = 8</code>时，就是八皇后问题，数学大佬高斯穷尽一生都没有数清楚八皇后问题到底有几种可能的放置方法，但是我们的算法只需要一秒就可以算出来所有可能的结果。</p><p>不过真的不怪高斯。这个问题的复杂度确实非常高，看看我们的决策树，虽然有<code>isValid</code>函数剪枝，但是最坏时间复杂度仍然是 O(N^(N+1))（这个时间复杂度需要考虑），而且无法优化。如果<code>N = 10</code>的时候，计算就已经很耗时了。</p><p><strong>有的时候，我们并不想得到所有合法的答案，只想要一个答案，怎么办呢</strong>？比如解数独的算法，找所有解法复杂度太高，只要找到一种解法就可以。</p><p>其实特别简单，只要稍微修改一下回溯算法的代码即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数找到一个答案后就返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; board, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (row == board.size()) &#123;</span><br><span class="line">        res.push_back(board);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        ...</span><br><span class="line">        board[row][col] = <span class="string">'Q'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (backtrack(board, row + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        board[row][col] = <span class="string">'.'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样修改后，只要找到一个答案，for 循环的后续递归穷举都会被阻断。也许你可以在 N 皇后问题的代码框架上，稍加修改，写一个解数独的算法？</p><h4 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h4><p> 回溯算法就是个多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置做一些操作，算法框架如下： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def backtrack(...):</span><br><span class="line">    <span class="keyword">for</span> 选择 in 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(...)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure><p><strong>写<code>backtrack</code>函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集</strong>。 </p><p>其实想想看，回溯算法和动态规划是不是有点像呢？我们在动态规划系列文章中多次强调，动态规划的三个需要明确的点就是「状态」「选择」和「base case」，是不是就对应着走过的「路径」，当前的「选择列表」和「结束条件」？</p><p>某种程度上说，动态规划的暴力求解阶段就是回溯算法。只是有的问题具有重叠子问题性质，可以用 dp table 或者备忘录优化，将递归树大幅剪枝，这就变成了动态规划。而今天的两个问题，都没有重叠子问题，也就是回溯算法问题了，复杂度非常高是不可避免的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这两天在研究回溯算法，所以特此记录一下，这一片文章是看的一个知乎上的人的总结，感觉非常不错，很容易理解。&lt;/p&gt;
&lt;h4 id=&quot;解决一个回溯问题，实际上就是一个决策树的遍历过程。&quot;&gt;&lt;a href=&quot;#解决一个回溯问题，实际上就是一个决策树的遍历过程。&quot; class=&quot;headerlink&quot; title=&quot;解决一个回溯问题，实际上就是一个决策树的遍历过程。&quot;&gt;&lt;/a&gt;解决一个回溯问题，实际上就是一个决策树的遍历过程。&lt;/h4&gt;&lt;p&gt;你只需要思考 3 个问题：&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://cblog.club/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://cblog.club/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>47全排列II</title>
    <link href="https://cblog.club/ck3hez79j001sdwg44gnj8js6.html"/>
    <id>https://cblog.club/ck3hez79j001sdwg44gnj8js6.html</id>
    <published>2019-11-25T13:19:15.000Z</published>
    <updated>2019-11-25T13:29:28.171Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p> 给定一个可包含重复数字的序列，返回所有不重复的全排列。 </p><a id="more"></a><blockquote><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：本题是全排列的升级版，主要区别是给定数组有重复数字出现，但是返回的数组不能有重复数字。大体的思路就是先将数组进行排序，因为我们很容易想到，排序后，重复的元素是相邻的，然后我们在根据要求，在重复的位置上进行剪枝即可。具体思路可以参考一个大佬的写的解题过程-https-leetcode-cn-com-problems-permutations-ii-solution-hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2-，今天思考递归，想了好久，手动模拟，感觉比以前要深刻一点。"><a href="#解题思路：本题是全排列的升级版，主要区别是给定数组有重复数字出现，但是返回的数组不能有重复数字。大体的思路就是先将数组进行排序，因为我们很容易想到，排序后，重复的元素是相邻的，然后我们在根据要求，在重复的位置上进行剪枝即可。具体思路可以参考一个大佬的写的解题过程-https-leetcode-cn-com-problems-permutations-ii-solution-hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2-，今天思考递归，想了好久，手动模拟，感觉比以前要深刻一点。" class="headerlink" title="解题思路：本题是全排列的升级版，主要区别是给定数组有重复数字出现，但是返回的数组不能有重复数字。大体的思路就是先将数组进行排序，因为我们很容易想到，排序后，重复的元素是相邻的，然后我们在根据要求，在重复的位置上进行剪枝即可。具体思路可以参考一个大佬的写的解题过程  https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/ ，今天思考递归，想了好久，手动模拟，感觉比以前要深刻一点。"></a>解题思路：本题是全排列的升级版，主要区别是给定数组有重复数字出现，但是返回的数组不能有重复数字。大体的思路就是先将数组进行排序，因为我们很容易想到，排序后，重复的元素是相邻的，然后我们在根据要求，在重复的位置上进行剪枝即可。具体思路可以参考一个大佬的写的解题过程  <a href="https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/</a> ，今天思考递归，想了好久，手动模拟，感觉比以前要深刻一点。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;result;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;init_path;</span><br><span class="line">        <span class="keyword">int</span> size=nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;visited(size,<span class="literal">false</span>);</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        Backtracking(init_path,nums,result,visited);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Backtracking</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;path,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;select,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp;result,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp;visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size()==select.size())&#123;</span><br><span class="line">            result.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;select.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;select[i<span class="number">-1</span>]==select[i]&amp;&amp;visited[i<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">                path.push_back(select[i]);</span><br><span class="line">                visited[i]=<span class="literal">true</span>;</span><br><span class="line">                Backtracking(path,select,result,visited);</span><br><span class="line">                path.pop_back();</span><br><span class="line">                visited[i]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt; 给定一个可包含重复数字的序列，返回所有不重复的全排列。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="回溯" scheme="https://cblog.club/categories/leetcode/%E5%9B%9E%E6%BA%AF/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="回溯" scheme="https://cblog.club/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>attetion机制简单了解</title>
    <link href="https://cblog.club/ck3hez7bl004edwg45pfmhiap.html"/>
    <id>https://cblog.club/ck3hez7bl004edwg45pfmhiap.html</id>
    <published>2019-11-25T11:53:16.000Z</published>
    <updated>2019-11-25T12:04:56.199Z</updated>
    
    <content type="html"><![CDATA[<p>读了一篇关于水表数字识别的论文，里面有个名词attention mechanism(注意力机制)，没有接触过，所以找了一些资料来看，特此记录一下，主要是记录下它的作用，具体的算法及其推导就不看了，不是NLP方向，就做个简单的了解 = =！（其实是太难了…）</p><a id="more"></a><h4 id="What-is-attention-mechanism"><a href="#What-is-attention-mechanism" class="headerlink" title="What is attention mechanism"></a>What is attention mechanism</h4><p>先简单描述一下attention机制是什么。相信做NLP的同学对这个机制不会很陌生，它在<strong>Attention is all you need</strong>可以说是大放异彩，在machine translation任务中，帮助深度模型在性能上有了很大的提升，输出了当时最好的state-of-art model。当然该模型除了attention机制外，还用了很多有用的trick，以帮助提升模型性能。但是不能否认的时，这个模型的核心就是attention。</p><p>attention机制：又称为注意力机制，顾名思义，是<strong>一种能让模型对重要信息重点关注并充分学习吸收的技术</strong>，它不算是一个完整的模型，应当是一种技术，能够作用于任何序列模型中。</p><p>注意力机制是一种基于RNN（LSTM或GRU）的编码器+解码器模型（我们之前在seq2seq模型中简单介绍过）的效果的机制（机制），一般称为注意机制。注意机制目前非常流行，广泛应用于机器翻译，语音识别，图像标注（Image Caption）等很多领域，之所以它这么受欢迎，是因为Attention给模型赋予了区分辨别的能力，例如，在机器翻译，语音识别应用中，为句子中的每个词赋予不同的权重，使神经网络模型的学习变得更加灵活（软），同时注意力本身可以做为一种对齐关系，解释输入/输出句子之间的对齐关系，解释模型到底学到了什么知识，为我们打开深度学习的黑箱，提供了一个窗口。</p><h4 id="Why-attention？"><a href="#Why-attention？" class="headerlink" title="Why attention？"></a>Why attention？</h4><p>讲一下为什么要引入attention机制。在之前总结过的seq2seq模型以及之前做NLP的比赛中，对于一段文本序列，我们通常要使用某种机制对该序列进行编码，通过降维等方式将其encode成一个固定长度的向量，用于输入到后面的全连接层。 </p><img src="/ck3hez7bl004edwg45pfmhiap/image-20191125200235039.png" class=""><p>一般我们会使用CNN或者RNN（包括GRU或者LSTM）等模型来对序列数据进行编码，然后采用各种pooling或者对RNN直接取最后一个t时刻的hidden state作为句子的向量输出。这里会有一个问题：</p><p>常规的编码方法，无法体现对一个句子序列中不同语素的关注程度，在自然语言中，一个句子中的不同部分是有不同含义和重要性的，比如上面的例子中：I hate this movie.如果做情感分析，明显对hate这个词语应当关注更多。当然是用CNN和RNN能够编码这种信息。但是如果序列长度很长的情况下，这种方法会有一定的瓶颈。拿CNN举例，具体如下图：图来自  <a href="https://link.zhihu.com/?target=https%3A//cloud.tencent.com/developer/article/1153079">“变形金刚”为何强大：从模型到代码全面解析Google Tensor2Tensor系统</a></p><img src="/ck3hez7bl004edwg45pfmhiap/image-20191125200402273.png" class=""><p>CNN的核心就是卷积核能够变相学习n-gram的信息，如果是用hierarchical的卷积核，那么越上层的卷积核越能编码原始距离较远的词组的信息。但是这种编码能力也是有上限的，对于较长的文本，模型效果不会再提升太多。RNN也是同理。</p><p>基于参加达观文本分类的经历，对于这种长文本处理，使用RNN+attention的效果比使用单纯的RNN+pooling的效果要好不少。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;读了一篇关于水表数字识别的论文，里面有个名词attention mechanism(注意力机制)，没有接触过，所以找了一些资料来看，特此记录一下，主要是记录下它的作用，具体的算法及其推导就不看了，不是NLP方向，就做个简单的了解 = =！（其实是太难了…）&lt;/p&gt;
    
    </summary>
    
    
      <category term="深度学习" scheme="https://cblog.club/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="https://cblog.club/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>seq2seq模型简单了解</title>
    <link href="https://cblog.club/ck3hez7bo004jdwg4fjage8ey.html"/>
    <id>https://cblog.club/ck3hez7bo004jdwg4fjage8ey.html</id>
    <published>2019-11-25T11:41:24.000Z</published>
    <updated>2019-11-25T11:49:39.035Z</updated>
    
    <content type="html"><![CDATA[<p>读了一篇关于水表数字识别的论文，里面有个名词seq2seq，没有接触过，所以找了一些资料来看，特此记录一下，主要是记录下它的作用，具体的算法及其推导还没看，因为不是NLP方向，就想简单了解一下。</p><a id="more"></a><h4 id="Seq2Seq模型简介"><a href="#Seq2Seq模型简介" class="headerlink" title="Seq2Seq模型简介"></a>Seq2Seq模型简介</h4><p>Seq2Seq模型是输出的长度不确定时采用的模型，这种情况一般是在机器翻译的任务中出现，将一句中文翻译成英文，那么这句英文的长度有可能会比中文短，也有可能会比中文长，所以输出的长度就不确定了。如下图所，输入的中文长度为4，输出的英文长度为2。</p><img src="/ck3hez7bo004jdwg4fjage8ey/image-20191125194417521.png" class=""><p>在网络结构中，输入一个中文序列，然后输出它对应的中文翻译，输出的部分的结果预测后面，根据上面的例子，也就是先输出“machine”，将”machine”作为下一次的输入，接着输出”learning”,这样就能输出任意长的序列。<br>机器翻译、人机对话、聊天机器人等等，这些都是应用在当今社会都或多或少的运用到了我们这里所说的Seq2Seq。</p><h4 id="Seq2Seq结构"><a href="#Seq2Seq结构" class="headerlink" title="Seq2Seq结构"></a>Seq2Seq结构</h4><p>seq2seq属于encoder-decoder结构的一种，这里看看常见的encoder-decoder结构，基本思想就是利用两个RNN，一个RNN作为encoder，另一个RNN作为decoder。<strong>encoder负责将输入序列压缩成指定长度的向量</strong>，这个向量就可以看成是这个序列的语义，这个过程称为编码，如下图，<strong>获取语义向量最简单的方式就是直接将最后一个输入的隐状态作为语义向量C</strong>。也可以对最后一个隐含状态做一个变换得到语义向量，还可以将输入序列的所有隐含状态做一个变换得到语义变量。</p><img src="/ck3hez7bo004jdwg4fjage8ey/image-20191125194651707.png" class=""><p>而<strong>decoder则负责根据语义向量生成指定的序列</strong>，这个过程也称为解码，如下图，最简单的方式是将encoder得到的语义变量作为初始状态输入到decoder的RNN中，得到输出序列。可以看到上一时刻的输出会作为当前时刻的输入，而且其中语义向量C只作为初始状态参与运算，后面的运算都与语义向量C无关。</p><img src="/ck3hez7bo004jdwg4fjage8ey/image-20191125194809371.png" class=""><p>decoder处理方式还有另外一种，就是语义向量C参与了序列所有时刻的运算，如下图，上一时刻的输出仍然作为当前时刻的输入，但语义向量C会参与所有时刻的运算。 </p><img src="/ck3hez7bo004jdwg4fjage8ey/image-20191125194907893.png" class="">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;读了一篇关于水表数字识别的论文，里面有个名词seq2seq，没有接触过，所以找了一些资料来看，特此记录一下，主要是记录下它的作用，具体的算法及其推导还没看，因为不是NLP方向，就想简单了解一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="深度学习" scheme="https://cblog.club/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="https://cblog.club/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>CTC简单了解</title>
    <link href="https://cblog.club/ck3hez7af002wdwg4eqixg9xa.html"/>
    <id>https://cblog.club/ck3hez7af002wdwg4eqixg9xa.html</id>
    <published>2019-11-25T11:34:20.000Z</published>
    <updated>2019-11-25T12:05:23.681Z</updated>
    
    <content type="html"><![CDATA[<p>CTC（ Connectionist Temporal Classification ）算法</p><p>读了一篇关于水表数字识别的论文，里面有个名词CTC，没有接触过，所以找了一些资料来看，特此记录一下，主要是记录下它的作用，具体的算法及其推导，暂时还没看 = =！（太难了）</p><a id="more"></a><p>现实应用中许多问题可以抽象为序列学习（sequence learning）问题，比如词性标注（POS Tagging）、语音识别（Speech Recognition）、手写字识别（Handwriting Recognition）、机器翻译（Machine Translation）等应用，其核心问题都是训练模型把一个领域的（输入）序列转成另一个领域的（输出）序列。近年来基于RNN的序列到序列模型（sequence-to-sequence models）在序列学习任务中取得了显著的效果提升，本文介绍一种RNN（Recurrent Neural Networks）的端到端训练方法——CTC（Connectionist Temporal Classification）算法，它可以让RNN直接对序列数据进行学习，而无需事先标注好训练数据中输入序列和输出序列的映射关系，打破了RNN应用于语音识别、手写字识别等领域的数据依赖约束，使得RNN模型在序列学习任务中取得更好的应用效果。 </p><p>在序列学习任务中，RNN模型对训练样本一般有这样的依赖条件：输入序列和输出序列之间的映射关系已经事先标注好了。比如，在词性标注任务中，训练样本中每个词（或短语）对应的词性会事先标注好，如下图（DT、NN等都是词性的标注，具体含义请参考 <a href="https://www.ling.upenn.edu/courses/Fall_2003/ling001/penn_treebank_pos.html" target="_blank" rel="noopener">链接</a> ）。由于输入序列和输出序列是一一对应的，所以RNN模型的训练和预测都是端到端的，即可以根据输出序列和标注样本间的差异来直接定义RNN模型的Loss函数，传统的RNN训练和预测方式可直接适用。 </p><img src="/ck3hez7af002wdwg4eqixg9xa/image-20191125192036324.png" class=""><p>然而，在语音识别、手写字识别等任务中，由于音频数据和图像数据都是从现实世界中将模拟信号转为数字信号采集得到，这些数据天然就很难进行“分割”，这使得我们很难获取到包含输入序列和输出序列映射关系的大规模训练样本（人工标注成本巨高，且启发式挖掘方法存在很大局限性）。因此，在这种条件下，RNN无法直接进行端到端的训练和预测。</p><p>如下图，输入是“apple”对应的一段说话音频和手写字图片，从连续的音频信号和图像信号中逐一分割并标注出对应的输出序列非常费时费力，在大规模训练下这种数据要求是完全不切实际的。而如果输入序列和输出序列之间映射关系没有提前标注好，那传统的RNN训练方式就不能直接适用了，无法直接对音频数据和图像数据进行训练。</p><img src="/ck3hez7af002wdwg4eqixg9xa/image-20191125192114162.png" class=""><p>因此，在语音识别、图像识别等领域中，由于数据天然无法切割，且难以标注出输入和输出的序列映射关系，导致传统的RNN训练方法不能直接适用。那么，如何让RNN模型实现端到端的训练成为了关键问题。 </p><p>Connectionist Temporal Classification（CTC）[1]是Alex Graves等人在ICML 2006上提出的一种端到端的RNN训练方法，它可以让RNN直接对序列数据进行学习，而无需事先标注好训练数据中输入序列和输入序列的映射关系，使得RNN模型在语音识别等序列学习任务中取得更好的效果，在语音识别和图像识别等领域CTC算法都有很比较广泛的应用。总的来说，CTC的核心思路主要分为以下几部分： </p><ul><li><p>它扩展了RNN的输出层，在输出序列和最终标签之间增加了多对一的空间映射，并在此基础上定义了CTC Loss函数 </p></li><li><p>它借鉴了HMM（Hidden Markov Model）的Forward-Backward算法思路，利用动态规划算法有效地计算CTC Loss函数及其导数，从而解决了RNN端到端训练的问题 </p></li><li><p>最后，结合CTC Decoding算法RNN可以有效地对序列数据进行端到端的预测 </p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CTC（ Connectionist Temporal Classification ）算法&lt;/p&gt;
&lt;p&gt;读了一篇关于水表数字识别的论文，里面有个名词CTC，没有接触过，所以找了一些资料来看，特此记录一下，主要是记录下它的作用，具体的算法及其推导，暂时还没看 = =！（太难了）&lt;/p&gt;
    
    </summary>
    
    
      <category term="深度学习" scheme="https://cblog.club/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="https://cblog.club/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>全卷积序列识别网络用于水表数字识别</title>
    <link href="https://cblog.club/ck3hez7c9004mdwg4hjdl2g6t.html"/>
    <id>https://cblog.club/ck3hez7c9004mdwg4hjdl2g6t.html</id>
    <published>2019-11-25T08:04:54.000Z</published>
    <updated>2019-11-25T08:27:46.049Z</updated>
    
    <content type="html"><![CDATA[<p>最近，读了一篇FCN的论文，然后记录一下，准备回看~</p><h2 id="Fully-Convolutional-Sequence-Recognition-Network-for-Water-Meter-Number-Reading"><a href="#Fully-Convolutional-Sequence-Recognition-Network-for-Water-Meter-Number-Reading" class="headerlink" title="Fully Convolutional Sequence Recognition Network for Water Meter Number Reading"></a>Fully Convolutional Sequence Recognition Network for Water Meter Number Reading</h2><p>全卷积序列识别网络用于水表数字识别（团队来自华南理工大学电子与信息工程学院）</p><a id="more"></a><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>卷积循环神经网络（CRNN）是图像序列识别中应用最为广泛的框架之一，它使用卷积神经网络（CNN）进行特征提取，使用递归神经网络（RNN）进行序列建模。然而，RNN在训练和推理方面都存在计算量大的问题，限制了它在有时间约束的系统中的应用。一些模型用序列建模的注意机制代替RNN，但是仍然需要昂贵的迭代计算。本文认为，具有足够深度的CNN可以捕获上下文信息，消除重复操作和并行化的需要。我们关注水表读数（WNR）的问题，这是一个典型的序列识别任务，但很少被研究。我们提出了一个完整的进化序列识别网络（FCSRN），用于快速准确地读取水表编号。此外，我们还设计了一个增加损失（AugLoss）函数来有效地管理数字的中间状态，提高了性能。实验结果表明，该函数具有捕获上下文信息和消除循环层需求的能力，同时需要的参数更少，计算量更少。带AugLoss的FCSRN优于基于RNN和基于注意的模型。此外，AugLoss可以有效地提高基于RNN和基于注意的模型的性能。此外，我们构建并发布了一个包含6000张带有标签的水表图像的数据集，可在<a href="https://github.com/HCIILAB/water-meter-Number-dataset" target="_blank" rel="noopener">https://github.com/HCIILAB/water-meter-Number-dataset</a> 上找到。</p><h3 id="I-引言"><a href="#I-引言" class="headerlink" title="I.引言"></a>I.引言</h3><p>自动化的水表数字识别在许多实际应用中都有很大的需求，如用水收费系统和实时监测用水量。在文献中提出的水表读数方法中，最常见的是使用嵌入式电子装置（例如光电装置或超声波装置）来计算或测量水流量。近年来，一种新的方法开始引起研究人员的注意，它利用摄像机捕捉水表图像，然后识别图像中的数字。该方法具有灵活性高、易于实现、能充分利用现有测量设备的优点。例如，机械式水表是输水系统中最受欢迎、最稳定的测量设备，在可预见的将来很难被电子式水表取代。最重要的一点是，水表图像的捕获可以用来防止关于用水的欺骗，因为目前，在电子设备上比在图像上更容易欺骗。水表图像中的水表号码读取流程包括：首先检测和裁剪图像中的号码区域，然后识别裁剪图像中的水表号码。本文的第二部分（也就是我们所关注的）是水表读数问题，它是一个典型的基于图像的序列识别任务。</p><p>基于图像的序列识别任务有几种通用的解决方案。</p><ul><li>第一类是基于分割的方法，它包括两个步骤：数字分割和识别。例如，Bissacco等人使用边界框检测到数字，使用预先训练的卷积神经网络（CNN）模型识别检测到的数字，最后结合上下文信息得到识别结果。这种方法要求每个数字都易于定位和标记，因此不适合识别数字难以分割的图像。</li><li>第二类解决方案称为无分割方法，包括整体方法、基于循环神经网络（RNN）的方法和基于注意力（attention）的方法。<ul><li>整体方法将图像中的一串数字识别为一个整体，而不识别每个单独的数字。例如，Jaderberg等人训练CNN对不同的英语单词进行直接分类。这些方法严重依赖于预定义的词汇表，并且缺乏识别词汇表外单词的能力。此外，对于带有“0 0 0 0 0”等标签的水表图像（水表图像只有五个数字，但每个数字的范围为“0”到“19”），可能的组合的总数可以高达20^5=3.2×10^6，这就排除了使用整体方法的可能性。</li><li>基于RNN的方法通过在特征序列（通常来自CNN）上迭代，并在每个时间步执行识别来避免分割问题。大多数无分割序列识别系统使用具有长短期记忆单元（LSTM）的RNN，其成功地证明了无需精确分割即可使输入和输出序列一致的能力（也就是正确的识别）。虽然基于RNN的系统的结果是令人印象深刻的，但存在两个重要缺点：（1）由于循环层中的在时间步长上的迭代矩阵乘法，这导致训练速度可能很慢；（2）优化过程可能遭受梯度消失/爆炸问题。<ul><li>简单介绍一下什么是梯度消失（比如说0.9^30）和梯度爆炸（比如说1.1^30）： 两种情况下梯度消失经常出现，一是在<strong>深层网络</strong>中，二是采用了<strong>不合适的损失函数</strong>，比如sigmoid。梯度爆炸一般出现在深层网络和<strong>权值初始化值太大</strong>的情况下。</li></ul></li><li>最近，注意机制已经成为各种任务中引人注目的序列建模和转换模型的重要组成部分，从而允许在不考虑输入或输出序列中的距离的情况下建立依赖关系的模型。在大多数情况下，注意机制与RNN结合使用。然而，一般来说，注意机制可用于任何基于神经网络的模型。Gehring等人提出了卷积seq2seq学习模型。（ 顾名思义，seq2seq 模型就像一个翻译模型，输入是一个序列（比如一个英文句子），输出也是一个序列（比如该英文句子所对应的法文翻译。这种结构最重要的地方在于输入序列和输出序列的长度是可变的，它们不一定等长的。 ）输入的表示是由CNN以并行方式为注意机制计算的；解码器状态也由CNN确定，这个CNN具有已经产生的特征。虽然基于注意的卷积系统的结果是令人印象深刻的，但存在一个缺点：注意力权重的计算只能在训练期间完全并行化，而在推理时，当前时间步的注意权重的计算必须依赖于上一个时间步的输出，这是不容易并行化的。</li></ul></li></ul><p>水表数字识别WNR与文本识别任务相似，但其解码过程略有不同，因为在WNR中存在一些“中间状态”字符。为了建立一个快速、准确的WNR系统，我们提出了一个全卷积序列识别网络（FCSRN），它将全卷积网络（FCN）和CTC结合起来，不需要任何中间循环连接。此外，通过分析解码后的后处理方法，我们提出了一个增加损失（AugLoss）函数来有效地提高网络性能。</p><p>实验结果表明，FCSRN具有捕获上下文信息、消除循环层的能力，同时所需参数少、计算量小。带AugLoss的FCSRN优于基于RNN和基于注意的模型。此外，AugLoss可以有效地提高基于RNN和基于注意的模型的性能。</p><p>本文的其余部分组织如下：在第二节中，我们描述了构建的水表图像数据集。然后，我们在第三节介绍了所提出的FCSRN，在第四节介绍了AugLoss，在第五节介绍了实验结果，并对本文进行了总结。</p><h3 id="II-水表图像数据集"><a href="#II-水表图像数据集" class="headerlink" title="II.水表图像数据集"></a>II.水表图像数据集</h3><img src="/ck3hez7c9004mdwg4hjdl2g6t/image-20191124170829347.png" class=""><pre><code>图1</code></pre><p>为了研究WNR，我们构建了一个名为SCUT-WMN的非商业用途数据集，可在<a href="https://github.com/HCIILAB/Water-Meter-Number-dataset" target="_blank" rel="noopener">https://github.com/HCIILAB/Water-Meter-Number-dataset</a> 上获得。据我们所知，这是第一个公共水表图像数据集。水表图像由摄像机拍摄，并使用边界框和水表数字进行标记。我们裁剪了边界框区域以构建用于识别的数据集。数据集由两部分组成。第一部分包含5000个困难样品（如图1a所示）。在这些困难的样本中，由于光照、折射和遮挡等原因，会产生很大的变化。第二部分包含1000个简单样本（如图1b所示）。困难样本和简单样本都用连续字符标记，如“1  2 2 5 8”。此外，数据集中每个字符的数量如下图表所示。</p><img src="/ck3hez7c9004mdwg4hjdl2g6t/image-20191124171646580.png" class="">    <p>​                                                                                                            图2</p><p>在WNR中，存在一些“中间状态”字符，如图2所示。考虑到第4个图片，图2b（第二行第一列）中的图片作为示例，数字超过“20369”，但未达到“20370”，因此数字中的最后两个字符显示在“中间状态”。此外，正确的水表编号应为“20369.5”。为了管理“中间状态”字符，我们将它们视为单独的类，标签范围从“10”到“19”，如图2所示。标签L∈[10,19]表示超过“L-10”（称为“低状态”）但未达到“L-9”（称为“高状态”）的字符。举个例子吧，比较直观，你看16（还是上文中的图），他就代表超过了6（16-10，这个我们叫低状态），但是没有超过7（16-9，这个我们叫高状态） = =！</p><p>特殊情况下，标签“L=19”表示字符处于“9”和“0”之间的“中间状态”（忽略进位）。在这种设置中，图2b中的第四章图片的标签是“2  0 3 16 19”。该标签序列可进一步处理为第III-D节所述的水表编号“20369.5”，这在实际应用中更为合理和实用。</p><h3 id="全卷积序列识别网络"><a href="#全卷积序列识别网络" class="headerlink" title="|||.全卷积序列识别网络"></a>|||.全卷积序列识别网络</h3><img src="/ck3hez7c9004mdwg4hjdl2g6t/image-20191124173018340.png" class="">    <p>​                                                                                                        图3</p><p>所提出的FCSRN由三个部分组成：全卷积骨干网、时间映射器和转录层（如图3所示）。卷积层在从图像中学习特征方面非常强大，我们使用FCN作为骨干网络。在FCN的基础上，利用时间映射器从二维特征图中生成一维特征序列。最后，转录层将这些序列特征转化为最终的标签序列。</p><img src="/ck3hez7c9004mdwg4hjdl2g6t/image-20191124173318716.png" class="">    <p>​                                                                                                                        图4</p><h4 id="A-全卷积网络"><a href="#A-全卷积网络" class="headerlink" title="A.全卷积网络"></a>A.全卷积网络</h4><p>我们使用何恺明大神在深度残差网络中提出的剩余块来构建FCN作为骨干网。我们的FCSRN采用了两种类型的剩余块，如图4所示。当输入x和输出y的维数相同时，剩余块A（如左图所示）用于从增加深度的模型中获得较大的感受野，并避免臭名昭著的梯度消失/爆炸问题，而剩余块B（右示）用于减少特征映射，并增加一倍滤波器数量以增加模型能力并保持模型复杂度。在每个卷积层之后使用BN层（批处理归一化，也是用于防止梯度消失/爆炸）和ReLU激活函数。</p><img src="/ck3hez7c9004mdwg4hjdl2g6t/image-20191124174235546.png" class="">    <p>​                                                                                                                                表2</p><p>我们构造了一个16层FCN，其中包含残差块，用于从输入图像中提取特征，如表2所示。我们使用较小的卷积核大小（3×3）来学习精细的局部特征，并使用堆栈多卷积层来提取具有大感受野的长期特征。响应图中的位置对应于输入图像中的矩形区域（称为感受野）。计算准确位置和感受野大小的分层公式如下（1，2）：</p><img class="-20191124174819870.png">    <p>其中ri是i层的局部区域大小，k是卷积核的大小，s是步长大小，p表示位置，d是特定层的填充大小。我们发现，深度足够的CNN中的高层特征对应于大的感受野，并且能够利用上下文信息捕获长期依赖关系。</p><h4 id="B-时间映射器"><a href="#B-时间映射器" class="headerlink" title="B.时间映射器"></a>B.时间映射器</h4><p>由于从FCN中提取的特征已经包含上下文信息，因此我们使用时间映射器而不是任何循环或全连接层来在转换层之前生成特征序列。时间映射器由卷积层、批处理规范化BN层和高度规范化HN层（没听说这个= =）组成。卷积层输出K（总字符类加空白）通道特征映射，为每个对应类别生成一个特征映射。</p><p>卷积层优先于完全连接层，因为卷积结构更自然地加强特征映射和类别之间的对应关系[34]。卷积层的核大小、步长和填充大小分别设置为3×3、1和1。我们假设输入特征映射的每一列都是要预测的时间步；因此，我们使用高度规范化层（也称为平均池层）来规范化每一列的特征。因此，我们可以将二维特征映射到一维序列特征，这些序列特征将被输入到最终的转录层中。如第V-D3节所述，映射的序列特征包含转录所需的上下文信息。</p><h4 id="C-转换层"><a href="#C-转换层" class="headerlink" title="C.转换层"></a>C.转换层</h4><p>在WNR中，转录用于将特征转换为从“0”到“19”范围内的字符序列。我们使用连接主义时间分类（CTC）作为转换层。CTC允许在输入序列和标签之间没有任何预先对齐的情况下对模型进行训练。（ CTC，Connectionist Temporal Classification，用来解决输入序列和输出序列难以一一对应的问题。 ）</p><p>让我们将字符表示为C={0,1，···，19，blank}，其中blank表示在相应的时间步没有预测。给定输入特征序列“s^k=s1^k  s2^k··st^k” ，通道k=21，总时间步长t，CTC通过对每个时间步长应用softmax函数指定序列上的分布，并提供在相应时间步长输出预测字符的概率。从该分布中采样的每个潜序列可以使用映射函数SGM变换成输出序列，该映射函数首先将连续重复的非空字符合并为一个字符，然后去除空白字符。例如，“1 2 2 5 8”可以由序列“b b 1 1 b 2 2 2 b b 2 b b b 5 8 8 b b b”的σ变换（其中b表示空白，T=20，过程就是先把连续重复的数字合并为一个字符，比如”b b 1 b 2 b b 2 b b b 5 8 b b b “，然后再把空字符删掉，就变成了”1 2 2 5 8”）。最终的输出序列概率是应用函数σ后对模拟目标结果的所有可能序列的总和。</p><h4 id="D-解码"><a href="#D-解码" class="headerlink" title="D.解码"></a>D.解码</h4><p>我们使用naive(天真的)解码算法（也称为最佳路径解码）来对FCSRN的输出进行预测。我们首先在每个时间步上使用一个softmax函数，然后在每个时间步t上考虑最可能的标签lt，得到预测序列，最后使用函数σ（见第III-C节）映射结果。</p><p>如第二节所述，解码后的图像（在图2b中，在第2行，第1列）的转换结果为：“2 0 3 16  19”，并且在实际应用中，该预测应转换为“20369.5”。因此，我们为处于“中间状态”的每个字符c引入一种后处理方法：</p><img src="/ck3hez7c9004mdwg4hjdl2g6t/image-20191124192303530.png" class=""><p>如果预测的数字在序列的末尾并且处于“中间状态”（详见第二节），则我们从该数字中减去9.5。例如，对于预测结果“12”，即对应的数字超过“2”，但未达到“3”，我们选择将其预测为“2”，并通过将0.5添加到最终数字来向结果附加“中间状态”标志。如果“中间状态”字符不是最后一个字符，那么我们只需从数字中减去10，从而表明选择了“较低状态”，这在直觉上更为合理。</p><h3 id="IV-增广损失函数"><a href="#IV-增广损失函数" class="headerlink" title="IV.增广损失函数"></a>IV.增广损失函数</h3><h4 id="A-CTC的增广损失函数"><a href="#A-CTC的增广损失函数" class="headerlink" title="A.CTC的增广损失函数"></a>A.CTC的增广损失函数</h4><p>对于基于FCSRN和RNN的模型，我们使用CTC作为目标函数。给定长度为T的输入序列x，使用softmax函数对向量yt进行规范化，然后解释为在时间步t时刻索引k的标签（或空白）的概率（对应于数字）：</p><img src="/ck3hez7c9004mdwg4hjdl2g6t/image-20191125141133902.png" class=""><p>其中yk是yt的元素k。CTC校准a是长度为T的空白和标签序列。a的概率Pr（a |x）是每个时间步的排放概率的乘积：</p><img src="/ck3hez7c9004mdwg4hjdl2g6t/image-20191125141601563.png" class=""><p>对于一个给定的转录序列，有尽可能多的可能的排列方式，以不同的方式将标签与空白区分开。另外，输出转录y的总概率等于与之对应的排列的概率之和：</p><img src="/ck3hez7c9004mdwg4hjdl2g6t/image-20191125141731428.png" class=""><p>给定目标转录y*，然后可以训练该模型以最小化CTC目标函数</p><img src="/ck3hez7c9004mdwg4hjdl2g6t/image-20191125141817667.png" class=""><p>如第二节所述，超过“5”（“低状态”）但未达到“6”（“高状态”）的字符定义为“中间状态”，应标记为“15”。直观地说，模型区分“低状态”、“中状态”和“高状态”字符是令人困惑的。然而，对于标签为“1 2 12 15 8”的样本，我们是是可以容忍将他们转换成这样的，举个例子：例如“1 12 12 15 8”或“1 12 2 15 8”，因为所有这些可能的预测都可以解码为相同的结果“12258”，如第III-D节所述。因此，我们引入一个增加损失（表示为AugLoss），它用相应的“低状态”标签（表示为y’）计算预测的CTC损失，以及用真值标签计算的正常CTC损失（表示为CTCLoss）：</p><img src="/ck3hez7c9004mdwg4hjdl2g6t/image-20191125142604569.png" class=""><p>直观地说，这两个损失都是WNR中识别精度的指标。我们联合训练这两种损失的网络，以提高辨别能力：</p><img src="/ck3hez7c9004mdwg4hjdl2g6t/image-20191125142707145.png" class=""><p>其中调整参数α表示AugLoss损失的权重。AugLoss可以解释为将“中间状态”偏向“较低状态”，而不是“高状态”或“非状态”（例如预测“1”到“7”）预测。我们将第一种情况称为“错误状态”错误（MSE），将其他情况称为“错误识别”错误（MRE）。如V-E节所示，Au’gLoss损失可以有效地降MRE，提高性能。</p><h4 id="B-基于注意力的模型的增加损失"><a href="#B-基于注意力的模型的增加损失" class="headerlink" title="B.基于注意力的模型的增加损失"></a>B.基于注意力的模型的增加损失</h4><p>对于基于注意的模型，我们使用softmax交叉熵函数作为目标函数。输出y的概率PrA（y | x）是每个时间步的排放概率的乘积：</p><img src="/ck3hez7c9004mdwg4hjdl2g6t/image-20191125143147521.png" class=""><p>给定目标转录y∗，然后可以训练该模型以最小化以下目标函数：</p><img src="/ck3hez7c9004mdwg4hjdl2g6t/image-20191125143242520.png" class=""><p>如第IV-A节所述，我们将增加损失函数定义如下：</p><img src="/ck3hez7c9004mdwg4hjdl2g6t/image-20191125143325808.png" class=""><p>此外，基于注意力的模型的损失函数是：</p><img src="/ck3hez7c9004mdwg4hjdl2g6t/image-20191125143354016.png" class=""><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><h4 id="A-数据预处理"><a href="#A-数据预处理" class="headerlink" title="A.数据预处理"></a>A.数据预处理</h4><p>SCUT-WMN数据集包含5000个困难样本和1000个简单样本，这些样本包含广泛的图像大小和比率。所有（困难和容易）样本的最大和最小宽度分别为418和201像素。最大和最小高度分别为111和37像素。此外，最大和最小纵横比（宽度/高度）分别为6.619和2.933。</p><img src="/ck3hez7c9004mdwg4hjdl2g6t/image-20191125143609688.png" class=""><p>为了并行计算，我们调整了所有图像的大小，使其具有相同的高度和宽度w，并在图像的相对较短的一侧使用必要的零填充（通过将图像比率与w/H进行比较）。数据预处理的目的是管理不同的图像大小，同时保留比例以避免失真。设W（宽度）=160，H（高度）=48，如图5所示。</p><h4 id="B-性能评估"><a href="#B-性能评估" class="headerlink" title="B.性能评估"></a>B.性能评估</h4><p>对于WNR，我们使用两个标准来衡量性能：</p><img src="/ck3hez7c9004mdwg4hjdl2g6t/image-20191125143905837.png" class=""><p>其中，LCR表示线正确率，AR表示准确率。Nc是正确识别的样本数，Nl是测试样本数，Nt是测试集中的字符数。替换错误、删除错误和插入错误是通过使用动态编程的纠错字符串匹配来计算的。我们还提出了另一个标准，称为线部分准确率（LPR）：</p><img src="/ck3hez7c9004mdwg4hjdl2g6t/image-20191125144508213.png" class=""><p>其中Nc’是部分正确识别的样本数，指预测包含错误字符但可以解码为正确目标数的样本，如第III-D节所述。例如，真实值“1  2 12 15 8”和预测值“1 12 12 15 8”或“1 12 2 15  8”的样本是部分正确识别的样本，因为这两个预测值可以解码为相同的水表数字：“12258”。</p><p>存在几种可能的预测，在解码后产生相同的目标数。因此，LPR是一种更精确的模型性能测量方法。此外，由“错误识别”和“错误状态”（如第四节所述）引起的错误率分别表示为：</p><img src="/ck3hez7c9004mdwg4hjdl2g6t/image-20191125144820237.png" class=""><h4 id="C-训练细节"><a href="#C-训练细节" class="headerlink" title="C.训练细节"></a>C.训练细节</h4><p>我们基于SCUT-WMN数据集构造训练集。训练集包含4000个困难样本，测试集由剩余的1000个困难样本构成。对于数据增强实验，我们在训练集中添加了1000个简单样本。</p><p>使用随机梯度下降法最小化模型的目标函数，使用100的批量大小，将学习率、动量和重量衰减分别设置为0.01、0.9和0.0001。网络参数的初始化使用了一个范围为0.01的均匀分布。我们使用MxNet深度学习框架对每个模型进行了100个轮次的训练。</p><h4 id="D-与最先进的方法的比较"><a href="#D-与最先进的方法的比较" class="headerlink" title="D.与最先进的方法的比较"></a>D.与最先进的方法的比较</h4><p>我们评估了WNR任务的各种方法。对于基于分割的方法，我们评估了两个卷积神经网络（ResNet[30]和FCSRN的骨干网络，我们称之为CharNet）。由于SCUT-WMN中的所有图像都包含五位数字，因此我们首先按照第V-A节的说明执行数据预处理，然后手动将每个处理过的图像分成五个等长列。</p><p>然后，任务就变成了单独的字符识别的问题。然而，值得注意的是，在实际应用中，水表可能有各种数字。对于无分割方法，我们评估了所提出的FCSRN、基于RNN的CRNN和基于注意的ConvS2S模型。具体如下：</p><ul><li>1）单独字符识别我们训练了一个18层ResNet作为基准线（输出通道设置为20）。为了与FCSRN进行公平比较，我们训练了一个CNN，该CNN由与FCSRN相同的骨干网、卷积层（核大小设置为3×3、步长设置为1×1、输出通道设置为20）、批处理规范化层和全局池层组成。我们称这个网络为CharNet。目标函数为softmax交叉熵损失函数。</li><li>2）基于RNN的CRNN和基于注意的CONVS2：为了公平比较FCSRN和CRNN，我们构造了一系列模型来确定最优超参数。CRNN模型的骨干网与FCSRN中的FCN相同。我们使用了一个多层LSTM（有k层，其中每层包含n个隐藏单元）和两个完全连接的层（分别输出c和2121通道特征），然后在最后的CTC层之上。我们训练了一系列k∈[1,2,3,4]，n∈[32,48,64128]和c∈[32,48,64,96128256]的模型，得到了在k=1，n=32，c=64时的最优结果。对于基于注意的ConvS2S模型，骨干网与FCSRN相同。我们对编码器和解码器都使用了64个隐藏单元。所有的嵌入，包括解码器在最终线性层（linear）之前产生的输出，都有32个维度。</li><li>3）提出的FCSRN和增加损失：我们评估了有/无AugLoss的FCSRN。对于有AugLoss的FCSRN，分别采用两个时间映射器和两个转录层来计算CTCLoss和AugLoss，并在两个损失中共享相同的FCN。我们训练了一系列模型来确定等式（9）中定义的最优超参数α，并报告了在α=0.2时获得的最佳结果（在下一节中解释）。</li></ul><img src="/ck3hez7c9004mdwg4hjdl2g6t/image-20191125150708754.png" class=""><p>​                                                                                                                        表3</p><p>上述模型的实验结果见表3。我们可以观察到，FCSRN比数字识别模型（ResNet18和CharNet）表现得更好，并且与最佳CRNN和ConvS2S模型具有可比性。因此，我们可以得出结论，具有足够深度和一个大的上下文窗口的卷积模型也能够学习转录所需的上下文依赖性（如第III-a节所述）。与CRNN（convs2）相比，FCSRN的训练时间减少了35%（25%），所涉及的参数减少了45%（33%）。</p><p>FCSRN比CRNN和convs2具有更高的训练速度，这主要是由于卷积运算的并行性，因为循环模型中的计算是连续的，不容易并行化，而注意机制中的解码器需要参数，因此需要更多的训练时间。</p><p>带有AugLoss的FCSRN在很大程度上优于单独字符识别、基于RNN和基于注意机制的模型。与无AugLoss的FCSRN相比，MRE相对降低了54.29%。AugLoss将“低状态”和“中间状态”字符视为同一类；也就是说，标签为“2”且预测为“2”或“12”，不会导致AugLoss出错。但是，标签为“5”的字符预测为“12”时，CTCLoss和AugLoss都会产生错误。因此，该模型学会了在针对AugLoss进行优化时避免MRE，并区分“不同状态”以最小化CTCLoss。因此，AugLoss有效地降低了MRE，提高了性能。</p><img src="/ck3hez7c9004mdwg4hjdl2g6t/image-20191125151543102.png" class=""><p>​                                                                                                                 表4</p><img src="/ck3hez7c9004mdwg4hjdl2g6t/image-20191125151643981.png" class=""><p>​                                                                                                                 表5</p><img src="/ck3hez7c9004mdwg4hjdl2g6t/image-20191125151712556.png" class=""><p>​                                                                                                                 表6</p><h4 id="E-增加损失的效率"><a href="#E-增加损失的效率" class="headerlink" title="E.增加损失的效率"></a>E.增加损失的效率</h4><p>所提出的AugLoss不仅可以用于FCSRN，而且可以改善CharNet、CRNN和ConvS2S的性能，我们用所提出的损失函数对这些模型进行训练，并进行了一系列实验来确定每个模型的最优超参数α。实验结果见表6，最佳结果见表4进行比较。FCSRN、CRNN、ConvS2S和CharNet的最佳优化超参数α* 分别是0.2、0.3、0.2和0.8，相对MRE分别降低54.29%、64.00%、40.30%和40.26%。我们的结论是，AugLoss是一种有效提高WNR任务性能的通用技术。</p><h4 id="F-数据增广"><a href="#F-数据增广" class="headerlink" title="F.数据增广"></a>F.数据增广</h4><p>我们采用了数据增强来提高性能。训练集由4000个困难样本和1000个简单样本组成，在增加图像噪声的情况下，随机调整亮度、饱和度、色调和对比度，然后进行非独立高斯分布的叠加噪声、泊松分布噪声、盐噪声、胡椒噪声和这些噪声的随机组合。实验结果（见表5）表明，数据增强稍微提高了性能。今后的工作将考虑进一步改进。</p><h3 id="VI总结"><a href="#VI总结" class="headerlink" title="VI总结"></a>VI总结</h3><p>本文主要研究了一种典型的基于图像的序列识别问题WNR。我们构建了一个开放式研究的数据集SCUT-WMN，并提出了快速准确识别的FCSRN。此外，还提出了一个增广损失函数来管理字符的中间状态并减少MRE。实验结果表明，FCSRN具有捕获上下文信息和消除重复层的能力，同时所需参数少，计算量小。带AugLoss的FCSRN优于基于RNN和基于注意的模型。此外，AugLoss有效地提高了基于RNN和基于注意的模型的性能。WNR在现实世界中有着许多有前途的应用，我们希望我们的方法和数据集一起能够有助于今后对这一课题的研究。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近，读了一篇FCN的论文，然后记录一下，准备回看~&lt;/p&gt;
&lt;h2 id=&quot;Fully-Convolutional-Sequence-Recognition-Network-for-Water-Meter-Number-Reading&quot;&gt;&lt;a href=&quot;#Fully-Convolutional-Sequence-Recognition-Network-for-Water-Meter-Number-Reading&quot; class=&quot;headerlink&quot; title=&quot;Fully Convolutional Sequence Recognition Network for Water Meter Number Reading&quot;&gt;&lt;/a&gt;Fully Convolutional Sequence Recognition Network for Water Meter Number Reading&lt;/h2&gt;&lt;p&gt;全卷积序列识别网络用于水表数字识别（团队来自华南理工大学电子与信息工程学院）&lt;/p&gt;
    
    </summary>
    
    
      <category term="论文" scheme="https://cblog.club/categories/%E8%AE%BA%E6%96%87/"/>
    
      <category term="图像领域" scheme="https://cblog.club/categories/%E8%AE%BA%E6%96%87/%E5%9B%BE%E5%83%8F%E9%A2%86%E5%9F%9F/"/>
    
    
      <category term="论文" scheme="https://cblog.club/tags/%E8%AE%BA%E6%96%87/"/>
    
      <category term="图像领域" scheme="https://cblog.club/tags/%E5%9B%BE%E5%83%8F%E9%A2%86%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>Django单元测试</title>
    <link href="https://cblog.club/ck3hez7am0037dwg4b8cx8cov.html"/>
    <id>https://cblog.club/ck3hez7am0037dwg4b8cx8cov.html</id>
    <published>2019-11-25T01:20:19.000Z</published>
    <updated>2019-11-25T01:43:38.455Z</updated>
    
    <content type="html"><![CDATA[<p>今天又重新回头看了一点关于Django单元测试的内容，写测试真的是一个很好的事情，对于代码重构，后期维护都非常有用。以下是Django文档中关于测试方面的内容，可以作为参考，当然，面对不同的项目，测试也不尽相同，写测试，真的很需要经验，一开始还真是无从下手= =！</p><a id="more"></a><h4 id="Django为测试提供了什么？"><a href="#Django为测试提供了什么？" class="headerlink" title="Django为测试提供了什么？"></a>Django为测试提供了什么？</h4><p>测试网站是一项复杂的任务，因为它由多层逻辑组成 - 从 HTTP 级请求处理，查询模型，到表单验证和处理，以及模板呈现。 </p><p>Django 提供了一个测试框架，其中包含基于 Python 标准<code>unittest</code>库的小型层次结构。尽管名称如此，但该测试框架适用于单元测试和集成测试。 Django 框架添加了 API 方法和工具，以帮助测试 Web 和 Django 特定的行为。这允许您模拟请求，插入测试数据以及检查应用程序的输出。 Django 还提供了一个API（<a href="https://docs.djangoproject.com/en/2.0/topics/testing/tools/#liveservertestcase" target="_blank" rel="noopener">LiveServerTestCase</a>）和<a href="https://docs.djangoproject.com/en/2.0/topics/testing/advanced/#other-testing-frameworks" target="_blank" rel="noopener">使用不同测试框架</a>的工具，例如，您可以与流行的 <a href="https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Cross_browser_testing/Your_own_automation_environment" target="_blank" rel="noopener">Selenium</a> 框架集成，以模拟用户与实时浏览器交互。 </p><p>要编写测试，您可以从任何 Django（或unittest）测试基类（<a href="https://docs.djangoproject.com/en/2.0/topics/testing/tools/#simpletestcase" target="_blank" rel="noopener">SimpleTestCase</a>, <a href="https://docs.djangoproject.com/en/2.0/topics/testing/tools/#transactiontestcase" target="_blank" rel="noopener">TransactionTestCase</a>, <a href="https://docs.djangoproject.com/en/2.0/topics/testing/tools/#testcase" target="_blank" rel="noopener">TestCase</a>, <a href="https://docs.djangoproject.com/en/2.0/topics/testing/tools/#liveservertestcase" target="_blank" rel="noopener">LiveServerTestCase</a>）派生，然后编写单独的方法，来检查特定功能，是否按预期工作（测试使用 “assert” 方法来测试表达式导致 <code>True</code>或 <code>False</code>值，或者两个值相等，等等。）当您开始测试运行时，框架将在派生类中执行所选的测试方法。测试方法独立运行，具有在类中定义的常见设置和/或拆卸行为，如下所示。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YourTestClass</span><span class="params">(TestCase)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#Setup run before every test method.</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#Clean up run after every test method.</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_something_that_will_pass</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertFalse(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_something_that_will_fail</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertTrue(<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>大多数测试的最佳基类是 <a href="https://docs.djangoproject.com/en/2.0/topics/testing/tools/#testcase" target="_blank" rel="noopener">django.test.TestCase</a>。此测试类在运行测试之前，创建一个干净的数据库，并在自己的事务中，运行每个测试函数。该类还拥有一个<a href="https://docs.djangoproject.com/en/2.0/topics/testing/tools/#django.test.Client" target="_blank" rel="noopener">测试客户端</a>，您可以使用该客户端，模拟在视图级别与代码交互的用户。在下面的部分中，我们将集中讨论使用此<a href="https://docs.djangoproject.com/en/2.0/topics/testing/tools/#testcase" target="_blank" rel="noopener">TestCase</a> 基类创建的单元测试。 </p><p><strong>注意:</strong> <a href="https://docs.djangoproject.com/en/2.0/topics/testing/tools/#testcase" target="_blank" rel="noopener">django.test.TestCase</a> 类非常方便，但可能会导致某些测试，比它们需要的速度慢（并非每个测试，都需要设置自己的数据库，或模拟视图交互）。一旦熟悉了这个类可以做什么，您可能希望用可以用更简单的测试类，替换一些测试。 </p><h4 id="你应该测试什么？"><a href="#你应该测试什么？" class="headerlink" title="你应该测试什么？"></a>你应该测试什么？</h4><p>您应该测试自己代码的所有方面，但不要测试 Python 或 Django 的一部分提供的任何库或功能。</p><p>例如，考虑下面定义的 <code>Author</code>模型。您不需要显式测试 <code>first_name</code> 和 <code>last_name</code> 是否已在数据库中正确储存为<code>CharField</code>，因为这是 Django 定义的内容（当然，在实践中，您将不可避免地在开发期间测试此功能）。你也不需要测试<code>date_of_birth</code>是否已被验证为日期字段，因为这也是 Django 中实现的东西。</p><p> 但是，您应该检查用于标签的文本（名字，姓氏，出生日期，死亡），以及为文本分配的字段大小（100个字符），因为这些是您的设计的一部分，可能会在将来被打破/改变。 </p><p>官方文档使用一个在线图书馆为例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    first_name = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    last_name = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    date_of_birth = models.DateField(null=<span class="literal">True</span>, blank=<span class="literal">True</span>)</span><br><span class="line">    date_of_death = models.DateField(<span class="string">'Died'</span>, null=<span class="literal">True</span>, blank=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_absolute_url</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> reverse(<span class="string">'author-detail'</span>, args=[str(self.id)])</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'%s, %s'</span> % (self.last_name, self.first_name)</span><br></pre></td></tr></table></figure><p>同样，您应该检查自定义方法 <code>get_absolute_url()</code> 和 <code>__str__()</code> 是否符合要求，因为它们是您的代码/业务逻辑。在<code>get_absolute_url()</code>的情况下，您可以相信 Django <code>reverse()</code>方法已经正确实现，因此您正在测试的是实际上已经定义了关联的视图。 </p><h4 id="测试结构概述"><a href="#测试结构概述" class="headerlink" title="测试结构概述"></a>测试结构概述</h4><p>在我们详细讨论“测试内容”之前，让我们先简要介绍一下测试的定位和方式。</p><p>Django 使用 unittest 模块的<a href="https://docs.python.org/3/library/unittest.html#unittest-test-discovery" target="_blank" rel="noopener">内置测试查找</a>，它将在任何使用模式<strong>test*.py</strong> 命名的文件中，查找当前工作目录下的测试。如果您正确命名文件，则可以使用您喜欢的任何结构。我们建议您为测试代码创建一个模块，并为模型，视图，表单和您需要测试的任何其他类型的代码，分别创建文件。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">KIMS/</span><br><span class="line">  /tests/</span><br><span class="line">    __init__.py</span><br><span class="line">    test_models.py</span><br><span class="line">    test_forms.py</span><br><span class="line">    test_views.py</span><br></pre></td></tr></table></figure><p>在 LocalLibrary 项目中，创建如上所示的文件结构。<strong>_<em>init_</em>.py</strong> 应该是一个空文件（这告诉 Python 该目录是一个套件包）。您可以通过复制和重命名框架测试文件<strong>/catalog/tests.py</strong>，来创建三个测试文件。 </p><p><strong>注意:</strong> 我们构建 Django 骨架网站时，会自动创建骨架测试文件<strong>/catalog/tests.py</strong> 。将所有测试放入其中是完全“合法的”，但如果测试正确，您将很快得到一个非常庞大且难以管理的测试文件。(全部测试都放在一个文件下，太难管理了= =)</p><p>删除骨架文件，因为我们不需要它。</p><p> 打开 <strong>/catalog/tests/test_models.py</strong>。 该文件应导入<code>django.test.TestCase</code>，如下所示： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.test <span class="keyword">import</span> TestCase</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your tests here.</span></span><br></pre></td></tr></table></figure><p>通常，您将为要测试的每个模型/视图/表单添加测试类别，并使用个别方法来测试特定功能。在其他情况下，您可能希望有一个分开的类别，来测试特定用例，使用个别的测试函数，来测试该用例的各个方面（例如，测试模型字段已正确验证的类，以及测试每个可能的失败案例的函数）。相同地，这样的结构非常适合您，但最好您能保持一致。</p><p>将下面的测试类别，添加到文件的底部。该类别演示了，如何通过派生<code>TestCase</code>，构建测试用例类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YourTestClass</span><span class="params">(TestCase)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUpTestData</span><span class="params">(cls)</span>:</span></span><br><span class="line">        print(<span class="string">"setUpTestData: Run once to set up non-modified data for all class methods."</span>)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"setUp: Run once for every test method to setup clean data."</span>)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_false_is_false</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Method: test_false_is_false."</span>)</span><br><span class="line">        self.assertFalse(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_false_is_true</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Method: test_false_is_true."</span>)</span><br><span class="line">        self.assertTrue(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_one_plus_one_equals_two</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Method: test_one_plus_one_equals_two."</span>)</span><br><span class="line">        self.assertEqual(<span class="number">1</span> + <span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>新的类别定义了两个可用于测试之前的配置的方法（例如，创建测试所需的任何模型或其他对象）： </p><ul><li><p><code>setUpTestData()</code> 用于类级别设置，在<strong>测试运行开始的时侯，会调用一次</strong>。您可以使用它来创建在任何测试方法中，都不会修改或更改的对象。 </p></li><li><p><code>setUp()</code> 在<strong>每个测试函数之前被调用</strong>，以设置可能被测试修改的任何对象（每个测试函数，都将获得这些对象的 “新” 版本）。 </p></li></ul><p><strong>注意</strong>：测试类别还有一个我们还没有使用的<code>tearDown()</code>方法。此方法对数据库测试不是特别有用，因为<code>TestCase</code>基类会为您处理数据库拆卸。 </p><p>下面我们有一些测试方法，它们使用 <code>Assert</code>函数来测试条件是真，假或相等（<code>AssertTrue</code>, <code>AssertFalse</code>, <code>AssertEqual</code>）。如果条件评估不如预期，则测试将失败，并将错误报告给控制台。</p><p><code>AssertTrue</code>, <code>AssertFalse</code>, <code>AssertEqual</code>是 <strong>unittest</strong> 提供的标准断言。框架中还有其他标准断言，还有 <a href="https://docs.djangoproject.com/en/2.0/topics/testing/tools/#assertions" target="_blank" rel="noopener">Django 特定的断言</a>，来测试视图是否重定向（<code>assertRedirects</code>），或测试是否已使用特定模板（<code>assertTemplateUsed</code>）等。</p><h4 id="如何运行测试"><a href="#如何运行测试" class="headerlink" title="如何运行测试"></a>如何运行测试</h4><p>要运行所有测试，最简单的方法，是使用以下命令： </p><p><code>python manage.py test</code></p><p>这将查找当前目录下，使用模式 <strong>test*.py</strong> 命名的所有文件，并运行使用适当基类定义的所有测试（这里我们有许多测试文件，但只有 <strong>/catalog/tests/test_models.py</strong> 目前包含任何测试。）。默认情况下，测试将仅单独报告测试失败，然后是测试摘要。 </p><p>如果您收到类似于以下内容的错误：<code>ValueError: Missing staticfiles manifest entry ...</code> 这可能是因为默认情况下，测试不会运行 collectstatic，而您的应用程序正在使用需要它的储存类别（有关更多信息，请参阅 <a href="https://docs.djangoproject.com/en/2.0/ref/contrib/staticfiles/#django.contrib.staticfiles.storage.ManifestStaticFilesStorage.manifest_strict" target="_blank" rel="noopener">manifest_strict</a>）。有许多方法可以解决这个问题 - 最简单的方法，是在运行测试之前，简单地运行collectstatic： </p><p><code>python manage.py collectstatic</code></p><p> 在 LocalLibrary 的根目录中，运行测试。您应该看到如下所示的输出 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt;python manage.py <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">Creating <span class="built_in">test</span> database <span class="keyword">for</span> <span class="built_in">alias</span> <span class="string">'default'</span>...</span><br><span class="line">setUpTestData: Run once to <span class="built_in">set</span> up non-modified data <span class="keyword">for</span> all class methods.</span><br><span class="line">setUp: Run once <span class="keyword">for</span> every <span class="built_in">test</span> method to setup clean data.</span><br><span class="line">Method: test_false_is_false.</span><br><span class="line">.setUp: Run once <span class="keyword">for</span> every <span class="built_in">test</span> method to setup clean data.</span><br><span class="line">Method: test_false_is_true.</span><br><span class="line">FsetUp: Run once <span class="keyword">for</span> every <span class="built_in">test</span> method to setup clean data.</span><br><span class="line">Method: test_one_plus_one_equals_two.</span><br><span class="line">.</span><br><span class="line">======================================================================</span><br><span class="line">FAIL: test_false_is_true (catalog.tests.tests_models.YourTestClass)</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"D:\Github\django_tmp\library_w_t_2\locallibrary\catalog\tests\tests_models.py"</span>, line 22, <span class="keyword">in</span> test_false_is_true</span><br><span class="line">    self.assertTrue(False)</span><br><span class="line">AssertionError: False is not <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran 3 tests <span class="keyword">in</span> 0.075s</span><br><span class="line"></span><br><span class="line">FAILED (failures=1)</span><br><span class="line">Destroying <span class="built_in">test</span> database <span class="keyword">for</span> <span class="built_in">alias</span> <span class="string">'default'</span>...</span><br></pre></td></tr></table></figure><p>在这里，我们看到有一个测试失败，我们可以确切地看到哪个函数失败了、为什么失败（这个失败是预期的，因为 <code>False</code>不是 <code>True</code>！）。 </p><p><strong>提示:</strong> 从上面的测试输出中，学到的最重要事情是，如果为对象和方法使用描述性/信息性名称，它会更有价值。 </p><p>上面以<strong>粗体</strong>显示的文本，通常不会出现在测试输出中（这是由我们的测试中的<code>print()</code>函数生成的）。这显示了如何为类调用<code>setUpTestData()</code>方法，并在每个方法之前调用<code>setUp()</code>。 </p><p>接下来的部分，将介绍如何运行特定测试，以及如何控制测试显示的信息量。 </p><h4 id="显示更多测试信息"><a href="#显示更多测试信息" class="headerlink" title="显示更多测试信息"></a>显示更多测试信息</h4><p>如果您想获得有关测试运行的更多信息，可以更改详细程度。例如，要列出测试成功和失败（以及有关如何设置测试数据库的大量信息），您可以将详细程度设置为 “2”，如下所示： </p><p><code>python manage.py test --verbosity 2</code></p><p>允许的详细级别为 0, 1 ,2 和 3，默认值为 “1”。 </p><h4 id="运行特定测试"><a href="#运行特定测试" class="headerlink" title="运行特定测试"></a>运行特定测试</h4><p>如果要运行测试的子集，可以通过指定包，模块，<code>TestCase</code>子类或方法的完整路径（包含点）来执行此操作： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python manage.py <span class="built_in">test</span> catalog.tests   <span class="comment"># 运行特定的测试，该文件在项目的tests文件夹下</span></span><br><span class="line">python manage.py <span class="built_in">test</span> catalog.tests.test_models  <span class="comment"># 运行上方文件下的特定的测试文件</span></span><br><span class="line">python manage.py <span class="built_in">test</span> catalog.tests.test_models.YourTestClass <span class="comment"># 运行上方文件的特定测试类</span></span><br><span class="line">python manage.py <span class="built_in">test</span> catalog.tests.test_models.YourTestClass.test_one_plus_one_equals_two  <span class="comment"># 运行上方测试类的特定的方法</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天又重新回头看了一点关于Django单元测试的内容，写测试真的是一个很好的事情，对于代码重构，后期维护都非常有用。以下是Django文档中关于测试方面的内容，可以作为参考，当然，面对不同的项目，测试也不尽相同，写测试，真的很需要经验，一开始还真是无从下手= =！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Django" scheme="https://cblog.club/categories/Django/"/>
    
      <category term="自动化测试" scheme="https://cblog.club/categories/Django/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="Django" scheme="https://cblog.club/tags/Django/"/>
    
      <category term="自动化测试" scheme="https://cblog.club/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>46全排列</title>
    <link href="https://cblog.club/ck3hez79h001pdwg47cs21lqt.html"/>
    <id>https://cblog.club/ck3hez79h001pdwg47cs21lqt.html</id>
    <published>2019-11-25T01:03:23.000Z</published>
    <updated>2019-11-25T01:19:24.555Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p> 给定一个<strong>没有重复</strong>数字的序列，返回其所有可能的全排列。 </p><a id="more"></a><blockquote><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：本题是经典回溯问题的入门题目，详细回溯算法，可以看回溯那一章博客，主要问题还是你得理解递归的细节过程，能自己推出过程，然后这一题再找是否有重复出现的数字时，可以采用visited-bool数组标记是否选过，当然也可以将走过的数字插入到一个数组中，然后再在数组中寻找，时间复杂度就比较高了，也有交换数字的方法，很高效，但是还没有仔细看，这一题需要重构，多用几种方法。"><a href="#解题思路：本题是经典回溯问题的入门题目，详细回溯算法，可以看回溯那一章博客，主要问题还是你得理解递归的细节过程，能自己推出过程，然后这一题再找是否有重复出现的数字时，可以采用visited-bool数组标记是否选过，当然也可以将走过的数字插入到一个数组中，然后再在数组中寻找，时间复杂度就比较高了，也有交换数字的方法，很高效，但是还没有仔细看，这一题需要重构，多用几种方法。" class="headerlink" title="解题思路：本题是经典回溯问题的入门题目，详细回溯算法，可以看回溯那一章博客，主要问题还是你得理解递归的细节过程，能自己推出过程，然后这一题再找是否有重复出现的数字时，可以采用visited bool数组标记是否选过，当然也可以将走过的数字插入到一个数组中，然后再在数组中寻找，时间复杂度就比较高了，也有交换数字的方法，很高效，但是还没有仔细看，这一题需要重构，多用几种方法。"></a>解题思路：本题是经典回溯问题的入门题目，详细回溯算法，可以看回溯那一章博客，主要问题还是你得理解递归的细节过程，能自己推出过程，然后这一题再找是否有重复出现的数字时，可以采用visited bool数组标记是否选过，当然也可以将走过的数字插入到一个数组中，然后再在数组中寻找，时间复杂度就比较高了，也有交换数字的方法，很高效，但是还没有仔细看，这一题需要重构，多用几种方法。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;result;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;init_path;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;visited(nums.size(),<span class="literal">false</span>);</span><br><span class="line">        Backtracking(init_path,nums,result,visited);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Backtracking</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;path,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;select,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp;result,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp;visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size()==select.size())&#123;</span><br><span class="line">            result.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;select.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i]==<span class="literal">true</span>)<span class="keyword">continue</span>;</span><br><span class="line">            path.push_back(select[i]);</span><br><span class="line">            visited[i]=<span class="literal">true</span>;</span><br><span class="line">            Backtracking(path,select,result,visited);</span><br><span class="line">            path.pop_back();</span><br><span class="line">            visited[i]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt; 给定一个&lt;strong&gt;没有重复&lt;/strong&gt;数字的序列，返回其所有可能的全排列。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="回溯" scheme="https://cblog.club/categories/leetcode/%E5%9B%9E%E6%BA%AF/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="回溯" scheme="https://cblog.club/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>63不同路径II</title>
    <link href="https://cblog.club/ck3hez7a1002edwg45vgtdk8y.html"/>
    <id>https://cblog.club/ck3hez7a1002edwg45vgtdk8y.html</id>
    <published>2019-11-24T00:49:21.000Z</published>
    <updated>2019-11-24T00:55:54.530Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>一个机器人位于一个 <em>m x n</em> 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p><p><strong>说明</strong>：<strong>m</strong> 和 <strong>n</strong> 的值均不超过 100。</p><a id="more"></a><blockquote><p><strong>示例 1:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">]</span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释:</span><br><span class="line"><span class="number">3</span>x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 <span class="number">2</span> 条不同的路径：</span><br><span class="line"><span class="number">1.</span> 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line"><span class="number">2.</span> 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：本题就是不同路径的微升级版，只不过增加了障碍物，思路一样，但是初始化不能是第一行，第一列初始为1了，因为第一行，第一列，包括原点都有可能是障碍物，这需要判断一下，直接从原地开始双层循环，越界情况，需要设置一下即可。还有需要注意的是对于二维的vector来说，获取行数用变量-size-，获取列数用变量-0-size，除此之外，数据有可能溢出，需要用long，这点没有考虑-！"><a href="#解题思路：本题就是不同路径的微升级版，只不过增加了障碍物，思路一样，但是初始化不能是第一行，第一列初始为1了，因为第一行，第一列，包括原点都有可能是障碍物，这需要判断一下，直接从原地开始双层循环，越界情况，需要设置一下即可。还有需要注意的是对于二维的vector来说，获取行数用变量-size-，获取列数用变量-0-size，除此之外，数据有可能溢出，需要用long，这点没有考虑-！" class="headerlink" title="解题思路：本题就是不同路径的微升级版，只不过增加了障碍物，思路一样，但是初始化不能是第一行，第一列初始为1了，因为第一行，第一列，包括原点都有可能是障碍物，这需要判断一下，直接从原地开始双层循环，越界情况，需要设置一下即可。还有需要注意的是对于二维的vector来说，获取行数用变量.size()，获取列数用变量[0].size，除此之外，数据有可能溢出，需要用long，这点没有考虑~！"></a>解题思路：本题就是不同路径的微升级版，只不过增加了障碍物，思路一样，但是初始化不能是第一行，第一列初始为1了，因为第一行，第一列，包括原点都有可能是障碍物，这需要判断一下，直接从原地开始双层循环，越界情况，需要设置一下即可。还有需要注意的是对于二维的vector来说，获取行数用变量.size()，获取列数用变量[0].size，除此之外，数据有可能溢出，需要用long，这点没有考虑~！</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">int</span> row,col;</span><br><span class="line">        row=obstacleGrid.size();</span><br><span class="line">        col=obstacleGrid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">int</span> dp[row][col];</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][<span class="number">0</span>]!=<span class="number">1</span>)dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j]==<span class="number">1</span>)dp[i][j]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;j<span class="number">-1</span>&gt;=<span class="number">0</span>)dp[i][j]=dp[i<span class="number">-1</span>][j]+dp[i][j<span class="number">-1</span>];</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(i<span class="number">-1</span>&lt;<span class="number">0</span>&amp;&amp;j<span class="number">-1</span>&gt;=<span class="number">0</span>)dp[i][j]=<span class="number">0</span>+dp[i][j<span class="number">-1</span>];</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;j<span class="number">-1</span>&lt;=<span class="number">0</span>)dp[i][j]=<span class="number">0</span>+dp[i<span class="number">-1</span>][j];</span><br><span class="line">                    <span class="keyword">else</span> dp[i][j]=dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[row<span class="number">-1</span>][col<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;一个机器人位于一个 &lt;em&gt;m x n&lt;/em&gt; 网格的左上角 （起始点在下图中标记为“Start” ）。&lt;/p&gt;
&lt;p&gt;机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。&lt;/p&gt;
&lt;p&gt;现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？&lt;/p&gt;
&lt;p&gt;网格中的障碍物和空位置分别用 &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;0&lt;/code&gt; 来表示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：&lt;strong&gt;m&lt;/strong&gt; 和 &lt;strong&gt;n&lt;/strong&gt; 的值均不超过 100。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/categories/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>PyTorch_CNN</title>
    <link href="https://cblog.club/ck3hez7ao003adwg4127u7qfi.html"/>
    <id>https://cblog.club/ck3hez7ao003adwg4127u7qfi.html</id>
    <published>2019-11-23T13:42:34.000Z</published>
    <updated>2019-11-23T13:52:28.764Z</updated>
    
    <content type="html"><![CDATA[<h3 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h3><ul><li>MNIST举例</li></ul><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设备的配置（这里使用GPU来跑训练）</span></span><br><span class="line">device=torch.device(<span class="string">'cuda'</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">'cpu'</span>)</span><br><span class="line">print(device)</span><br></pre></td></tr></table></figure><pre><code>cuda</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设定超参数</span></span><br><span class="line">num_classes=<span class="number">10</span></span><br><span class="line">num_epochs=<span class="number">30</span></span><br><span class="line">batch_size=<span class="number">100</span></span><br><span class="line">learning_rate=<span class="number">0.001</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#加载MNIST数据集</span></span><br><span class="line">train_dataset=torchvision.datasets.MNIST(root=<span class="string">'./data'</span>,train=<span class="literal">True</span>,download=<span class="literal">True</span>,transform=transforms.ToTensor())</span><br><span class="line"></span><br><span class="line">test_dataset=torchvision.datasets.MNIST(root=<span class="string">'./data'</span>,train=<span class="literal">False</span>,transform=transforms.ToTensor())</span><br></pre></td></tr></table></figure><pre><code>Downloading http://yann.lecun.com/exdb/mnist/train-images-idx3-ubyte.gz to ./data/MNIST/raw/train-images-idx3-ubyte.gz100.1%Extracting ./data/MNIST/raw/train-images-idx3-ubyte.gz to ./data/MNIST/rawDownloading http://yann.lecun.com/exdb/mnist/train-labels-idx1-ubyte.gz to ./data/MNIST/raw/train-labels-idx1-ubyte.gz113.5%Extracting ./data/MNIST/raw/train-labels-idx1-ubyte.gz to ./data/MNIST/rawDownloading http://yann.lecun.com/exdb/mnist/t10k-images-idx3-ubyte.gz to ./data/MNIST/raw/t10k-images-idx3-ubyte.gz100.4%Extracting ./data/MNIST/raw/t10k-images-idx3-ubyte.gz to ./data/MNIST/rawDownloading http://yann.lecun.com/exdb/mnist/t10k-labels-idx1-ubyte.gz to ./data/MNIST/raw/t10k-labels-idx1-ubyte.gz180.4%Extracting ./data/MNIST/raw/t10k-labels-idx1-ubyte.gz to ./data/MNIST/rawProcessing...Done!</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义数据加载器（数据输入流水线）</span></span><br><span class="line">train_dataloader=torch.utils.data.DataLoader(dataset=train_dataset,batch_size=batch_size,shuffle=<span class="literal">True</span>)</span><br><span class="line">test_dataloader=torch.utils.data.DataLoader(dataset=test_dataset,batch_size=batch_size,shuffle=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义一个卷积神经网络（两个卷积层）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConvNet</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,num_classes=<span class="number">10</span>)</span>:</span></span><br><span class="line">        super(ConvNet,self).__init__()</span><br><span class="line">        self.layer1=nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">1</span>,<span class="number">16</span>,kernel_size=<span class="number">5</span>,stride=<span class="number">1</span>,padding=<span class="number">2</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">16</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(kernel_size=<span class="number">2</span>,stride=<span class="number">2</span>))</span><br><span class="line">        self.layer2=nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">16</span>,<span class="number">32</span>,kernel_size=<span class="number">5</span>,stride=<span class="number">1</span>,padding=<span class="number">2</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">32</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(kernel_size=<span class="number">2</span>,stride=<span class="number">2</span>))</span><br><span class="line">        self.fc=nn.Linear(<span class="number">7</span>*<span class="number">7</span>*<span class="number">32</span>,num_classes)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        out=self.layer1(x)</span><br><span class="line">        out=self.layer2(out)</span><br><span class="line">        out=out.reshape(out.size(<span class="number">0</span>),<span class="number">-1</span>)</span><br><span class="line">        out=self.fc(out)</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">model=ConvNet(num_classes).to(device)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义损失函数和优化器</span></span><br><span class="line">criterion=nn.CrossEntropyLoss()</span><br><span class="line">optimizer=torch.optim.SGD(model.parameters(),lr=learning_rate)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#训练模型</span></span><br><span class="line">total_step=len(train_dataloader)</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(num_epochs):</span><br><span class="line">    <span class="keyword">for</span> i,(images,labels) <span class="keyword">in</span> enumerate(train_dataloader):</span><br><span class="line">        images=images.to(device)</span><br><span class="line">        labels=labels.to(device)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#前向传播</span></span><br><span class="line">        outputs=model(images)</span><br><span class="line">        loss=criterion(outputs,labels)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#梯度置0+反向传播+更新权重</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span>)%<span class="number">100</span>==<span class="number">0</span>:</span><br><span class="line">            print(<span class="string">'Epoch [&#123;&#125;/&#123;&#125;], Step [&#123;&#125;/&#123;&#125;], Loss: &#123;:.4f&#125;'</span> .format(epoch+<span class="number">1</span>, num_epochs, i+<span class="number">1</span>, total_step, loss.item()))</span><br></pre></td></tr></table></figure><pre><code>Epoch [1/30], Step [100/600], Loss: 0.1577Epoch [1/30], Step [200/600], Loss: 0.1438Epoch [1/30], Step [300/600], Loss: 0.1884Epoch [1/30], Step [400/600], Loss: 0.2141Epoch [1/30], Step [500/600], Loss: 0.1059Epoch [1/30], Step [600/600], Loss: 0.2351Epoch [2/30], Step [100/600], Loss: 0.1536Epoch [2/30], Step [200/600], Loss: 0.2595Epoch [2/30], Step [300/600], Loss: 0.1568Epoch [2/30], Step [400/600], Loss: 0.1574Epoch [2/30], Step [500/600], Loss: 0.1640Epoch [2/30], Step [600/600], Loss: 0.1491Epoch [3/30], Step [100/600], Loss: 0.1316Epoch [3/30], Step [200/600], Loss: 0.1286Epoch [3/30], Step [300/600], Loss: 0.1090Epoch [3/30], Step [400/600], Loss: 0.1225Epoch [3/30], Step [500/600], Loss: 0.1855Epoch [3/30], Step [600/600], Loss: 0.2051Epoch [4/30], Step [100/600], Loss: 0.1919Epoch [4/30], Step [200/600], Loss: 0.0978Epoch [4/30], Step [300/600], Loss: 0.1332Epoch [4/30], Step [400/600], Loss: 0.0695Epoch [4/30], Step [500/600], Loss: 0.1611Epoch [4/30], Step [600/600], Loss: 0.1686Epoch [5/30], Step [100/600], Loss: 0.0865Epoch [5/30], Step [200/600], Loss: 0.0943Epoch [5/30], Step [300/600], Loss: 0.0437Epoch [5/30], Step [400/600], Loss: 0.1014Epoch [5/30], Step [500/600], Loss: 0.1270Epoch [5/30], Step [600/600], Loss: 0.0938Epoch [6/30], Step [100/600], Loss: 0.1868Epoch [6/30], Step [200/600], Loss: 0.1830Epoch [6/30], Step [300/600], Loss: 0.1203Epoch [6/30], Step [400/600], Loss: 0.1165Epoch [6/30], Step [500/600], Loss: 0.1225Epoch [6/30], Step [600/600], Loss: 0.0663Epoch [7/30], Step [100/600], Loss: 0.1232Epoch [7/30], Step [200/600], Loss: 0.0919Epoch [7/30], Step [300/600], Loss: 0.0830Epoch [7/30], Step [400/600], Loss: 0.1185Epoch [7/30], Step [500/600], Loss: 0.1438Epoch [7/30], Step [600/600], Loss: 0.1936Epoch [8/30], Step [100/600], Loss: 0.0454Epoch [8/30], Step [200/600], Loss: 0.0440Epoch [8/30], Step [300/600], Loss: 0.1723Epoch [8/30], Step [400/600], Loss: 0.1465Epoch [8/30], Step [500/600], Loss: 0.1301Epoch [8/30], Step [600/600], Loss: 0.1120Epoch [9/30], Step [100/600], Loss: 0.1239Epoch [9/30], Step [200/600], Loss: 0.0668Epoch [9/30], Step [300/600], Loss: 0.1200Epoch [9/30], Step [400/600], Loss: 0.0720Epoch [9/30], Step [500/600], Loss: 0.1159Epoch [9/30], Step [600/600], Loss: 0.0869Epoch [10/30], Step [100/600], Loss: 0.0502Epoch [10/30], Step [200/600], Loss: 0.1090Epoch [10/30], Step [300/600], Loss: 0.0604Epoch [10/30], Step [400/600], Loss: 0.0823Epoch [10/30], Step [500/600], Loss: 0.1274Epoch [10/30], Step [600/600], Loss: 0.0921Epoch [11/30], Step [100/600], Loss: 0.0766Epoch [11/30], Step [200/600], Loss: 0.0915Epoch [11/30], Step [300/600], Loss: 0.0680Epoch [11/30], Step [400/600], Loss: 0.0537Epoch [11/30], Step [500/600], Loss: 0.0872Epoch [11/30], Step [600/600], Loss: 0.0501Epoch [12/30], Step [100/600], Loss: 0.0640Epoch [12/30], Step [200/600], Loss: 0.1074Epoch [12/30], Step [300/600], Loss: 0.0648Epoch [12/30], Step [400/600], Loss: 0.1053Epoch [12/30], Step [500/600], Loss: 0.1114Epoch [12/30], Step [600/600], Loss: 0.0853Epoch [13/30], Step [100/600], Loss: 0.0316Epoch [13/30], Step [200/600], Loss: 0.0837Epoch [13/30], Step [300/600], Loss: 0.1915Epoch [13/30], Step [400/600], Loss: 0.0859Epoch [13/30], Step [500/600], Loss: 0.0947Epoch [13/30], Step [600/600], Loss: 0.0501Epoch [14/30], Step [100/600], Loss: 0.0765Epoch [14/30], Step [200/600], Loss: 0.0526Epoch [14/30], Step [300/600], Loss: 0.0773Epoch [14/30], Step [400/600], Loss: 0.0578Epoch [14/30], Step [500/600], Loss: 0.0845Epoch [14/30], Step [600/600], Loss: 0.0521Epoch [15/30], Step [100/600], Loss: 0.1169Epoch [15/30], Step [200/600], Loss: 0.0391Epoch [15/30], Step [300/600], Loss: 0.0686Epoch [15/30], Step [400/600], Loss: 0.0966Epoch [15/30], Step [500/600], Loss: 0.0331Epoch [15/30], Step [600/600], Loss: 0.0582Epoch [16/30], Step [100/600], Loss: 0.0694Epoch [16/30], Step [200/600], Loss: 0.0841Epoch [16/30], Step [300/600], Loss: 0.1188Epoch [16/30], Step [400/600], Loss: 0.0712Epoch [16/30], Step [500/600], Loss: 0.0655Epoch [16/30], Step [600/600], Loss: 0.0883Epoch [17/30], Step [100/600], Loss: 0.1239Epoch [17/30], Step [200/600], Loss: 0.0856Epoch [17/30], Step [300/600], Loss: 0.0598Epoch [17/30], Step [400/600], Loss: 0.0667Epoch [17/30], Step [500/600], Loss: 0.0577Epoch [17/30], Step [600/600], Loss: 0.0958Epoch [18/30], Step [100/600], Loss: 0.0657Epoch [18/30], Step [200/600], Loss: 0.0419Epoch [18/30], Step [300/600], Loss: 0.0927Epoch [18/30], Step [400/600], Loss: 0.1247Epoch [18/30], Step [500/600], Loss: 0.1200Epoch [18/30], Step [600/600], Loss: 0.1246Epoch [19/30], Step [100/600], Loss: 0.0615Epoch [19/30], Step [200/600], Loss: 0.0164Epoch [19/30], Step [300/600], Loss: 0.0816Epoch [19/30], Step [400/600], Loss: 0.1274Epoch [19/30], Step [500/600], Loss: 0.0988Epoch [19/30], Step [600/600], Loss: 0.0349Epoch [20/30], Step [100/600], Loss: 0.1025Epoch [20/30], Step [200/600], Loss: 0.1068Epoch [20/30], Step [300/600], Loss: 0.0400Epoch [20/30], Step [400/600], Loss: 0.0398Epoch [20/30], Step [500/600], Loss: 0.0671Epoch [20/30], Step [600/600], Loss: 0.0874Epoch [21/30], Step [100/600], Loss: 0.0413Epoch [21/30], Step [200/600], Loss: 0.1078Epoch [21/30], Step [300/600], Loss: 0.0597Epoch [21/30], Step [400/600], Loss: 0.0410Epoch [21/30], Step [500/600], Loss: 0.0644Epoch [21/30], Step [600/600], Loss: 0.1118Epoch [22/30], Step [100/600], Loss: 0.0907Epoch [22/30], Step [200/600], Loss: 0.0542Epoch [22/30], Step [300/600], Loss: 0.2506Epoch [22/30], Step [400/600], Loss: 0.0521Epoch [22/30], Step [500/600], Loss: 0.0435Epoch [22/30], Step [600/600], Loss: 0.0573Epoch [23/30], Step [100/600], Loss: 0.0587Epoch [23/30], Step [200/600], Loss: 0.0452Epoch [23/30], Step [300/600], Loss: 0.0409Epoch [23/30], Step [400/600], Loss: 0.0517Epoch [23/30], Step [500/600], Loss: 0.0404Epoch [23/30], Step [600/600], Loss: 0.0853Epoch [24/30], Step [100/600], Loss: 0.0939Epoch [24/30], Step [200/600], Loss: 0.0728Epoch [24/30], Step [300/600], Loss: 0.0334Epoch [24/30], Step [400/600], Loss: 0.0385Epoch [24/30], Step [500/600], Loss: 0.0339Epoch [24/30], Step [600/600], Loss: 0.1187Epoch [25/30], Step [100/600], Loss: 0.0291Epoch [25/30], Step [200/600], Loss: 0.0209Epoch [25/30], Step [300/600], Loss: 0.0638Epoch [25/30], Step [400/600], Loss: 0.1146Epoch [25/30], Step [500/600], Loss: 0.0283Epoch [25/30], Step [600/600], Loss: 0.0954Epoch [26/30], Step [100/600], Loss: 0.0835Epoch [26/30], Step [200/600], Loss: 0.0453Epoch [26/30], Step [300/600], Loss: 0.0255Epoch [26/30], Step [400/600], Loss: 0.0836Epoch [26/30], Step [500/600], Loss: 0.0456Epoch [26/30], Step [600/600], Loss: 0.0207Epoch [27/30], Step [100/600], Loss: 0.1213Epoch [27/30], Step [200/600], Loss: 0.0258Epoch [27/30], Step [300/600], Loss: 0.0545Epoch [27/30], Step [400/600], Loss: 0.0296Epoch [27/30], Step [500/600], Loss: 0.0507Epoch [27/30], Step [600/600], Loss: 0.0386Epoch [28/30], Step [100/600], Loss: 0.0545Epoch [28/30], Step [200/600], Loss: 0.0468Epoch [28/30], Step [300/600], Loss: 0.2291Epoch [28/30], Step [400/600], Loss: 0.1048Epoch [28/30], Step [500/600], Loss: 0.0407Epoch [28/30], Step [600/600], Loss: 0.0895Epoch [29/30], Step [100/600], Loss: 0.0504Epoch [29/30], Step [200/600], Loss: 0.0448Epoch [29/30], Step [300/600], Loss: 0.0254Epoch [29/30], Step [400/600], Loss: 0.0468Epoch [29/30], Step [500/600], Loss: 0.0783Epoch [29/30], Step [600/600], Loss: 0.0542Epoch [30/30], Step [100/600], Loss: 0.0531Epoch [30/30], Step [200/600], Loss: 0.0461Epoch [30/30], Step [300/600], Loss: 0.0339Epoch [30/30], Step [400/600], Loss: 0.0592Epoch [30/30], Step [500/600], Loss: 0.0287Epoch [30/30], Step [600/600], Loss: 0.0403</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#测试模型</span></span><br><span class="line">model.eval()</span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    correct=<span class="number">0</span></span><br><span class="line">    total=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> images,labels <span class="keyword">in</span> test_dataloader:</span><br><span class="line">        images=images.to(device)</span><br><span class="line">        labels=labels.to(device)</span><br><span class="line">        outputs=model(images)</span><br><span class="line">        _,predicted=torch.max(outputs.data,<span class="number">1</span>)</span><br><span class="line">        total+=labels.size(<span class="number">0</span>)</span><br><span class="line">        correct+=(predicted==labels).sum().item()</span><br><span class="line">        </span><br><span class="line">    print(<span class="string">'Test Accuracy of the model on the 10000 test images:&#123;&#125;%'</span>.format(<span class="number">100</span>*correct/total))</span><br><span class="line"></span><br><span class="line"><span class="comment">#保存模型的权重</span></span><br><span class="line">torch.save(model.state_dict(),<span class="string">'cnn.ckpt'</span>)</span><br></pre></td></tr></table></figure><pre><code>Test Accuracy of the model on the 10000 test images:98.37%</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;卷积神经网络&quot;&gt;&lt;a href=&quot;#卷积神经网络&quot; class=&quot;headerlink&quot; title=&quot;卷积神经网络&quot;&gt;&lt;/a&gt;卷积神经网络&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;MNIST举例&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="PyTorch" scheme="https://cblog.club/categories/PyTorch/"/>
    
    
      <category term="PyTorch" scheme="https://cblog.club/tags/PyTorch/"/>
    
  </entry>
  
  <entry>
    <title>PyTorch-Day5</title>
    <link href="https://cblog.club/ck3hez7az003qdwg497qu5zbv.html"/>
    <id>https://cblog.club/ck3hez7az003qdwg497qu5zbv.html</id>
    <published>2019-11-23T13:41:39.000Z</published>
    <updated>2019-11-23T13:52:17.369Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前馈神经网络"><a href="#前馈神经网络" class="headerlink" title="前馈神经网络"></a>前馈神经网络</h3><ul><li>这里仍然使用MNIST数据集</li></ul><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设备的配置（这里使用GPU来跑训练）</span></span><br><span class="line">device=torch.device(<span class="string">'cuda'</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">'cpu'</span>)</span><br><span class="line">print(device)</span><br></pre></td></tr></table></figure><pre><code>cuda</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设定超参数</span></span><br><span class="line">input_size=<span class="number">784</span></span><br><span class="line">hidden_size=<span class="number">500</span></span><br><span class="line">num_classes=<span class="number">10</span></span><br><span class="line">num_epochs=<span class="number">30</span></span><br><span class="line">batch_size=<span class="number">100</span></span><br><span class="line">learning_rate=<span class="number">0.001</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#加载MNIST数据集</span></span><br><span class="line">train_dataset=torchvision.datasets.MNIST(root=<span class="string">'./data'</span>,train=<span class="literal">True</span>,download=<span class="literal">True</span>,transform=transforms.ToTensor())</span><br><span class="line"></span><br><span class="line">test_dataset=torchvision.datasets.MNIST(root=<span class="string">'./data'</span>,train=<span class="literal">False</span>,transform=transforms.ToTensor())</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义数据加载器（数据输入流水线）</span></span><br><span class="line">train_dataloader=torch.utils.data.DataLoader(dataset=train_dataset,batch_size=batch_size,shuffle=<span class="literal">True</span>)</span><br><span class="line">test_dataloader=torch.utils.data.DataLoader(dataset=test_dataset,batch_size=batch_size,shuffle=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一个隐含层的全连接神经网络</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NeuralNet</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,input_size,hidden_size,num_classes)</span>:</span></span><br><span class="line">        super(NeuralNet,self).__init__()</span><br><span class="line">        self.fc1=nn.Linear(input_size,hidden_size)</span><br><span class="line">        self.relu=nn.ReLU()</span><br><span class="line">        self.fc2=nn.Linear(hidden_size,num_classes)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        out=self.fc1(x)</span><br><span class="line">        out=self.relu(out)</span><br><span class="line">        out=self.fc2(out)</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">model=NeuralNet(input_size,hidden_size,num_classes).to(device)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义损失函数和优化器</span></span><br><span class="line">criterion=nn.CrossEntropyLoss()</span><br><span class="line">optimizer=torch.optim.SGD(model.parameters(),lr=learning_rate)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#训练模型</span></span><br><span class="line">total_step=len(train_dataloader)</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(num_epochs):</span><br><span class="line">    <span class="keyword">for</span> i,(images,labels) <span class="keyword">in</span> enumerate(train_dataloader):</span><br><span class="line">        <span class="comment">#将tensor张量移动到GPU上</span></span><br><span class="line">        images=images.reshape(<span class="number">-1</span>,<span class="number">28</span>*<span class="number">28</span>).to(device)</span><br><span class="line">        labels=labels.to(device)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#前向传播</span></span><br><span class="line">        outputs=model(images)</span><br><span class="line">        loss=criterion(outputs,labels)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#梯度置0+反向传播+更新权重</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i+<span class="number">1</span>)%<span class="number">100</span>==<span class="number">0</span>:</span><br><span class="line">            print(<span class="string">'Epoch [&#123;&#125;/&#123;&#125;], Step [&#123;&#125;/&#123;&#125;], Loss: &#123;:.4f&#125;'</span> .format(epoch+<span class="number">1</span>, num_epochs, i+<span class="number">1</span>, total_step, loss.item()))</span><br></pre></td></tr></table></figure><pre><code>Epoch [1/30], Step [100/600], Loss: 2.2577Epoch [1/30], Step [200/600], Loss: 2.2602Epoch [1/30], Step [300/600], Loss: 2.2123Epoch [1/30], Step [400/600], Loss: 2.2026Epoch [1/30], Step [500/600], Loss: 2.1547Epoch [1/30], Step [600/600], Loss: 2.1598Epoch [2/30], Step [100/600], Loss: 2.0920Epoch [2/30], Step [200/600], Loss: 2.0759Epoch [2/30], Step [300/600], Loss: 2.0557Epoch [2/30], Step [400/600], Loss: 2.0411Epoch [2/30], Step [500/600], Loss: 1.9963Epoch [2/30], Step [600/600], Loss: 1.9562Epoch [3/30], Step [100/600], Loss: 1.8933Epoch [3/30], Step [200/600], Loss: 1.8954Epoch [3/30], Step [300/600], Loss: 1.8854Epoch [3/30], Step [400/600], Loss: 1.9073Epoch [3/30], Step [500/600], Loss: 1.8073Epoch [3/30], Step [600/600], Loss: 1.7214Epoch [4/30], Step [100/600], Loss: 1.7209Epoch [4/30], Step [200/600], Loss: 1.6359Epoch [4/30], Step [300/600], Loss: 1.6842Epoch [4/30], Step [400/600], Loss: 1.6216Epoch [4/30], Step [500/600], Loss: 1.6705Epoch [4/30], Step [600/600], Loss: 1.5234Epoch [5/30], Step [100/600], Loss: 1.4869Epoch [5/30], Step [200/600], Loss: 1.4968Epoch [5/30], Step [300/600], Loss: 1.4577Epoch [5/30], Step [400/600], Loss: 1.5792Epoch [5/30], Step [500/600], Loss: 1.4062Epoch [5/30], Step [600/600], Loss: 1.3446Epoch [6/30], Step [100/600], Loss: 1.3835Epoch [6/30], Step [200/600], Loss: 1.2209Epoch [6/30], Step [300/600], Loss: 1.3533Epoch [6/30], Step [400/600], Loss: 1.2524Epoch [6/30], Step [500/600], Loss: 1.1529Epoch [6/30], Step [600/600], Loss: 1.1282Epoch [7/30], Step [100/600], Loss: 1.1611Epoch [7/30], Step [200/600], Loss: 1.1645Epoch [7/30], Step [300/600], Loss: 1.0757Epoch [7/30], Step [400/600], Loss: 1.1130Epoch [7/30], Step [500/600], Loss: 1.1147Epoch [7/30], Step [600/600], Loss: 0.9933Epoch [8/30], Step [100/600], Loss: 0.9965Epoch [8/30], Step [200/600], Loss: 1.0421Epoch [8/30], Step [300/600], Loss: 0.9947Epoch [8/30], Step [400/600], Loss: 0.9643Epoch [8/30], Step [500/600], Loss: 0.8699Epoch [8/30], Step [600/600], Loss: 0.9051Epoch [9/30], Step [100/600], Loss: 0.9915Epoch [9/30], Step [200/600], Loss: 0.8200Epoch [9/30], Step [300/600], Loss: 0.8870Epoch [9/30], Step [400/600], Loss: 0.7617Epoch [9/30], Step [500/600], Loss: 0.8657Epoch [9/30], Step [600/600], Loss: 0.8298Epoch [10/30], Step [100/600], Loss: 0.8165Epoch [10/30], Step [200/600], Loss: 0.8207Epoch [10/30], Step [300/600], Loss: 0.8202Epoch [10/30], Step [400/600], Loss: 0.8262Epoch [10/30], Step [500/600], Loss: 0.8131Epoch [10/30], Step [600/600], Loss: 0.8367Epoch [11/30], Step [100/600], Loss: 0.8376Epoch [11/30], Step [200/600], Loss: 0.8952Epoch [11/30], Step [300/600], Loss: 0.8049Epoch [11/30], Step [400/600], Loss: 0.8018Epoch [11/30], Step [500/600], Loss: 0.6761Epoch [11/30], Step [600/600], Loss: 0.7581Epoch [12/30], Step [100/600], Loss: 0.6733Epoch [12/30], Step [200/600], Loss: 0.7217Epoch [12/30], Step [300/600], Loss: 0.7343Epoch [12/30], Step [400/600], Loss: 0.6188Epoch [12/30], Step [500/600], Loss: 0.6395Epoch [12/30], Step [600/600], Loss: 0.6714Epoch [13/30], Step [100/600], Loss: 0.7165Epoch [13/30], Step [200/600], Loss: 0.6684Epoch [13/30], Step [300/600], Loss: 0.6127Epoch [13/30], Step [400/600], Loss: 0.6626Epoch [13/30], Step [500/600], Loss: 0.6130Epoch [13/30], Step [600/600], Loss: 0.6483Epoch [14/30], Step [100/600], Loss: 0.5773Epoch [14/30], Step [200/600], Loss: 0.6234Epoch [14/30], Step [300/600], Loss: 0.5617Epoch [14/30], Step [400/600], Loss: 0.6304Epoch [14/30], Step [500/600], Loss: 0.5647Epoch [14/30], Step [600/600], Loss: 0.6992Epoch [15/30], Step [100/600], Loss: 0.7693Epoch [15/30], Step [200/600], Loss: 0.5023Epoch [15/30], Step [300/600], Loss: 0.6256Epoch [15/30], Step [400/600], Loss: 0.5553Epoch [15/30], Step [500/600], Loss: 0.5332Epoch [15/30], Step [600/600], Loss: 0.6705Epoch [16/30], Step [100/600], Loss: 0.5651Epoch [16/30], Step [200/600], Loss: 0.6031Epoch [16/30], Step [300/600], Loss: 0.6298Epoch [16/30], Step [400/600], Loss: 0.6218Epoch [16/30], Step [500/600], Loss: 0.5065Epoch [16/30], Step [600/600], Loss: 0.5554Epoch [17/30], Step [100/600], Loss: 0.5246Epoch [17/30], Step [200/600], Loss: 0.6190Epoch [17/30], Step [300/600], Loss: 0.5547Epoch [17/30], Step [400/600], Loss: 0.5002Epoch [17/30], Step [500/600], Loss: 0.6297Epoch [17/30], Step [600/600], Loss: 0.6091Epoch [18/30], Step [100/600], Loss: 0.5265Epoch [18/30], Step [200/600], Loss: 0.4593Epoch [18/30], Step [300/600], Loss: 0.5204Epoch [18/30], Step [400/600], Loss: 0.5156Epoch [18/30], Step [500/600], Loss: 0.5276Epoch [18/30], Step [600/600], Loss: 0.5380Epoch [19/30], Step [100/600], Loss: 0.4246Epoch [19/30], Step [200/600], Loss: 0.4761Epoch [19/30], Step [300/600], Loss: 0.5177Epoch [19/30], Step [400/600], Loss: 0.5698Epoch [19/30], Step [500/600], Loss: 0.5143Epoch [19/30], Step [600/600], Loss: 0.4552Epoch [20/30], Step [100/600], Loss: 0.4989Epoch [20/30], Step [200/600], Loss: 0.4384Epoch [20/30], Step [300/600], Loss: 0.5648Epoch [20/30], Step [400/600], Loss: 0.4323Epoch [20/30], Step [500/600], Loss: 0.4153Epoch [20/30], Step [600/600], Loss: 0.5401Epoch [21/30], Step [100/600], Loss: 0.4298Epoch [21/30], Step [200/600], Loss: 0.4795Epoch [21/30], Step [300/600], Loss: 0.4865Epoch [21/30], Step [400/600], Loss: 0.6770Epoch [21/30], Step [500/600], Loss: 0.4689Epoch [21/30], Step [600/600], Loss: 0.5034Epoch [22/30], Step [100/600], Loss: 0.4461Epoch [22/30], Step [200/600], Loss: 0.3873Epoch [22/30], Step [300/600], Loss: 0.4634Epoch [22/30], Step [400/600], Loss: 0.4536Epoch [22/30], Step [500/600], Loss: 0.5801Epoch [22/30], Step [600/600], Loss: 0.3840Epoch [23/30], Step [100/600], Loss: 0.4354Epoch [23/30], Step [200/600], Loss: 0.3644Epoch [23/30], Step [300/600], Loss: 0.5900Epoch [23/30], Step [400/600], Loss: 0.5235Epoch [23/30], Step [500/600], Loss: 0.4935Epoch [23/30], Step [600/600], Loss: 0.4815Epoch [24/30], Step [100/600], Loss: 0.3946Epoch [24/30], Step [200/600], Loss: 0.5413Epoch [24/30], Step [300/600], Loss: 0.4906Epoch [24/30], Step [400/600], Loss: 0.4895Epoch [24/30], Step [500/600], Loss: 0.5062Epoch [24/30], Step [600/600], Loss: 0.4927Epoch [25/30], Step [100/600], Loss: 0.5096Epoch [25/30], Step [200/600], Loss: 0.5281Epoch [25/30], Step [300/600], Loss: 0.5560Epoch [25/30], Step [400/600], Loss: 0.3325Epoch [25/30], Step [500/600], Loss: 0.5069Epoch [25/30], Step [600/600], Loss: 0.4295Epoch [26/30], Step [100/600], Loss: 0.3942Epoch [26/30], Step [200/600], Loss: 0.5095Epoch [26/30], Step [300/600], Loss: 0.4046Epoch [26/30], Step [400/600], Loss: 0.4315Epoch [26/30], Step [500/600], Loss: 0.4742Epoch [26/30], Step [600/600], Loss: 0.4902Epoch [27/30], Step [100/600], Loss: 0.5214Epoch [27/30], Step [200/600], Loss: 0.5570Epoch [27/30], Step [300/600], Loss: 0.4271Epoch [27/30], Step [400/600], Loss: 0.4110Epoch [27/30], Step [500/600], Loss: 0.3797Epoch [27/30], Step [600/600], Loss: 0.4555Epoch [28/30], Step [100/600], Loss: 0.4667Epoch [28/30], Step [200/600], Loss: 0.4648Epoch [28/30], Step [300/600], Loss: 0.4887Epoch [28/30], Step [400/600], Loss: 0.3500Epoch [28/30], Step [500/600], Loss: 0.4439Epoch [28/30], Step [600/600], Loss: 0.4054Epoch [29/30], Step [100/600], Loss: 0.5129Epoch [29/30], Step [200/600], Loss: 0.4508Epoch [29/30], Step [300/600], Loss: 0.4131Epoch [29/30], Step [400/600], Loss: 0.4463Epoch [29/30], Step [500/600], Loss: 0.5682Epoch [29/30], Step [600/600], Loss: 0.3458Epoch [30/30], Step [100/600], Loss: 0.3850Epoch [30/30], Step [200/600], Loss: 0.4949Epoch [30/30], Step [300/600], Loss: 0.3873Epoch [30/30], Step [400/600], Loss: 0.4957Epoch [30/30], Step [500/600], Loss: 0.3352Epoch [30/30], Step [600/600], Loss: 0.4667</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#测试模型（在测试阶段不需要再计算梯度）</span></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    correct=<span class="number">0</span></span><br><span class="line">    total=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> images,labels <span class="keyword">in</span> test_dataloader:</span><br><span class="line">        images=images.reshape(<span class="number">-1</span>,<span class="number">28</span>*<span class="number">28</span>).to(device)</span><br><span class="line">        labels=labels.to(device)</span><br><span class="line">        outputs=model(images)</span><br><span class="line">        _,predicted=torch.max(outputs.data,<span class="number">1</span>)</span><br><span class="line">        total+=labels.size(<span class="number">0</span>)</span><br><span class="line">        correct+=(predicted==labels).sum().item()</span><br><span class="line">print(<span class="string">'Accuracy of the network on the 10000 test images:&#123;&#125;%'</span>.format(<span class="number">100</span>*correct/total))</span><br><span class="line"></span><br><span class="line"><span class="comment">#保存模型</span></span><br><span class="line">torch.save(model.state_dict(),<span class="string">'NeuralNet.ckpt'</span>)</span><br></pre></td></tr></table></figure><pre><code>Accuracy of the network on the 10000 test images:89.47%</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前馈神经网络&quot;&gt;&lt;a href=&quot;#前馈神经网络&quot; class=&quot;headerlink&quot; title=&quot;前馈神经网络&quot;&gt;&lt;/a&gt;前馈神经网络&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;这里仍然使用MNIST数据集&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="PyTorch" scheme="https://cblog.club/categories/PyTorch/"/>
    
    
      <category term="PyTorch" scheme="https://cblog.club/tags/PyTorch/"/>
    
  </entry>
  
  <entry>
    <title>安装anaconda虚拟环境、pytorch和jupyter notebook（远程访问）</title>
    <link href="https://cblog.club/ck3hez7dx004ydwg4e7audix4.html"/>
    <id>https://cblog.club/ck3hez7dx004ydwg4e7audix4.html</id>
    <published>2019-11-23T12:45:04.000Z</published>
    <updated>2019-11-23T13:38:32.894Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习Pytorch，然后实验室有一台双卡的服务器，显卡是特斯拉（貌似很nb），所以就想在服务器上跑代码，炼丹。今天花了点时间配置了一下环境，主要安装了anaconda和pytorch(gpu版本)，为此记录一下= =。</p><a id="more"></a><h3 id="Anaconda简介"><a href="#Anaconda简介" class="headerlink" title="Anaconda简介"></a>Anaconda简介</h3><p>anaconda 是一个python的发行版，包括了python和很多常见的软件库, 和一个包管理器conda。<br>常见的科学计算类的库都包含在里面了，使得安装比常规python安装要容易。主要是！装了anaconda就不需要单独装python了。<br>因为Anaconda就是用来管理我们不同版本的python环境的。</p><p>对整个python环境, 最关键的是需要有一个解释器, 和一个包集合，所有的第三方包都放在site-packages文件夹里面。<br>比如说一个爬虫脚本用到了第三方的requests包,而另一台计算机是刚刚是装好原始python的, 也就是说根本没有任何第三方包,<br>那么这个爬虫脚本是无法在另一台机器上运行的。（因为需要requests包的支持。）</p><h3 id="Anaconda安装"><a href="#Anaconda安装" class="headerlink" title="Anaconda安装"></a>Anaconda安装</h3><p>Anaconda和Python版本是对应的，所以需要选择安装对应Python2.7版本的还是Python3.7版本或其他版本的，根据自己的需要下载合适的安装包。</p><p>下载链接：<a href="https://www.anaconda.com/download/#linux" target="_blank" rel="noopener">https://www.anaconda.com/download/#linux</a></p><p> 点击下面的64-Bit (x86) Installer ,下载64位的版本，下载完成是：Anaconda3-日期-Linux-x86_64.sh，这是一个shell脚本文件。 </p><h4 id="安装步骤："><a href="#安装步骤：" class="headerlink" title="安装步骤："></a>安装步骤：</h4><ul><li><p>进入安装包Anaconda3-日期-Linux-x86_64.sh所在目录，打开终端</p></li><li><p>执行：bash Anaconda3-日期-Linux-x86_64.sh，然后一路回车，知道出现提示，输入yes</p></li><li><p>回车选择默认路径，然后开始安装，最后会询问你是否添加到环境变量，输入yes</p></li><li><p>这样就安装OK了，不需要重启</p></li></ul><h4 id="检查是否成功："><a href="#检查是否成功：" class="headerlink" title="检查是否成功："></a>检查是否成功：</h4><ul><li>打开新终端，输入python，里边含有Anaconda信息即可</li><li>或者输入<code>conda --version</code>，如果有版本号，也是OK的</li></ul><h3 id="管理虚拟环境"><a href="#管理虚拟环境" class="headerlink" title="管理虚拟环境"></a>管理虚拟环境</h3><p> 安装了anaconda以后，我们可以用它来创建我们一个个独立的python环境 </p><h4 id="创建独立的虚拟环境"><a href="#创建独立的虚拟环境" class="headerlink" title="创建独立的虚拟环境"></a>创建独立的虚拟环境</h4><p><code>conda create -n pytorch_gpu python=3.7</code></p><h4 id="source-activate命令进入到虚拟环境"><a href="#source-activate命令进入到虚拟环境" class="headerlink" title="source activate命令进入到虚拟环境"></a>source activate命令进入到虚拟环境</h4><p><code>source activate pytorch_gpu</code></p><h4 id="activate命令进入到虚拟环境"><a href="#activate命令进入到虚拟环境" class="headerlink" title="activate命令进入到虚拟环境"></a>activate命令进入到虚拟环境</h4><p><code>source activate pytorch_gpu</code></p><h4 id="显示当前虚拟环境所安装的包"><a href="#显示当前虚拟环境所安装的包" class="headerlink" title="显示当前虚拟环境所安装的包"></a>显示当前虚拟环境所安装的包</h4><p><code>conda list</code></p><h4 id="安装需要的包"><a href="#安装需要的包" class="headerlink" title="安装需要的包"></a>安装需要的包</h4><p><code>conda install 包的名字</code></p><h3 id="安装pytorch-GPU版本"><a href="#安装pytorch-GPU版本" class="headerlink" title="安装pytorch(GPU版本)"></a>安装pytorch(GPU版本)</h3><p>准备工作（ 用conda安装Pytorch过程中会连接失败，这是因为Anaconda.org的服务器在国外，需要切换到国内镜像源 ）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ </span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ </span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/</span><br></pre></td></tr></table></figure><p>官网一步到位： <a href="https://pytorch.org/get-started/locally/" target="_blank" rel="noopener">https://pytorch.org/get-started/locally/</a> </p><p>选择适合自己的版本即可，我看了Ubuntu的显卡信息<code>nvidia-smi</code>,发现cuda是10.0版本的，所以cudatoolkit改成10.0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pytorch torchvision cudatoolkit=10.0 -c pytorch</span><br></pre></td></tr></table></figure><p>最后安装完成，打开python，<code>import torch</code>不出错即可 </p><p>查看GPU是否可用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">device=torch.device(<span class="string">'cuda'</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">'cpu'</span>)</span><br><span class="line">print(device)</span><br></pre></td></tr></table></figure><h3 id="Jupyter-notebook简介"><a href="#Jupyter-notebook简介" class="headerlink" title="Jupyter notebook简介"></a>Jupyter notebook简介</h3><blockquote><p>Jupyter Notebook是基于网页的用于交互计算的应用程序。其可被应用于全过程计算：开发、文档编写、运行代码和展示结果。——<a href="https://link.jianshu.com?t=https%3A%2F%2Fjupyter-notebook.readthedocs.io%2Fen%2Fstable%2Fnotebook.html" target="_blank" rel="noopener">Jupyter Notebook官方介绍</a></p></blockquote><p>简而言之，Jupyter Notebook是以网页的形式打开，可以在网页页面中<strong>直接</strong>编写代码和运行代码，代码的运行结果也会直接在代码块下显示。如在编程过程中需要编写说明文档，可在同一个页面中直接编写，便于作及时的说明和解释。</p><h3 id="安装Jupyter-Notebook"><a href="#安装Jupyter-Notebook" class="headerlink" title="安装Jupyter Notebook"></a>安装Jupyter Notebook</h3><p>之前我已经安装过了anaconda，所以直接使用<code>conda install jupyter</code>即可</p><p>安装完成后，因为我是远程连接服务器，所以就要设置jupyter notebook远程访问，这样写代码比较方便</p><h3 id="Jupyter-nootbook远程访问设置"><a href="#Jupyter-nootbook远程访问设置" class="headerlink" title="Jupyter nootbook远程访问设置"></a>Jupyter nootbook远程访问设置</h3><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>首先，我们需要修改一个名为“upyter_notebook_config.py”的文件，从其命名规则可以看出，这是有关Notebook的配置文件。</p><p>其实，在本质上，它是一个由Python编写的脚本文档。</p><p>通常，这个文档位于我们的家目录（home directory）之下，不同的操作系统，它所处的位置稍有不同，大致如下：</p><p><code>Linux: /home/USERNAME/.jupyter/jupyter_notebook_config.py</code></p><p>上面的「USERNAME」就是前面我们提到的诸如‘jpnb’这样的用户名，我们根据实际情况替换为实际路径即可。</p><p>如果你在上述路径下没有找到这个配置文件，那么就需要在终端运行如下命令：</p><p><code>jupyter notebook --generate-config</code>即可， 这个命令的功能，就是创建Jupyter文件夹和配置文件「jupyter_notebook_config.py」。 </p><h4 id="设置Jupyter远程访问密码"><a href="#设置Jupyter远程访问密码" class="headerlink" title="设置Jupyter远程访问密码"></a>设置Jupyter远程访问密码</h4><h4 id="设置访问密码"><a href="#设置访问密码" class="headerlink" title="设置访问密码"></a>设置访问密码</h4><p>打开终端输入：<code>jupyter notebook password</code></p><h4 id="下面我们还需要手动生成一个hash密码"><a href="#下面我们还需要手动生成一个hash密码" class="headerlink" title="下面我们还需要手动生成一个hash密码,"></a>下面我们还需要手动生成一个hash密码,</h4><p>如果你没有生成这么一个hash密码的话，那么每次通过浏览器远程访问Jupyter时，你都需要输入一次密码，这很繁琐！  但如果我们启用了这个hash密码，只需要首次远程访问Jupyter文档时，输入一次密码，在下次访问时，这个hash密码就好比一个钥匙（token），替我们打开密码之门，也就是免密码登录。 </p><p> 为了生成这个hash密码，我们需要在终端输入“ipython”（全部小写）命令，以进入IPython的交互shell。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">from</span> notebook.auth <span class="keyword">import</span> passwd</span><br><span class="line">In [<span class="number">2</span>]: passwd()</span><br><span class="line">Enter password:</span><br><span class="line">Verify password:</span><br><span class="line">Out[<span class="number">2</span>]: <span class="string">'sha1:67c9e60bb8b6:9ffede0825894254b2e042ea597d771089e11aed'</span></span><br></pre></td></tr></table></figure><p>然后exit()退出IPython</p><h4 id="将hash密码添加到配置文件中"><a href="#将hash密码添加到配置文件中" class="headerlink" title="将hash密码添加到配置文件中"></a>将hash密码添加到配置文件中</h4><p> 下面，我们把前面生成的hash密码，添加到前面生成的配置文件：jupyter_notebook_config.py， </p><p>找到c.NotebookApp.password 所在行，将如下代码：</p><p><code>#c.NotebookApp.password = &#39; &#39;</code>将#注释去掉，然后改成<code>c.NotebookApp.password = u&#39;sha1:67c9e60bb8b6:9ffede0825894254b2e042ea597d771089e11aed&#39;</code></p><p> 这里，特别需要注意的是，hash密码字符串前面的那个u不可省略。 </p><h4 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h4><p>将默认值False修改为True，表示允许外部访问，这个设置和下面IP设置，双重保障外部用户访问的可达性：</p><blockquote><p>c.NotebookApp.allow_remote_access = True</p></blockquote><p>等号右边的‘localhost’（仅仅运行本地访问），修改为‘*’，表示允许所有IP皆可访问</p><blockquote><p>c.NotebookApp.ip=’*’</p></blockquote><p>禁止自动打开浏览器</p><blockquote><p>c.NotebookApp.open_browser = False</p></blockquote><p>设置一个固定的notebook服务会监听的IP端口（这里设置为9999），这个值可以任意，只要保证不和其他已经启用的端口号冲突即可。</p><blockquote><p>c.NotebookApp.port = 9999</p></blockquote><p>做完上述配置之后，保存文件并退出。</p><p>但此时修改的配置并没有生效，我们还需要在终端输入“jupyter notebook”命令，这样确保Jupyter重新加载jupyter_notebook_config.py，进而使得新配置起效。</p><p>最后打开浏览器，输入相应IP:端口号即可。</p><h3 id="修改jupyter-notebook的默认工作路径"><a href="#修改jupyter-notebook的默认工作路径" class="headerlink" title="修改jupyter notebook的默认工作路径"></a>修改jupyter notebook的默认工作路径</h3><p>找到刚才的 <strong>jupyter_notebook_config.py</strong> 配置文件，然后定位到 <code>#c.NotebookApp.notebook_dir = &#39;&#39;</code></p><p>然后将其改成你的工作目录即可</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在学习Pytorch，然后实验室有一台双卡的服务器，显卡是特斯拉（貌似很nb），所以就想在服务器上跑代码，炼丹。今天花了点时间配置了一下环境，主要安装了anaconda和pytorch(gpu版本)，为此记录一下= =。&lt;/p&gt;
    
    </summary>
    
    
      <category term="环境配置" scheme="https://cblog.club/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="环境配置" scheme="https://cblog.club/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>139单词拆分</title>
    <link href="https://cblog.club/ck3hez7840008dwg455bi5l89.html"/>
    <id>https://cblog.club/ck3hez7840008dwg455bi5l89.html</id>
    <published>2019-11-23T03:44:50.000Z</published>
    <updated>2019-11-23T04:01:13.433Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p> 给定一个<strong>非空</strong>字符串 <em>s</em> 和一个包含<strong>非空</strong>单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 </p><p><strong>说明：</strong></p><ul><li>拆分时可以重复使用字典中的单词。</li><li>你可以假设字典中没有重复的单词。</li></ul><a id="more"></a><blockquote><p><strong>示例 1：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = <span class="string">"leetcode"</span>, wordDict = [<span class="string">"leet"</span>, <span class="string">"code"</span>]</span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 返回 <span class="literal">true</span> 因为 <span class="string">"leetcode"</span> 可以被拆分成 <span class="string">"leet code"</span>。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = <span class="string">"applepenapple"</span>, wordDict = [<span class="string">"apple"</span>, <span class="string">"pen"</span>]</span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 返回 <span class="literal">true</span> 因为 <span class="string">"applepenapple"</span> 可以被拆分成 <span class="string">"apple pen apple"</span>。</span><br><span class="line">     注意你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = <span class="string">"catsandog"</span>, wordDict = [<span class="string">"cats"</span>, <span class="string">"dog"</span>, <span class="string">"sand"</span>, <span class="string">"and"</span>, <span class="string">"cat"</span>]</span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：本题最开始的思路是，遍历字符串，str初试为空，一直加，加到能在字典数组里查到有一个字符串和其相等，然后str再为空，最后能遍历完数组，在最后一位结束也能在字典中查到即可，但是对于aaaaaaa-“aaaa”-“aaa”-，这样的测试数据就没法通过了-，比如aaa，aaa，只剩下一个a，返回false（字典中没有一个a），但是他其实是可以的，先aaaa，再aaa-，所以这种方法宣告失败！后来借鉴了一下动态规划的思想，比较巧妙，dp-i-表示i之前都能够分割完成，相当于将子结构分为两部分，从j的位置开始到i，如果dp-j-1并且-j-i-1-这一部分又能在字典中找到，就意味着i之前这个子结构就是可分的，那么一直遍历到最后，如果字符串长度最后结果还是1的话，代表整个字符串都能够成功分割！"><a href="#解题思路：本题最开始的思路是，遍历字符串，str初试为空，一直加，加到能在字典数组里查到有一个字符串和其相等，然后str再为空，最后能遍历完数组，在最后一位结束也能在字典中查到即可，但是对于aaaaaaa-“aaaa”-“aaa”-，这样的测试数据就没法通过了-，比如aaa，aaa，只剩下一个a，返回false（字典中没有一个a），但是他其实是可以的，先aaaa，再aaa-，所以这种方法宣告失败！后来借鉴了一下动态规划的思想，比较巧妙，dp-i-表示i之前都能够分割完成，相当于将子结构分为两部分，从j的位置开始到i，如果dp-j-1并且-j-i-1-这一部分又能在字典中找到，就意味着i之前这个子结构就是可分的，那么一直遍历到最后，如果字符串长度最后结果还是1的话，代表整个字符串都能够成功分割！" class="headerlink" title="解题思路：本题最开始的思路是，遍历字符串，str初试为空，一直加，加到能在字典数组里查到有一个字符串和其相等，然后str再为空，最后能遍历完数组，在最后一位结束也能在字典中查到即可，但是对于aaaaaaa     “aaaa”   “aaa”   ，这样的测试数据就没法通过了= =，比如aaa，aaa，只剩下一个a，返回false（字典中没有一个a），但是他其实是可以的，先aaaa，再aaa~，所以这种方法宣告失败！后来借鉴了一下动态规划的思想，比较巧妙，dp[i]表示i之前都能够分割完成，相当于将子结构分为两部分，从j的位置开始到i，如果dp[j]=1并且[j,i-1]这一部分又能在字典中找到，就意味着i之前这个子结构就是可分的，那么一直遍历到最后，如果字符串长度最后结果还是1的话，代表整个字符串都能够成功分割！"></a>解题思路：本题最开始的思路是，遍历字符串，str初试为空，一直加，加到能在字典数组里查到有一个字符串和其相等，然后str再为空，最后能遍历完数组，在最后一位结束也能在字典中查到即可，但是对于aaaaaaa     “aaaa”   “aaa”   ，这样的测试数据就没法通过了= =，比如aaa，aaa，只剩下一个a，返回false（字典中没有一个a），但是他其实是可以的，先aaaa，再aaa~，所以这种方法宣告失败！后来借鉴了一下动态规划的思想，比较巧妙，dp[i]表示i之前都能够分割完成，相当于将子结构分为两部分，从j的位置开始到i，如果dp[j]=1并且[j,i-1]这一部分又能在字典中找到，就意味着i之前这个子结构就是可分的，那么一直遍历到最后，如果字符串长度最后结果还是1的话，代表整个字符串都能够成功分割！</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size=s.size()+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(size);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">string</span> word : wordDict)&#123;</span><br><span class="line">                <span class="keyword">int</span> wsize=word.size();</span><br><span class="line">                <span class="keyword">if</span>(i&gt;=wsize)&#123;</span><br><span class="line">                    <span class="keyword">int</span> is_exist=s.compare(i-wsize,wsize,word);</span><br><span class="line">                    <span class="keyword">if</span>(is_exist==<span class="number">0</span>&amp;&amp;dp[i-wsize]==<span class="number">1</span>)dp[i]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[size<span class="number">-1</span>]==<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt; 给定一个&lt;strong&gt;非空&lt;/strong&gt;字符串 &lt;em&gt;s&lt;/em&gt; 和一个包含&lt;strong&gt;非空&lt;/strong&gt;单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拆分时可以重复使用字典中的单词。&lt;/li&gt;
&lt;li&gt;你可以假设字典中没有重复的单词。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/categories/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
      <category term="动态规划" scheme="https://cblog.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>DFS深优先度搜索</title>
    <link href="https://cblog.club/ck3hez7ai002zdwg4cthx5z60.html"/>
    <id>https://cblog.club/ck3hez7ai002zdwg4cthx5z60.html</id>
    <published>2019-11-22T13:39:02.000Z</published>
    <updated>2019-11-22T14:33:28.128Z</updated>
    
    <content type="html"><![CDATA[<p> 讲搜索当然不能撇开图，搜索思想在图问题中能以最直观的方式展现。 </p><p><strong>深度优先搜索的步骤分为 1.递归下去 2.回溯上来。顾名思义，深度优先，则是以深度为准则，先一条路走到底，直到达到目标。这里称之为递归下去。</strong></p><p><strong>如果既没有达到目标又无路可走了，那么则退回到上一步的状态，走其他路。这便是回溯上来。</strong></p><p>下面结合具体例子来理解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 讲搜索当然不能撇开图，搜索思想在图问题中能以最直观的方式展现。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;深度优先搜索的步骤分为 1.递归下去 2.回溯上来。顾名思义，深度优先，则是以深度为准则，先一条路走到底，直到达到目标。这里称之为递归下去。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;
      
    
    </summary>
    
    
      <category term="算法" scheme="https://cblog.club/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://cblog.club/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>

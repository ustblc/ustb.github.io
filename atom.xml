<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>lemon</title>
  
  <subtitle>一直在路上</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cblog.club/"/>
  <updated>2019-11-17T08:51:48.567Z</updated>
  <id>https://cblog.club/</id>
  
  <author>
    <name>lemon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>理解LSTM</title>
    <link href="https://cblog.club/ck32ty1b6000yxwg48jonfet7.html"/>
    <id>https://cblog.club/ck32ty1b6000yxwg48jonfet7.html</id>
    <published>2019-11-17T01:38:27.000Z</published>
    <updated>2019-11-17T08:51:48.567Z</updated>
    
    <content type="html"><![CDATA[<p>SimpleRNN并不是keras中唯一的循环层，另外还有两个：LSTM和GRU。SimpleRNN最大的问题就是：在t时刻，理论上讲它能记住许多时间步之前见过的信息，但是实际上他是不可能学到这种长期依赖的。其原因就在于梯度消失问题，这一问题有点类似于在层数比较多的非循环网络（前馈网络）中观察到的效应：随着层数的增加，网络最终无法训练（具体原因没有深究，以后一定要看看论文），而LSTM和GRU就是为了解决SimpleRNN梯度消失这个问题设计的。<a id="more"></a></p><h4 id="LSTM-长短期记忆-算法的提出，是研究梯度消失的重要成果，-解决长依赖问题-。"><a href="#LSTM-长短期记忆-算法的提出，是研究梯度消失的重要成果，-解决长依赖问题-。" class="headerlink" title="LSTM(长短期记忆)算法的提出，是研究梯度消失的重要成果， 解决长依赖问题 。"></a>LSTM(长短期记忆)算法的提出，是研究梯度消失的重要成果， 解决长依赖问题 。</h4><p>所有循环神经网络都具有神经网络的重复模块链的形式。 在标准的RNN中，该重复模块将具有非常简单的结构，例如单个tanh层。标准的RNN网络如下图所示：</p><img src="/ck32ty1b6000yxwg48jonfet7/1.png" class=""><p> LSTM也具有这种链式结构，但是它的重复单元不同于标准RNN网络里的单元只有一个网络层，它的内部有四个网络层。LSTMs的结构如下图所示：</p><img src="/ck32ty1b6000yxwg48jonfet7/2.png" class=""><p> 在解释LSTMs的详细结构时先定义一下图中各个符号的含义，符号包括下面几种 </p><img src="/ck32ty1b6000yxwg48jonfet7/3.jpg" class=""><p>图中黄色类似于CNN里的激活函数操作，粉色圆圈表示点操作，单箭头表示数据流向，箭头合并表示向量的合并（concat）操作，箭头分叉表示向量的拷贝操作 </p><h4 id="LSTM核心思想"><a href="#LSTM核心思想" class="headerlink" title="LSTM核心思想"></a>LSTM核心思想</h4><p>LSTM的关键在于细胞的状态(整个绿色的图表示的是一个cell)，和穿过细胞的那条水平线。</p><p>细胞状态类似于传送带。直接在整个链上运行，只有一些少量的线性交互。信息在上面流传保持不变会很容易。</p><img src="/ck32ty1b6000yxwg48jonfet7/4.png" class=""><p>若只有上面的那条水平线是没办法实现添加或者删除信息的。而是通过一种叫做 门（gates） 的结构来实现的。</p><p>门 可以实现选择性地让信息通过，主要是通过一个 sigmoid 的神经层 和一个逐点相乘的操作来实现的。</p><img src="/ck32ty1b6000yxwg48jonfet7/5.png" class=""><p>sigmoid 层输出（是一个向量）的每个元素都是一个在 0 和 1 之间的实数，表示让对应信息通过的权重（或者占比）。比如， 0 表示“不让任何信息通过”， 1 表示“让所有信息通过”。</p><p>LSTM通过三个这样的结构来实现信息的保护和控制。这三个门分别输入门、遗忘门和输出门。</p><h4 id="逐步理解LSTM"><a href="#逐步理解LSTM" class="headerlink" title="逐步理解LSTM"></a>逐步理解LSTM</h4><p>接下来通过三个门来逐步理解LSTM的原理</p><h5 id="遗忘门"><a href="#遗忘门" class="headerlink" title="遗忘门"></a>遗忘门</h5><p>在我们 LSTM 中的第一步是决定我们会从细胞状态中丢弃什么信息。这个决定通过一个称为忘记门层完成。该门会读取 h(t-1)和x(t)， 输出一个在 0到 1之间的数值即每个在细胞状态C(t-1)中的数字， 1 表示“完全保留”，0 表示“完全舍弃” 。</p><p>举个例子，在语言中我们基于已经看到的词来预测下一个词。在这个问题中，细胞状态可能包含当前主语的性别，因此正确的代词可以被选择出来。当我们看到新的主语，我们希望忘记旧的主语。 </p><img src="/ck32ty1b6000yxwg48jonfet7/6.png" class=""><p> 其中h(t-1)表示的是上一个cell的输出，x(t)表示的是当前细胞的输入。σ表示sigmod函数。 </p><h5 id="输入门"><a href="#输入门" class="headerlink" title="输入门"></a>输入门</h5><p>下一步是决定给细胞状态添加哪些新的信息。这一步又分为两个步骤，首先，利用h(t-1)和x(t)通过一个称为输入门的操作来决定更新哪些信息。然后利用h(t-1)和x(t)通过一个tanh层得到新的候选细胞信息~Ct，这些信息可能会被更新到细胞信息中。这两步描述如下图所示：</p><img src="/ck32ty1b6000yxwg48jonfet7/7.png" class=""><p> 下面将更新旧的细胞信息C(t-1)，变为新的细胞信息Ct。更新的规则就是通过忘记门选择忘记旧细胞信息的一部分，通过输入门选择添加候选细胞信息~Ct的一部分得到新的细胞信息Ct。更新操作如下图所示:</p><img src="/ck32ty1b6000yxwg48jonfet7/8.png" class=""><h5 id="输出门"><a href="#输出门" class="headerlink" title="输出门"></a>输出门</h5><p>最终，我们需要确定输出什么值。这个输出将会基于我们的细胞状态，但是也是一个过滤后的版本。首先，我们运行一个 sigmoid 层来确定细胞状态的哪个部分将输出出去。接着，我们把细胞状态通过 tanh 进行处理（得到一个在 -1 到 1 之间的值）并将它和 sigmoid 门的输出相乘，最终我们仅仅会输出我们确定输出的那部分。</p><p> 还是拿语言模型来举例说明，在预测动词形式的时候，我们需要通过输入的主语是单数还是复数来推断输出门输出的预测动词是单数形式还是复数形式。 </p><img src="/ck32ty1b6000yxwg48jonfet7/9.png" class=""><h4 id="LSTM变体"><a href="#LSTM变体" class="headerlink" title="LSTM变体"></a>LSTM变体</h4><p>下面主要讲一下其中比较著名的变种 GRU（Gated Recurrent Unit ），这是由 Cho, et al. (2014) 提出。在 GRU 中，如下图所示，只有两个门：重置门（reset gate）和更新门（update gate）。同时在这个结构中，把细胞状态和隐藏状态进行了合并。最后模型比标准的 LSTM 结构要简单，而且这个结构后来也非常流行。</p><img src="/ck32ty1b6000yxwg48jonfet7/10.png" class=""><p> 其中，<strong>r</strong>表示重置门，<strong>t</strong>表示更新门。重置门决定是否将之前的状态忘记。(作用相当于合并了 LSTM 中的遗忘门和传入门）当<strong>r</strong>趋于0的时候，前一个时刻的状态信息 h(t-1)会被忘掉，隐藏状态^ht 会被重置为当前输入的信息。更新门决定是否要将隐藏状态更新为新的状态 ht(作用相当于 LSTM 中的输出门)</p><p>其中重置门为上图中前面那个门，决定了如何将新的输入信息与前面的记忆相结合。更新门为上图中后面那个门，定义了前面记忆保存到当前时间步的量。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SimpleRNN并不是keras中唯一的循环层，另外还有两个：LSTM和GRU。SimpleRNN最大的问题就是：在t时刻，理论上讲它能记住许多时间步之前见过的信息，但是实际上他是不可能学到这种长期依赖的。其原因就在于梯度消失问题，这一问题有点类似于在层数比较多的非循环网络（前馈网络）中观察到的效应：随着层数的增加，网络最终无法训练（具体原因没有深究，以后一定要看看论文），而LSTM和GRU就是为了解决SimpleRNN梯度消失这个问题设计的。
    
    </summary>
    
    
      <category term="深度学习" scheme="https://cblog.club/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="https://cblog.club/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>3无重复字符的最长子串</title>
    <link href="https://cblog.club/ck32ty18r000fxwg434rcbvdz.html"/>
    <id>https://cblog.club/ck32ty18r000fxwg434rcbvdz.html</id>
    <published>2019-11-16T15:17:37.000Z</published>
    <updated>2019-11-16T15:22:48.290Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><a id="more"></a><blockquote><p><strong>示例 1:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"abcabcbb"</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"abc"</span>，所以其长度为 <span class="number">3</span>。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"bbbbb"</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"b"</span>，所以其长度为 <span class="number">1</span>。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"pwwkew"</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"wke"</span>，所以其长度为 <span class="number">3</span>。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">"pwke"</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：本题一开始的思路就是循环当前元素，（但是没考虑到双循环，慢慢做，才发现需要-，因为我们只能确定以当前为首字母的字串的长度），然后就是使用哈希set，从当前元素向后循环，只要没出现在set中的，就插入到set中，并且使用count计数，如果见到了，就代表有重复，令count和max比较，确定是否更新，count置0，以此类推即可，但是要注意的是如果都没有见到重复元素，也要更新max值（这点忽视了，导致数据点没全部通过-）"><a href="#解题思路：本题一开始的思路就是循环当前元素，（但是没考虑到双循环，慢慢做，才发现需要-，因为我们只能确定以当前为首字母的字串的长度），然后就是使用哈希set，从当前元素向后循环，只要没出现在set中的，就插入到set中，并且使用count计数，如果见到了，就代表有重复，令count和max比较，确定是否更新，count置0，以此类推即可，但是要注意的是如果都没有见到重复元素，也要更新max值（这点忽视了，导致数据点没全部通过-）" class="headerlink" title="解题思路：本题一开始的思路就是循环当前元素，（但是没考虑到双循环，慢慢做，才发现需要= =，因为我们只能确定以当前为首字母的字串的长度），然后就是使用哈希set，从当前元素向后循环，只要没出现在set中的，就插入到set中，并且使用count计数，如果见到了，就代表有重复，令count和max比较，确定是否更新，count置0，以此类推即可，但是要注意的是如果都没有见到重复元素，也要更新max值（这点忽视了，导致数据点没全部通过~）"></a>解题思路：本题一开始的思路就是循环当前元素，（但是没考虑到双循环，慢慢做，才发现需要= =，因为我们只能确定以当前为首字母的字串的长度），然后就是使用哈希set，从当前元素向后循环，只要没出现在set中的，就插入到set中，并且使用count计数，如果见到了，就代表有重复，令count和max比较，确定是否更新，count置0，以此类推即可，但是要注意的是如果都没有见到重复元素，也要更新max值（这点忽视了，导致数据点没全部通过~）</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt;S_set;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=i;j&lt;s.size();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(S_set.count(s[j])==<span class="number">0</span>)count++; </span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(max&lt;count)max=count;</span><br><span class="line">                    count=<span class="number">0</span>;</span><br><span class="line">                    S_set.clear();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                S_set.insert(s[j]);</span><br><span class="line">                <span class="keyword">if</span>(j==s.size()<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(max&lt;count)max=count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的 &lt;strong&gt;最长子串&lt;/strong&gt; 的长度。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>771宝石与石头</title>
    <link href="https://cblog.club/ck32ty19o000pxwg47alld718.html"/>
    <id>https://cblog.club/ck32ty19o000pxwg47alld718.html</id>
    <published>2019-11-16T15:13:32.000Z</published>
    <updated>2019-11-17T01:32:43.727Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定字符串<code>J</code> 代表石头中宝石的类型，和字符串 <code>S</code>代表你拥有的石头。 <code>S</code> 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。</p><p><code>J</code> 中的字母不重复，<code>J</code> 和 <code>S</code>中的所有字符都是字母。字母区分大小写，因此<code>&quot;a&quot;</code>和<code>&quot;A&quot;</code>是不同类型的石头。</p><a id="more"></a><blockquote><p><strong>示例 1:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: J = <span class="string">"aA"</span>, S = <span class="string">"aAAbbbb"</span></span><br><span class="line">输出: <span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: J = <span class="string">"z"</span>, S = <span class="string">"ZZ"</span></span><br><span class="line">输出: <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><code>S</code> 和 <code>J</code> 最多含有50个字母。</li><li><code>J</code> 中的字符不重复。</li></ul></blockquote><h6 id="解题思路：本题是最基础的哈希集合的题目，一眼就可以看出来要使用哈希set，将J的插入到set中，然后循环S，再判断当前元素是否在J中即可，比较水。"><a href="#解题思路：本题是最基础的哈希集合的题目，一眼就可以看出来要使用哈希set，将J的插入到set中，然后循环S，再判断当前元素是否在J中即可，比较水。" class="headerlink" title="解题思路：本题是最基础的哈希集合的题目，一眼就可以看出来要使用哈希set，将J的插入到set中，然后循环S，再判断当前元素是否在J中即可，比较水。"></a>解题思路：本题是最基础的哈希集合的题目，一眼就可以看出来要使用哈希set，将J的插入到set中，然后循环S，再判断当前元素是否在J中即可，比较水。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(<span class="built_in">string</span> J, <span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt;J_set;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;J.size();i++)&#123;</span><br><span class="line">            J_set.insert(J[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(J_set.count(S[i])&gt;<span class="number">0</span>)count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;给定字符串&lt;code&gt;J&lt;/code&gt; 代表石头中宝石的类型，和字符串 &lt;code&gt;S&lt;/code&gt;代表你拥有的石头。 &lt;code&gt;S&lt;/code&gt; 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;J&lt;/code&gt; 中的字母不重复，&lt;code&gt;J&lt;/code&gt; 和 &lt;code&gt;S&lt;/code&gt;中的所有字符都是字母。字母区分大小写，因此&lt;code&gt;&amp;quot;a&amp;quot;&lt;/code&gt;和&lt;code&gt;&amp;quot;A&amp;quot;&lt;/code&gt;是不同类型的石头。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>36有效的数独</title>
    <link href="https://cblog.club/ck32ty17t0009xwg471rr6c0e.html"/>
    <id>https://cblog.club/ck32ty17t0009xwg471rr6c0e.html</id>
    <published>2019-11-15T13:37:43.000Z</published>
    <updated>2019-11-15T13:49:04.784Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>判断一个 9x9 的数独是否有效。只需要<strong>根据以下规则</strong>，验证已经填入的数字是否有效即可。</p><a id="more"></a><ol><li>数字 <code>1-9</code> 在每一行只能出现一次。</li><li>数字 <code>1-9</code> 在每一列只能出现一次。</li><li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。</li></ol><img src="/ck32ty17t0009xwg471rr6c0e/1.jpg" class=""><p>上图是一个部分填充的有效的数独。</p><p>数独部分空格内已填入了数字，空白格用 <code>&#39;.&#39;</code> 表示。</p><blockquote><p><strong>示例 1:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [<span class="string">"5"</span>,<span class="string">"3"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"7"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],</span><br><span class="line">  [<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"1"</span>,<span class="string">"9"</span>,<span class="string">"5"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],</span><br><span class="line">  [<span class="string">"."</span>,<span class="string">"9"</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>],</span><br><span class="line">  [<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"3"</span>],</span><br><span class="line">  [<span class="string">"4"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"3"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"1"</span>],</span><br><span class="line">  [<span class="string">"7"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"2"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>],</span><br><span class="line">  [<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"2"</span>,<span class="string">"8"</span>,<span class="string">"."</span>],</span><br><span class="line">  [<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"4"</span>,<span class="string">"1"</span>,<span class="string">"9"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"5"</span>],</span><br><span class="line">  [<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"7"</span>,<span class="string">"9"</span>]</span><br><span class="line">]</span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [<span class="string">"8"</span>,<span class="string">"3"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"7"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],</span><br><span class="line">  [<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"1"</span>,<span class="string">"9"</span>,<span class="string">"5"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],</span><br><span class="line">  [<span class="string">"."</span>,<span class="string">"9"</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>],</span><br><span class="line">  [<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"3"</span>],</span><br><span class="line">  [<span class="string">"4"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"3"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"1"</span>],</span><br><span class="line">  [<span class="string">"7"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"2"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>],</span><br><span class="line">  [<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"2"</span>,<span class="string">"8"</span>,<span class="string">"."</span>],</span><br><span class="line">  [<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"4"</span>,<span class="string">"1"</span>,<span class="string">"9"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"5"</span>],</span><br><span class="line">  [<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"7"</span>,<span class="string">"9"</span>]</span><br><span class="line">]</span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">解释: 除了第一行的第一个数字从 <span class="number">5</span> 改为 <span class="number">8</span> 以外，空格内其他数字均与 示例<span class="number">1</span> 相同。</span><br><span class="line">     但由于位于左上角的 <span class="number">3</span>x3 宫内有两个 <span class="number">8</span> 存在, 因此这个数独是无效的。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>一个有效的数独（部分已被填充）不一定是可解的</li><li>只需要根据以上规则，验证已经填入的数字是否有效即可</li><li>给定数独序列只包含数字 <code>1-9</code> 和字符 <code>&#39;.&#39;</code> </li><li>给定数独永远是 <code>9x9</code> 形式的</li></ul></blockquote><h6 id="解题思路：本题刚开始，在思考怎么设计哈希映射中的键时，还是没有想好，但是总的思想就是判断三个，行，列，3x3的矩阵中不能有重复元素，将行号，列号，块号-通过行列求得，这个需要再思考-设计为键，只需要判断当前元素是否在判断的相应区域出现过，出现过就设置为1，如果判断其他的元素时，value为1，那么就代表当前区域出现过当前元素，不符合题目要求。"><a href="#解题思路：本题刚开始，在思考怎么设计哈希映射中的键时，还是没有想好，但是总的思想就是判断三个，行，列，3x3的矩阵中不能有重复元素，将行号，列号，块号-通过行列求得，这个需要再思考-设计为键，只需要判断当前元素是否在判断的相应区域出现过，出现过就设置为1，如果判断其他的元素时，value为1，那么就代表当前区域出现过当前元素，不符合题目要求。" class="headerlink" title="解题思路：本题刚开始，在思考怎么设计哈希映射中的键时，还是没有想好，但是总的思想就是判断三个，行，列，3x3的矩阵中不能有重复元素，将行号，列号，块号(通过行列求得，这个需要再思考= =)设计为键，只需要判断当前元素是否在判断的相应区域出现过，出现过就设置为1，如果判断其他的元素时，value为1，那么就代表当前区域出现过当前元素，不符合题目要求。"></a>解题思路：本题刚开始，在思考怎么设计哈希映射中的键时，还是没有想好，但是总的思想就是判断三个，行，列，3x3的矩阵中不能有重复元素，将行号，列号，块号(通过行列求得，这个需要再思考= =)设计为键，只需要判断当前元素是否在判断的相应区域出现过，出现过就设置为1，如果判断其他的元素时，value为1，那么就代表当前区域出现过当前元素，不符合题目要求。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;row(<span class="number">9</span>),col(<span class="number">9</span>),block(<span class="number">9</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">9</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">char</span> cur=board[i][j];</span><br><span class="line">                <span class="keyword">if</span>(cur==<span class="string">'.'</span>)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> block_index=(i/<span class="number">3</span>)*<span class="number">3</span>+(j/<span class="number">3</span>);</span><br><span class="line">                <span class="keyword">if</span>(row[i][cur]||col[j][cur]||block[block_index][cur])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                row[i][cur]=<span class="number">1</span>;</span><br><span class="line">                col[j][cur]=<span class="number">1</span>;</span><br><span class="line">                block[block_index][cur]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;判断一个 9x9 的数独是否有效。只需要&lt;strong&gt;根据以下规则&lt;/strong&gt;，验证已经填入的数字是否有效即可。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>49字母异位词分组</title>
    <link href="https://cblog.club/ck32ty198000jxwg4cmukbz6o.html"/>
    <id>https://cblog.club/ck32ty198000jxwg4cmukbz6o.html</id>
    <published>2019-11-15T13:28:41.000Z</published>
    <updated>2019-11-15T13:38:28.556Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p> 给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 </p><a id="more"></a><blockquote><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="string">"eat"</span>, <span class="string">"tea"</span>, <span class="string">"tan"</span>, <span class="string">"ate"</span>, <span class="string">"nat"</span>, <span class="string">"bat"</span>],</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="string">"ate"</span>,<span class="string">"eat"</span>,<span class="string">"tea"</span>],</span><br><span class="line">  [<span class="string">"nat"</span>,<span class="string">"tan"</span>],</span><br><span class="line">  [<span class="string">"bat"</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>所有输入均为小写字母。</li><li>不考虑答案输出的顺序。</li></ul></blockquote><h6 id="解题思路：本题得益于之前的设计键的思想（将不同字符串的映射转换成按照字母大小排序后的字符串，这样符合题目要求的字符串就会被分到同一组），得以有思路，第一次做的思路是，循环字符串，然后存到哈希映射中，同步存到哈希集合set中，这样便于循环将他们分组，刚开始看错了，以为是一个完整的字符串，还考虑用逗号分成一个个字符串，后来发现已经分好了-，第二个思路比较好，借鉴别人的，就是key是排序好的，value是一个字符数组，然后将整个字符数组直接插入到二维数组中即可，不再需要第一次的循环插入。"><a href="#解题思路：本题得益于之前的设计键的思想（将不同字符串的映射转换成按照字母大小排序后的字符串，这样符合题目要求的字符串就会被分到同一组），得以有思路，第一次做的思路是，循环字符串，然后存到哈希映射中，同步存到哈希集合set中，这样便于循环将他们分组，刚开始看错了，以为是一个完整的字符串，还考虑用逗号分成一个个字符串，后来发现已经分好了-，第二个思路比较好，借鉴别人的，就是key是排序好的，value是一个字符数组，然后将整个字符数组直接插入到二维数组中即可，不再需要第一次的循环插入。" class="headerlink" title="解题思路：本题得益于之前的设计键的思想（将不同字符串的映射转换成按照字母大小排序后的字符串，这样符合题目要求的字符串就会被分到同一组），得以有思路，第一次做的思路是，循环字符串，然后存到哈希映射中，同步存到哈希集合set中，这样便于循环将他们分组，刚开始看错了，以为是一个完整的字符串，还考虑用逗号分成一个个字符串，后来发现已经分好了= =，第二个思路比较好，借鉴别人的，就是key是排序好的，value是一个字符数组，然后将整个字符数组直接插入到二维数组中即可，不再需要第一次的循环插入。"></a>解题思路：本题得益于之前的设计键的思想（将不同字符串的映射转换成按照字母大小排序后的字符串，这样符合题目要求的字符串就会被分到同一组），得以有思路，第一次做的思路是，循环字符串，然后存到哈希映射中，同步存到哈希集合set中，这样便于循环将他们分组，刚开始看错了，以为是一个完整的字符串，还考虑用逗号分成一个个字符串，后来发现已经分好了= =，第二个思路比较好，借鉴别人的，就是key是排序好的，value是一个字符数组，然后将整个字符数组直接插入到二维数组中即可，不再需要第一次的循环插入。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;</span></span><br><span class="line"><span class="comment">        unordered_set&lt;string&gt;uset;</span></span><br><span class="line"><span class="comment">        unordered_multimap&lt;string,string&gt;umap;</span></span><br><span class="line"><span class="comment">        vector&lt;vector&lt;string&gt;&gt;result;</span></span><br><span class="line"><span class="comment">        vector&lt;string&gt;cur_str;</span></span><br><span class="line"><span class="comment">        for(auto str:strs)&#123;</span></span><br><span class="line"><span class="comment">            string temp=str;</span></span><br><span class="line"><span class="comment">            sort(temp.begin(),temp.end());</span></span><br><span class="line"><span class="comment">            umap.insert(&#123;str,temp&#125;);</span></span><br><span class="line"><span class="comment">            uset.insert(temp);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        for(auto it=uset.begin();it!=uset.end();it++)&#123;</span></span><br><span class="line"><span class="comment">            for(auto it_map=umap.begin();it_map!=umap.end();it_map++)&#123;</span></span><br><span class="line"><span class="comment">                if(*it==it_map-&gt;second)cur_str.push_back(it_map-&gt;first);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            result.push_back(cur_str);</span></span><br><span class="line"><span class="comment">            cur_str.clear();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return result;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupAnagrams(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;umap;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str:strs)&#123;</span><br><span class="line">            <span class="built_in">string</span> temp=str;</span><br><span class="line">            sort(temp.begin(),temp.end());</span><br><span class="line">            umap[temp].push_back(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> um:umap)&#123;</span><br><span class="line">            result.push_back(um.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt; 给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>RNN循环神经网络</title>
    <link href="https://cblog.club/ck32ty19x000rxwg45kw6e02g.html"/>
    <id>https://cblog.club/ck32ty19x000rxwg45kw6e02g.html</id>
    <published>2019-11-15T13:04:38.000Z</published>
    <updated>2019-11-15T13:25:36.771Z</updated>
    
    <content type="html"><![CDATA[<h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><ul><li>之前见过的神经网络都有一个特点，就是没有记忆，只能单独处理每个输入，在输入与输入之间没有保存任何状态，对于这种网络，要想处理数据点的序列或时间序列，需要向网络同时展示整个序列，即将序列转换成单个数据点，然后一次性处理，这种网络叫做前馈网络。</li></ul><a id="more"></a><ul><li>细想BP算法,CNN(卷积神经网络)我们会发现, 他们的输出都是只考虑前一个输入的影响而不考虑其它时刻输入的影响, 比如简单的猫,狗,手写数字等单个物体的识别具有较好的效果. 但是, 对于一些与时间先后有关的, 比如视频的下一时刻的预测,文档前后文内容的预测等, 这些算法的表现就不尽如人意了。因此, RNN就应运而生了。</li></ul><h5 id="循环神经网络"><a href="#循环神经网络" class="headerlink" title="循环神经网络"></a>循环神经网络</h5><ul><li><p>RNN是一种特殊的神经网络结构, 它是根据”人的认知是基于过往的经验和记忆”这一观点提出的. 它与DNN,CNN不同的是: 它不仅考虑前一时刻的输入,而且赋予了网络对前面的内容的一种’记忆’功能.</p></li><li><p>RNN之所以称为循环神经网路，即一个序列当前的输出与前面的输出也有关。具体的表现形式为网络会对前面的信息进行记忆并应用于当前输出的计算中，即隐藏层之间的节点不再无连接而是有连接的，并且隐藏层的输入不仅包括输入层的输出还包括上一时刻隐藏层的输出。</p></li><li><img src="/ck32ty19x000rxwg45kw6e02g/1.png" class=""></li></ul><h5 id="RNN前向传播"><a href="#RNN前向传播" class="headerlink" title="RNN前向传播"></a>RNN前向传播</h5><img src="/ck32ty19x000rxwg45kw6e02g/2.png" class=""><p>我们可以看到RNN层级结构较之于CNN来说比较简单, 它主要有<strong>输入层</strong>,<strong>Hidden Layer</strong>, <strong>输出层</strong>组成。</p><p>并且会发现在<strong>Hidden Layer</strong> 有一个箭头表示数据的循环更新, 这个就是实现时间记忆功能的方法。</p><img src="/ck32ty19x000rxwg45kw6e02g/3.png" class=""><p>所示为Hidden Layer的层级展开图. t-1, t, t+1表示时间序列. X表示输入的样本. St表示样本在时间t处的的记忆,<strong>St = f(W*St-1 +U*Xt)</strong>. W表示输入的权重, U表示此刻输入的样本的权重, V表示输出的样本权重。</p><p> 在t =1时刻, 一般初始化输入S0=0, 随机初始化W,U,V, 进行下面的公式计算:</p><img src="/ck32ty19x000rxwg45kw6e02g/4.png" class=""><p>其中,f和g均为激活函数. 其中f可以是tanh,relu,sigmoid等激活函数，g通常是softmax也可以是其他。</p><p>时间就向前推进，此时的状态s1作为时刻1的记忆状态将参与下一个时刻的预测活动，也就是:</p><img src="/ck32ty19x000rxwg45kw6e02g/5.png" class=""><p>以此类推, 可以得到最终的输出值为:</p><img src="/ck32ty19x000rxwg45kw6e02g/6.png" class=""><p><strong>注意</strong>: </p><ul><li><p>这里的<strong>W,U,V</strong>在每个时刻都是相等的(<strong>权重共享</strong>).</p></li><li><p>隐藏状态可以理解为: S=f(现有的输入+过去记忆总结) </p></li></ul><h5 id="RNN反向传播"><a href="#RNN反向传播" class="headerlink" title="RNN反向传播"></a>RNN反向传播</h5><p>我们介绍了RNN的前向传播的方式, 那么RNN的权重参数W,U,V都是怎么更新的呢?</p><p>每一次的输出值Ot都会产生一个误差值Et, 则总的误差可以表示为:<img src="/ck32ty19x000rxwg45kw6e02g/7.png" class=""></p><p>则损失函数可以使用交叉熵损失函数也可以使用平方误差损失函数。</p><p>由于每一步的输出不仅仅依赖当前步的网络，并且还需要前若干步网络的状态，那么这种BP改版的算法叫做Backpropagation Through Time(BPTT) , 也就是将输出端的误差值反向传递,运用梯度下降法进行更新。</p><p>也就是要求参数的梯度：</p><img src="/ck32ty19x000rxwg45kw6e02g/8.png" class=""><p>首先我们求解<strong>W的更新方法</strong>, 由前面的W的更新可以看出它是每个时刻的偏差的偏导数之和. </p><p> 在这里我们以 t = 3时刻为例, 根据链式求导法则可以得到t = 3时刻的偏导数为:</p><img src="/ck32ty19x000rxwg45kw6e02g/9.png" class=""><p>此时, 根据公式<img src="/ck32ty19x000rxwg45kw6e02g/10.png" class="">我们会发现, S3除了和W有关之外, 还和前一时刻S2有关。</p><p>对于S3直接展开得到下面的式子:</p><img src="/ck32ty19x000rxwg45kw6e02g/11.png" class=""><p>对于S2直接展开得到下面的式子:</p><img src="/ck32ty19x000rxwg45kw6e02g/12.png" class=""><p>对于S1直接展开得到下面的式子:</p><img src="/ck32ty19x000rxwg45kw6e02g/13.png" class=""><p>将上述三个式子合并得到:</p><img src="/ck32ty19x000rxwg45kw6e02g/14.png" class=""><p>这样就得到了公式:</p><img src="/ck32ty19x000rxwg45kw6e02g/15.png" class=""><p>这里要说明的是:<img src="/ck32ty19x000rxwg45kw6e02g/18.png" class="">表示的是S3对W直接求导, 不考虑S2的影响.(也就是例如y = f(x)*g(x)对x求导一样)</p><p>其次是对<strong>U的更新方法</strong>. 由于参数U求解和W求解类似,这里就不在赘述了,最终得到的具体的公式如下:</p><img src="/ck32ty19x000rxwg45kw6e02g/16.png" class=""><p>最后,给出<strong>V的更新公式</strong>(V只和输出O有关):</p><img src="/ck32ty19x000rxwg45kw6e02g/17.png" class="">]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;之前见过的神经网络都有一个特点，就是没有记忆，只能单独处理每个输入，在输入与输入之间没有保存任何状态，对于这种网络，要想处理数据点的序列或时间序列，需要向网络同时展示整个序列，即将序列转换成单个数据点，然后一次性处理，这种网络叫做前馈网络。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="深度学习" scheme="https://cblog.club/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="https://cblog.club/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>深度学习应用于文本和序列</title>
    <link href="https://cblog.club/ck32ty1at000uxwg445lgd1di.html"/>
    <id>https://cblog.club/ck32ty1at000uxwg445lgd1di.html</id>
    <published>2019-11-15T12:23:48.000Z</published>
    <updated>2019-11-15T13:25:52.960Z</updated>
    
    <content type="html"><![CDATA[<p>文本可以理解成单词序列、字符序列，序列又有时间序列和其他的一般序列。<a id="more"></a></p><p>处理序列的两种基本的深度学习模型</p><ul><li>循环神经网络（RNN）</li><li>一维卷积神经网络</li></ul><p>模型的输入不能是原始文本，他只能处理数值张量，所以要先将文本向量化</p><ul><li>文本向量化：将文本转换为数值张量的过程</li></ul><p>文本向量化的方法：</p><ul><li>将文本分割成单词，将每个单词转换为一个向量</li><li>将文本分割成字符，将每个字符转换为一个向量</li><li>提取单词或字符的n-gram，并将每个n-gram转换为一个向量。n-gram是多个连续单词或字符的集合（n-gram之间可重叠）</li></ul><p>将文本分解而成的单元（单词、字符、n-gram）叫做标记</p><p>将文本分解成标记的过程叫做分词</p> <img src="/ck32ty1at000uxwg445lgd1di/fenci.png" class="" title="分词的过程"><p>将向量与标记关联的方法：</p><ul><li>对标记做one-hot编码</li><li>标记嵌入（token embedding），该方法通常只用于单词，叫做词嵌入（word embedding）<ul><li>one-hot得到的向量是二进制的、稀疏的（绝大部分元素都是0）、维数很高的（维数等于词表中单词个数）</li><li>词嵌入是低维的浮点数向量（密集向量），并且是从数据中学习得到的，常见的维度是256、512、1024（处理非常大的词表），而one-hot编码维度很高（20000或更高）</li><li><img src="/ck32ty1at000uxwg445lgd1di/bianma.png" class="" title="不同方法编码对比"></li></ul></li></ul><p>获取词嵌入的方法：</p><ul><li>在完成主任务（比如情感预测、文档分类）的同时学习词嵌入，在这种情况下，一开始是随机的词向量，然后对这些词向量进行学习，其学习方式和学习神经网络权重相同</li><li>在不同与待解决的机器学习任务上预计算好词嵌入，然后将其加载到模型中，这些词嵌入叫做预训练词嵌入</li></ul><p>利用embedding层学习词嵌入（对应方法一）</p><ul><li><p>词嵌入的作用就是将人类语言映射到几何空间，词向量之间的几何关系表示这些词之间的语义关系。但由于语言是特定文化和特定环境的反射，所以要根据实际情况，不同问题不同分析。所以一个合理的做法就是对每个新任务都学习一个新的词嵌入空间，在keras框架中，我么只需要学习一个层的权重即可，即embedding层。</p><ul><li>embedding层：可以理解成一个字典，将整数序列（二维整数张量）（表示特定单词）映射为密集向量</li></ul><img src="/ck32ty1at000uxwg445lgd1di/embedding.png" class="" title="embedding层作用过程"><ul><li>接收整数序列作为输入，然后在字典中查找整数，最后返回相关联的向量（返回的是一个三维浮点数张量）</li><li>将一个embedding层实例化时，他的权重（即标记向量的内部字典）初始时是随机的，在训练过程中利用反向传播来逐渐调节这些词向量，改变空间结构以便下游模型可以使用。</li></ul></li></ul><p>利用预训练的词嵌入</p><ul><li>背景：可用的训练数据很少，无法学习适合特定任务的词嵌入</li><li>从预计算的嵌入空间中加载嵌入张量，其原理与在图像分类中使用预训练的卷积神经网络是一样的<ul><li>原理：没有足够的数据来自己学习真正的特征，但是你需要的特征是非常通用的，很常见，那么就可以重复使用在其他问题上学到的特征</li></ul></li></ul><p>预计算的词嵌入数据库：</p><ul><li>word2vec</li><li>GloVe</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文本可以理解成单词序列、字符序列，序列又有时间序列和其他的一般序列。
    
    </summary>
    
    
      <category term="深度学习" scheme="https://cblog.club/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="https://cblog.club/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>219存在重复元素II</title>
    <link href="https://cblog.club/ck32ty16r0002xwg40mahasdh.html"/>
    <id>https://cblog.club/ck32ty16r0002xwg40mahasdh.html</id>
    <published>2019-11-14T14:30:04.000Z</published>
    <updated>2019-11-15T07:02:42.555Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p> 给定一个整数数组和一个整数 <em>k</em>，判断数组中是否存在两个不同的索引 <em>i</em> 和 <em>j</em>，使得 <strong>nums [i] = nums [j]</strong>，并且 <em>i</em> 和 <em>j</em> 的差的绝对值最大为 <em>k</em>。 </p><a id="more"></a><blockquote><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3,1], k = 3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,0,1,1], k = 1</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3,1,2,3], k = 2</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></blockquote><h6 id="解题思路：本题思路比较清楚，就是使用哈希映射，当前元素值-gt-数组索引，循环当前数组，如果在哈希表中找到与当前元素相同的数，那么就计算他们之间的索引距离，如果小于等于给定K即可。"><a href="#解题思路：本题思路比较清楚，就是使用哈希映射，当前元素值-gt-数组索引，循环当前数组，如果在哈希表中找到与当前元素相同的数，那么就计算他们之间的索引距离，如果小于等于给定K即可。" class="headerlink" title="解题思路：本题思路比较清楚，就是使用哈希映射，当前元素值-&gt;数组索引，循环当前数组，如果在哈希表中找到与当前元素相同的数，那么就计算他们之间的索引距离，如果小于等于给定K即可。"></a>解题思路：本题思路比较清楚，就是使用哈希映射，当前元素值-&gt;数组索引，循环当前数组，如果在哈希表中找到与当前元素相同的数，那么就计算他们之间的索引距离，如果小于等于给定K即可。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_multimap</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;umap;</span><br><span class="line">        <span class="built_in">unordered_multimap</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">        <span class="keyword">int</span> cur_distance;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            it=umap.find(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(it!=umap.end())&#123;</span><br><span class="line">                cur_distance=i-(it-&gt;second);</span><br><span class="line">                <span class="keyword">if</span>(cur_distance&lt;=k)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            umap.insert(&#123;nums[i],i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt; 给定一个整数数组和一个整数 &lt;em&gt;k&lt;/em&gt;，判断数组中是否存在两个不同的索引 &lt;em&gt;i&lt;/em&gt; 和 &lt;em&gt;j&lt;/em&gt;，使得 &lt;strong&gt;nums [i] = nums [j]&lt;/strong&gt;，并且 &lt;em&gt;i&lt;/em&gt; 和 &lt;em&gt;j&lt;/em&gt; 的差的绝对值最大为 &lt;em&gt;k&lt;/em&gt;。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>350两个数组的交集II</title>
    <link href="https://cblog.club/ck32ty17o0008xwg4a9mzhwnt.html"/>
    <id>https://cblog.club/ck32ty17o0008xwg4a9mzhwnt.html</id>
    <published>2019-11-14T14:23:29.000Z</published>
    <updated>2019-11-14T14:35:03.314Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p> 给定两个数组，编写一个函数来计算它们的交集。<a id="more"></a> </p><blockquote><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">输出: [2,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">输出: [4,9]</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。</li><li>我们可以不考虑输出结果的顺序。</li></ul><p><strong><em>\</em>进阶:**</strong></p><ul><li>如果给定的数组已经排好序呢？你将如何优化你的算法？</li><li>如果 <em>nums1</em> 的大小比 <em>nums2</em> 小很多，哪种方法更优？</li><li>如果 <em>nums2</em> 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</li></ul></blockquote><h6 id="解题思路：本题和之前的求两个数组的交集不同，不同之处就在于，示例1，交集元素如果出现多次，那么结果中应该也是多次，处理操作就是使用unordered-multiset（允许重复元素出现）-那么就是如果当前元素在另一个哈希集合中找到，那么就将其插入到数组中，但是还要有一个操作，就是将另一个集合-中的当前元素删掉，因为有可能后边还会出现，造成结果错误。"><a href="#解题思路：本题和之前的求两个数组的交集不同，不同之处就在于，示例1，交集元素如果出现多次，那么结果中应该也是多次，处理操作就是使用unordered-multiset（允许重复元素出现）-那么就是如果当前元素在另一个哈希集合中找到，那么就将其插入到数组中，但是还要有一个操作，就是将另一个集合-中的当前元素删掉，因为有可能后边还会出现，造成结果错误。" class="headerlink" title="解题思路：本题和之前的求两个数组的交集不同，不同之处就在于，示例1，交集元素如果出现多次，那么结果中应该也是多次，处理操作就是使用unordered_multiset（允许重复元素出现）,那么就是如果当前元素在另一个哈希集合中找到，那么就将其插入到数组中，但是还要有一个操作，就是将另一个集合 中的当前元素删掉，因为有可能后边还会出现，造成结果错误。"></a>解题思路：本题和之前的求两个数组的交集不同，不同之处就在于，示例1，交集元素如果出现多次，那么结果中应该也是多次，处理操作就是使用unordered_multiset（允许重复元素出现）,那么就是如果当前元素在另一个哈希集合中找到，那么就将其插入到数组中，但是还要有一个操作，就是将另一个集合 中的当前元素删掉，因为有可能后边还会出现，造成结果错误。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersect(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        <span class="built_in">unordered_multiset</span>&lt;<span class="keyword">int</span>&gt;unums1;</span><br><span class="line">        <span class="built_in">unordered_multiset</span>&lt;<span class="keyword">int</span>&gt;unums2;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums1.size();i++)&#123;</span><br><span class="line">            unums1.insert(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums2.size();i++)&#123;</span><br><span class="line">            unums2.insert(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unordered_multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums1.size();i++)&#123;</span><br><span class="line">            it=unums2.find(nums1[i]);</span><br><span class="line">            <span class="keyword">if</span>(it!=unums2.end())&#123;</span><br><span class="line">                result.push_back(nums1[i]);</span><br><span class="line">                unums2.erase(it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt; 给定两个数组，编写一个函数来计算它们的交集。
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>387字符串中的第一个唯一字符</title>
    <link href="https://cblog.club/ck32ty18d000dxwg453zw6mxw.html"/>
    <id>https://cblog.club/ck32ty18d000dxwg453zw6mxw.html</id>
    <published>2019-11-14T14:16:46.000Z</published>
    <updated>2019-11-14T14:34:33.188Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p> 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。 <a id="more"></a></p><blockquote><p>案例:</p><p>s = “leetcode”<br>返回 0.</p><p>s = “loveleetcode”,<br>返回 2.</p><p>注意事项：您可以假定该字符串只包含小写字母。</p></blockquote><h6 id="解题思路：本题思路比较清楚，能想到使用哈希映射即可，字符-gt-出现次数，第一次循环，如果在哈希表中存在，次数就-，否则则置为0，最后再依次循环，找到第一个出现次数为0的字符即可。"><a href="#解题思路：本题思路比较清楚，能想到使用哈希映射即可，字符-gt-出现次数，第一次循环，如果在哈希表中存在，次数就-，否则则置为0，最后再依次循环，找到第一个出现次数为0的字符即可。" class="headerlink" title="解题思路：本题思路比较清楚，能想到使用哈希映射即可，字符-&gt;出现次数，第一次循环，如果在哈希表中存在，次数就++，否则则置为0，最后再依次循环，找到第一个出现次数为0的字符即可。"></a>解题思路：本题思路比较清楚，能想到使用哈希映射即可，字符-&gt;出现次数，第一次循环，如果在哈希表中存在，次数就++，否则则置为0，最后再依次循环，找到第一个出现次数为0的字符即可。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;umap;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            it=umap.find(s[i]);</span><br><span class="line">            <span class="keyword">if</span>(it!=umap.end())it-&gt;second++;</span><br><span class="line">            <span class="keyword">else</span> umap[s[i]]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            it=umap.find(s[i]);</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;second==<span class="number">0</span>)<span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt; 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>599两个列表的最小索引总和</title>
    <link href="https://cblog.club/ck32ty19b000mxwg4akx436d1.html"/>
    <id>https://cblog.club/ck32ty19b000mxwg4akx436d1.html</id>
    <published>2019-11-14T14:05:10.000Z</published>
    <updated>2019-11-14T14:14:22.975Z</updated>
    
    <content type="html"><![CDATA[<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>假设Andy和Doris想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。<a id="more"></a></p><p>你需要帮助他们用<strong>最少的索引和</strong>找出他们<strong>共同喜爱的餐厅</strong>。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设总是存在一个答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">[<span class="string">"Shogun"</span>, <span class="string">"Tapioca Express"</span>, <span class="string">"Burger King"</span>, <span class="string">"KFC"</span>]</span><br><span class="line">[<span class="string">"Piatti"</span>, <span class="string">"The Grill at Torrey Pines"</span>, <span class="string">"Hungry Hunter Steakhouse"</span>, <span class="string">"Shogun"</span>]</span><br><span class="line">输出: [<span class="string">"Shogun"</span>]</span><br><span class="line">解释: 他们唯一共同喜爱的餐厅是“Shogun”。</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">[<span class="string">"Shogun"</span>, <span class="string">"Tapioca Express"</span>, <span class="string">"Burger King"</span>, <span class="string">"KFC"</span>]</span><br><span class="line">[<span class="string">"KFC"</span>, <span class="string">"Shogun"</span>, <span class="string">"Burger King"</span>]</span><br><span class="line">输出: [<span class="string">"Shogun"</span>]</span><br><span class="line">解释: 他们共同喜爱且具有最小索引和的餐厅是“Shogun”，它有最小的索引和<span class="number">1</span>(<span class="number">0</span>+<span class="number">1</span>)。</span><br><span class="line">提示:</span><br><span class="line"></span><br><span class="line">两个列表的长度范围都在 [<span class="number">1</span>, <span class="number">1000</span>]内。</span><br><span class="line">两个列表中的字符串的长度将在[<span class="number">1</span>，<span class="number">30</span>]的范围内。</span><br><span class="line">下标从<span class="number">0</span>开始，到列表的长度减<span class="number">1</span>。</span><br><span class="line">两个列表都没有重复的元素。</span><br></pre></td></tr></table></figure><h6 id="解题思路：本题思路比较清晰，创建两个哈希映射，餐厅名称-gt-索引，然后再循环，如果再另一个哈希表找到当前餐厅，那么就将其两个索引加起来，和min比较，如果比min小，value值就设置成min，反之就设置成2000-（因为两个索引最多为1998），最后再次循环，找到value值为min的加入到数组中即可。"><a href="#解题思路：本题思路比较清晰，创建两个哈希映射，餐厅名称-gt-索引，然后再循环，如果再另一个哈希表找到当前餐厅，那么就将其两个索引加起来，和min比较，如果比min小，value值就设置成min，反之就设置成2000-（因为两个索引最多为1998），最后再次循环，找到value值为min的加入到数组中即可。" class="headerlink" title="解题思路：本题思路比较清晰，创建两个哈希映射，餐厅名称-&gt;索引，然后再循环，如果再另一个哈希表找到当前餐厅，那么就将其两个索引加起来，和min比较，如果比min小，value值就设置成min，反之就设置成2000+（因为两个索引最多为1998），最后再次循环，找到value值为min的加入到数组中即可。"></a>解题思路：本题思路比较清晰，创建两个哈希映射，餐厅名称-&gt;索引，然后再循环，如果再另一个哈希表找到当前餐厅，那么就将其两个索引加起来，和min比较，如果比min小，value值就设置成min，反之就设置成2000+（因为两个索引最多为1998），最后再次循环，找到value值为min的加入到数组中即可。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findRestaurant(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; list1, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; list2) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;map_l1;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;map_l2;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list1.size();i++)&#123;</span><br><span class="line">            map_l1[list1[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list2.size();i++)&#123;</span><br><span class="line">            map_l2[list2[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min=<span class="number">2000</span>;</span><br><span class="line">        <span class="keyword">int</span> cur_value;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it=map_l1.begin();it!=map_l1.end();it++)&#123;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;::iterator l2_iter;</span><br><span class="line">            l2_iter=map_l2.find(it-&gt;first);</span><br><span class="line">            <span class="keyword">if</span>(l2_iter!=map_l2.end())&#123;</span><br><span class="line">                cur_value=it-&gt;second+l2_iter-&gt;second;</span><br><span class="line">                <span class="keyword">if</span>(cur_value&lt;=min)&#123;</span><br><span class="line">                    min=cur_value;</span><br><span class="line">                    it-&gt;second=min;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> it-&gt;second=cur_value;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> it-&gt;second+=<span class="number">2000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it=map_l1.begin();it!=map_l1.end();it++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;second==min)result.push_back(it-&gt;first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h6&gt;&lt;p&gt;假设Andy和Doris想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>349两个数组的交集</title>
    <link href="https://cblog.club/ck32ty17f0006xwg4chs00i50.html"/>
    <id>https://cblog.club/ck32ty17f0006xwg4chs00i50.html</id>
    <published>2019-11-13T14:02:06.000Z</published>
    <updated>2019-11-14T13:54:38.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h2><h6 id="题目描述：给定两个数组，编写一个函数来计算它们的交集"><a href="#题目描述：给定两个数组，编写一个函数来计算它们的交集" class="headerlink" title="题目描述：给定两个数组，编写一个函数来计算它们的交集"></a>题目描述：给定两个数组，编写一个函数来计算它们的交集<a id="more"></a></h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>], nums2 = [<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出: [<span class="number">2</span>]</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: nums1 = [<span class="number">4</span>,<span class="number">9</span>,<span class="number">5</span>], nums2 = [<span class="number">9</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">4</span>]</span><br><span class="line">输出: [<span class="number">9</span>,<span class="number">4</span>]</span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">输出结果中的每个元素一定是唯一的。</span><br><span class="line">我们可以不考虑输出结果的顺序。</span><br></pre></td></tr></table></figure><h6 id="解题思路：本题比较容易想到使用哈希集合，因为哈希集合-unordered-set-寻找速度快，是o-1-级别（底层使用哈希表，而set底层使用红黑树，所以查找速度为O-logn-故使用前者），将其两个数组全部插入到哈希集合，然后再以一个哈希集合循环，能在另一个找到同元素，即为交集。"><a href="#解题思路：本题比较容易想到使用哈希集合，因为哈希集合-unordered-set-寻找速度快，是o-1-级别（底层使用哈希表，而set底层使用红黑树，所以查找速度为O-logn-故使用前者），将其两个数组全部插入到哈希集合，然后再以一个哈希集合循环，能在另一个找到同元素，即为交集。" class="headerlink" title="解题思路：本题比较容易想到使用哈希集合，因为哈希集合(unordered_set)寻找速度快，是o(1)级别（底层使用哈希表，而set底层使用红黑树，所以查找速度为O(logn),故使用前者），将其两个数组全部插入到哈希集合，然后再以一个哈希集合循环，能在另一个找到同元素，即为交集。"></a>解题思路：本题比较容易想到使用哈希集合，因为哈希集合(unordered_set)寻找速度快，是o(1)级别（底层使用哈希表，而set底层使用红黑树，所以查找速度为O(logn),故使用前者），将其两个数组全部插入到哈希集合，然后再以一个哈希集合循环，能在另一个找到同元素，即为交集。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersection(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;s1;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;s2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums1.size();i++)&#123;</span><br><span class="line">            s1.insert(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums2.size();i++)&#123;</span><br><span class="line">            s2.insert(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it=s2.begin();it!=s2.end();it++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1.count(*it)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                result.push_back(*it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;两个数组的交集&quot;&gt;&lt;a href=&quot;#两个数组的交集&quot; class=&quot;headerlink&quot; title=&quot;两个数组的交集&quot;&gt;&lt;/a&gt;两个数组的交集&lt;/h2&gt;&lt;h6 id=&quot;题目描述：给定两个数组，编写一个函数来计算它们的交集&quot;&gt;&lt;a href=&quot;#题目描述：给定两个数组，编写一个函数来计算它们的交集&quot; class=&quot;headerlink&quot; title=&quot;题目描述：给定两个数组，编写一个函数来计算它们的交集&quot;&gt;&lt;/a&gt;题目描述：给定两个数组，编写一个函数来计算它们的交集
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>136只出现一次的数字</title>
    <link href="https://cblog.club/ck32ty1650000xwg4esys60v1.html"/>
    <id>https://cblog.club/ck32ty1650000xwg4esys60v1.html</id>
    <published>2019-11-13T12:07:54.000Z</published>
    <updated>2019-11-13T14:10:12.716Z</updated>
    
    <content type="html"><![CDATA[<h2 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h2><h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: [<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure><h6 id="解题思路：本题抛开限制条件，非常简单，就是设置一个multiset（允许重复），然后全部插入之后，再次循环找到个数为1的数字。但是借鉴了别人的思路，太巧妙了，使用异或运算（a-0-a-a-a-0-并且最关键的就是疑惑还支持交换律-）"><a href="#解题思路：本题抛开限制条件，非常简单，就是设置一个multiset（允许重复），然后全部插入之后，再次循环找到个数为1的数字。但是借鉴了别人的思路，太巧妙了，使用异或运算（a-0-a-a-a-0-并且最关键的就是疑惑还支持交换律-）" class="headerlink" title="解题思路：本题抛开限制条件，非常简单，就是设置一个multiset（允许重复），然后全部插入之后，再次循环找到个数为1的数字。但是借鉴了别人的思路，太巧妙了，使用异或运算（a^0=a,a^a=0,并且最关键的就是疑惑还支持交换律- -）"></a>解题思路：本题抛开限制条件，非常简单，就是设置一个multiset（允许重复），然后全部插入之后，再次循环找到个数为1的数字。但是借鉴了别人的思路，太巧妙了，使用异或运算（a^0=a,a^a=0,并且最关键的就是疑惑还支持交换律- -）</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;uset;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(uset.count(nums[i])&gt;<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> uset.insert(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        unordered_set&lt;int&gt;uset;</span></span><br><span class="line"><span class="comment">        for(int i=0;i&lt;nums.size();i++)&#123;</span></span><br><span class="line"><span class="comment">             uset.insert(nums[i]);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        if(uset.size()==nums.size())return false;</span></span><br><span class="line"><span class="comment">        return true;*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;只出现一次的数字&quot;&gt;&lt;a href=&quot;#只出现一次的数字&quot; class=&quot;headerlink&quot; title=&quot;只出现一次的数字&quot;&gt;&lt;/a&gt;只出现一次的数字&lt;/h2&gt;&lt;h6 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://cblog.club/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://cblog.club/tags/leetcode/"/>
    
  </entry>
  
</feed>
